From 7f3a19bc21831b728d0c73824e66f6e998655fb0 Mon Sep 17 00:00:00 2001
From: xjljian <xjlxxx3@gmail.com>
Date: Sun, 23 Feb 2014 19:13:38 +0800
Subject: [PATCH 1/2] Add support for MultiSim

Change-Id: I915927f8d939fec984f73804f8636dcb96cd3b7f
---
 Android.mk                                         |    5 +
 core/java/android/app/ContextImpl.java             |    8 +
 core/java/android/content/Context.java             |   15 +-
 core/java/android/net/MobileDataStateTracker.java  |  118 +-
 core/java/android/net/NetworkIdentity.java         |   42 +-
 core/java/android/provider/CallLog.java            |   31 +
 core/java/android/provider/ContactsContract.java   |   25 +
 core/java/android/provider/LocalGroups.java        |  155 +++
 core/java/android/provider/Settings.java           |   62 +
 core/res/AndroidManifest.xml                       |    2 +-
 core/res/res/values-zh-rCN/strings.xml             |    1 +
 core/res/res/values/config.xml                     |   26 +
 core/res/res/values/strings.xml                    |   26 +-
 core/res/res/values/symbols.xml                    |   20 +
 data/sounds/ringtones/BOOTES.ogg                   |  Bin 26310 -> 26309 bytes
 data/sounds/ringtones/ogg/Bootes.ogg               |  Bin 26273 -> 26272 bytes
 media/java/android/media/AudioService.java         |   12 +-
 .../res/drawable-hdpi/sym_keyboard_cancel.png      |  Bin 0 -> 2573 bytes
 .../res/drawable-ldpi/sym_keyboard_cancel.png      |  Bin 0 -> 573 bytes
 .../res/drawable-mdpi/sym_keyboard_cancel.png      |  Bin 0 -> 573 bytes
 .../res/drawable-xhdpi/sym_keyboard_cancel.png     |  Bin 0 -> 2573 bytes
 .../res/layout/keyguard_emergency_carrier_area.xml |    9 +
 .../res/layout/msim_keyguard_carrier_area.xml      |   41 +
 .../res/layout/msim_keyguard_sim_pin_view.xml      |  237 ++++
 .../res/layout/msim_keyguard_sim_puk_view.xml      |  232 ++++
 packages/Keyguard/res/values/strings.xml           |   32 +
 .../src/com/android/keyguard/CarrierText.java      |   34 +-
 .../src/com/android/keyguard/KeyguardHostView.java |   34 +-
 .../android/keyguard/KeyguardSecurityModel.java    |   18 +-
 .../com/android/keyguard/KeyguardSimPinView.java   |   38 +-
 .../com/android/keyguard/KeyguardSimPukView.java   |   31 +-
 .../android/keyguard/KeyguardUpdateMonitor.java    |  178 ++-
 .../keyguard/KeyguardUpdateMonitorCallback.java    |   18 +
 .../com/android/keyguard/KeyguardViewMediator.java |   35 +-
 .../com/android/keyguard/msim/MSimCarrierText.java |   99 ++
 .../keyguard/msim/MSimKeyguardSimPinView.java      |  245 ++++
 .../keyguard/msim/MSimKeyguardSimPukView.java      |  182 +++
 .../android/providers/settings/DatabaseHelper.java |   24 +-
 .../res/layout/msim_signal_cluster_view.xml        |  210 ++++
 packages/SystemUI/res/layout/msim_status_bar.xml   |  162 +++
 .../SystemUI/res/layout/msim_super_status_bar.xml  |   53 +
 .../SystemUI/res/layout/signal_cluster_view.xml    |    7 +
 .../SystemUI/res/layout/status_bar_expanded.xml    |   26 +-
 packages/SystemUI/res/layout/subs_label.xml        |   34 +
 .../systemui/statusbar/MSimSignalClusterView.java  |  242 ++++
 .../systemui/statusbar/SignalClusterView.java      |   17 +-
 .../systemui/statusbar/phone/PhoneStatusBar.java   |  151 ++-
 .../statusbar/phone/PhoneStatusBarPolicy.java      |   34 +-
 .../statusbar/phone/PhoneStatusBarTransitions.java |    7 +-
 .../statusbar/policy/MSimNetworkController.java    | 1270 ++++++++++++++++++++
 .../statusbar/policy/NetworkController.java        |  203 ++--
 .../internal/policy/impl/PhoneWindowManager.java   |    3 +-
 .../com/android/server/MSimTelephonyRegistry.java  |  863 +++++++++++++
 services/java/com/android/server/SystemServer.java |   16 +
 .../java/com/android/server/TelephonyRegistry.java |   21 +
 .../server/connectivity/DataConnectionStats.java   |    2 +-
 .../server/net/NetworkPolicyManagerService.java    |   25 +-
 .../com/android/server/power/ShutdownThread.java   |   43 +-
 .../android/telephony/MSimTelephonyManager.java    | 1135 +++++++++++++++++
 .../java/android/telephony/PhoneNumberUtils.java   |   32 +-
 .../java/android/telephony/PhoneStateListener.java |   19 +
 telephony/java/android/telephony/ServiceState.java |   17 +-
 .../java/android/telephony/SignalStrength.java     |  109 +-
 .../java/android/telephony/TelephonyManager.java   |   89 +-
 .../android/telephony/gsm/GsmCellLocation.java     |   11 +-
 .../android/internal/telephony/DctConstants.java   |    6 +
 .../java/com/android/internal/telephony/ISms.aidl  |   31 +
 .../com/android/internal/telephony/ITelephony.aidl |    5 +
 .../internal/telephony/ITelephonyRegistryMSim.aidl |   48 +
 .../internal/telephony/IccCardConstants.java       |   17 +-
 .../android/internal/telephony/MSimConstants.java  |   62 +
 .../android/internal/telephony/PhoneConstants.java |    1 +
 .../android/internal/telephony/RILConstants.java   |   34 +-
 .../android/internal/telephony/SmsConstants.java   |    1 +
 .../internal/telephony/TelephonyIntents.java       |   12 +
 .../internal/telephony/TelephonyProperties.java    |   37 +-
 .../internal/telephony/msim/IPhoneSubInfoMSim.aidl |   81 ++
 .../internal/telephony/msim/ITelephonyMSim.aidl    |  373 ++++++
 78 files changed, 7255 insertions(+), 289 deletions(-)
 create mode 100644 core/java/android/provider/LocalGroups.java
 create mode 100644 packages/Keyguard/res/drawable-hdpi/sym_keyboard_cancel.png
 create mode 100755 packages/Keyguard/res/drawable-ldpi/sym_keyboard_cancel.png
 create mode 100644 packages/Keyguard/res/drawable-mdpi/sym_keyboard_cancel.png
 create mode 100644 packages/Keyguard/res/drawable-xhdpi/sym_keyboard_cancel.png
 create mode 100644 packages/Keyguard/res/layout/msim_keyguard_carrier_area.xml
 create mode 100644 packages/Keyguard/res/layout/msim_keyguard_sim_pin_view.xml
 create mode 100644 packages/Keyguard/res/layout/msim_keyguard_sim_puk_view.xml
 create mode 100644 packages/Keyguard/src/com/android/keyguard/msim/MSimCarrierText.java
 create mode 100644 packages/Keyguard/src/com/android/keyguard/msim/MSimKeyguardSimPinView.java
 create mode 100644 packages/Keyguard/src/com/android/keyguard/msim/MSimKeyguardSimPukView.java
 create mode 100644 packages/SystemUI/res/layout/msim_signal_cluster_view.xml
 create mode 100644 packages/SystemUI/res/layout/msim_status_bar.xml
 create mode 100644 packages/SystemUI/res/layout/msim_super_status_bar.xml
 create mode 100644 packages/SystemUI/res/layout/subs_label.xml
 create mode 100644 packages/SystemUI/src/com/android/systemui/statusbar/MSimSignalClusterView.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/statusbar/policy/MSimNetworkController.java
 create mode 100644 services/java/com/android/server/MSimTelephonyRegistry.java
 create mode 100644 telephony/java/android/telephony/MSimTelephonyManager.java
 create mode 100644 telephony/java/com/android/internal/telephony/ITelephonyRegistryMSim.aidl
 create mode 100644 telephony/java/com/android/internal/telephony/MSimConstants.java
 create mode 100644 telephony/java/com/android/internal/telephony/msim/IPhoneSubInfoMSim.aidl
 create mode 100644 telephony/java/com/android/internal/telephony/msim/ITelephonyMSim.aidl

diff --git a/Android.mk b/Android.mk
index 00b7550..02b22da 100644
--- a/Android.mk
+++ b/Android.mk
@@ -280,9 +280,12 @@ LOCAL_SRC_FILES += \
 	media/java/android/media/IRingtonePlayer.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
+	telephony/java/com/android/internal/telephony/msim/IPhoneSubInfoMSim.aidl \
 	telephony/java/com/android/internal/telephony/ITelephony.aidl \
+	telephony/java/com/android/internal/telephony/msim/ITelephonyMSim.aidl \
 	telephony/java/com/android/internal/telephony/ISms.aidl \
 	telephony/java/com/android/internal/telephony/ITelephonyRegistry.aidl \
+	telephony/java/com/android/internal/telephony/ITelephonyRegistryMSim.aidl \
 	telephony/java/com/android/internal/telephony/IWapPushManager.aidl \
 	wifi/java/android/net/wifi/IWifiManager.aidl \
 	wifi/java/android/net/wifi/p2p/IWifiP2pManager.aidl \
@@ -418,7 +421,9 @@ aidl_files := \
 	frameworks/base/location/java/com/android/internal/location/ProviderRequest.aidl \
 	frameworks/base/telephony/java/android/telephony/ServiceState.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
+	frameworks/base/telephony/java/com/android/internal/telephony/msim/IPhoneSubInfoMSim.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl \
+    frameworks/base/telephony/java/com/android/internal/telephony/msim/ITelephonyMSim.aidl \
 	frameworks/base/wifi/java/android/net/wifi/BatchedScanSettings.aidl \
 	frameworks/base/wifi/java/android/net/wifi/BatchedScanResult.aidl \
 
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 7e9ef30..954960a 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2006 The Android Open Source Project
  * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
@@ -103,6 +105,7 @@ import android.os.storage.IMountService;
 import android.os.storage.StorageManager;
 import android.print.IPrintManager;
 import android.print.PrintManager;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.TelephonyManager;
 import android.content.ClipboardManager;
 import android.util.AndroidRuntimeException;
@@ -509,6 +512,11 @@ class ContextImpl extends Context {
                     return new TelephonyManager(ctx.getOuterContext());
                 }});
 
+        registerService(MSIM_TELEPHONY_SERVICE, new ServiceFetcher() {
+                public Object createService(ContextImpl ctx) {
+                    return new MSimTelephonyManager(ctx.getOuterContext());
+                }});
+
         registerService(UI_MODE_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
                     return new UiModeManager();
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index b4e7d7a..f3899b1 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2006 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -1798,7 +1800,7 @@ public abstract class Context {
      * @hide like {@link #stopService(Intent)} but for a specific user.
      */
     public abstract boolean stopServiceAsUser(Intent service, UserHandle user);
-    
+
     /**
      * Connect to an application service, creating it if needed.  This defines
      * a dependency between your application and the service.  The given
@@ -2275,6 +2277,17 @@ public abstract class Context {
 
     /**
      * Use with {@link #getSystemService} to retrieve a
+     * {android.telephony.MSimTelephonyManager} for handling the management
+     * of the telephony features of the multi sim device.
+     *
+     * @see #getSystemService
+     * @see android.telephony.MSimTelephonyManager
+     * @hide
+     */
+    public static final String MSIM_TELEPHONY_SERVICE = "phone_msim";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
      * {@link android.text.ClipboardManager} for accessing and modifying
      * the contents of the global clipboard.
      *
diff --git a/core/java/android/net/MobileDataStateTracker.java b/core/java/android/net/MobileDataStateTracker.java
index c106514..7c407b0 100644
--- a/core/java/android/net/MobileDataStateTracker.java
+++ b/core/java/android/net/MobileDataStateTracker.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -28,6 +30,7 @@ import android.os.Message;
 import android.os.Messenger;
 import android.os.RemoteException;
 import android.os.ServiceManager;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.PhoneStateListener;
 import android.telephony.SignalStrength;
 import android.telephony.TelephonyManager;
@@ -36,6 +39,8 @@ import android.util.Slog;
 
 import com.android.internal.telephony.DctConstants;
 import com.android.internal.telephony.ITelephony;
+import com.android.internal.telephony.msim.ITelephonyMSim;
+import com.android.internal.telephony.MSimConstants;
 import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.TelephonyIntents;
 import com.android.internal.util.AsyncChannel;
@@ -59,6 +64,7 @@ public class MobileDataStateTracker extends BaseNetworkStateTracker {
 
     private PhoneConstants.DataState mMobileDataState;
     private ITelephony mPhoneService;
+    private ITelephonyMSim mMSimPhoneService;
 
     private String mApnType;
     private NetworkInfo mNetworkInfo;
@@ -248,6 +254,37 @@ public class MobileDataStateTracker extends BaseNetworkStateTracker {
                     log("Broadcast received: " + intent.getAction() + " apnType=" + apnType);
                 }
 
+                if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+                    int dds = 0;
+                    final int subscription = intent.getIntExtra(MSimConstants.SUBSCRIPTION_KEY,
+                            MSimConstants.DEFAULT_SUBSCRIPTION);
+                    getPhoneService(false);
+
+                   /*
+                    * If the phone process has crashed in the past, we'll get a
+                    * RemoteException and need to re-reference the service.
+                    */
+                    for (int retry = 0; retry < 2; retry++) {
+                        if (mMSimPhoneService == null) {
+                            loge("Ignoring get dds request because "
+                                    + "MSim Phone Service is not available");
+                            break;
+                        }
+
+                        try {
+                            dds = mMSimPhoneService.getPreferredDataSubscription();
+                        } catch (RemoteException e) {
+                            if (retry == 0) getPhoneService(true);
+                        }
+                    }
+                    log(String.format("subscription=%s, dds=%s", subscription, dds));
+                    if (subscription != dds) {
+                        log("ignore data connection state as sub:" + subscription +
+                                " is not current dds: " + dds);
+                        return;
+                    }
+                }
+
                 int oldSubtype = mNetworkInfo.getSubtype();
                 int newSubType = TelephonyManager.getDefault().getNetworkType();
                 String subTypeName = TelephonyManager.getDefault().getNetworkTypeName();
@@ -370,6 +407,13 @@ public class MobileDataStateTracker extends BaseNetworkStateTracker {
     }
 
     private void getPhoneService(boolean forceRefresh) {
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            if (mMSimPhoneService == null || forceRefresh) {
+                mMSimPhoneService = ITelephonyMSim.Stub.asInterface(
+                        ServiceManager.getService("phone_msim"));
+            }
+            return;
+        }
         if ((mPhoneService == null) || forceRefresh) {
             mPhoneService = ITelephony.Stub.asInterface(ServiceManager.getService("phone"));
         }
@@ -398,6 +442,7 @@ public class MobileDataStateTracker extends BaseNetworkStateTracker {
             networkTypeStr = "edge";
             break;
         case TelephonyManager.NETWORK_TYPE_UMTS:
+        case TelephonyManager.NETWORK_TYPE_TD_SCDMA:
             networkTypeStr = "umts";
             break;
         case TelephonyManager.NETWORK_TYPE_HSDPA:
@@ -550,15 +595,33 @@ public class MobileDataStateTracker extends BaseNetworkStateTracker {
          * RemoteException and need to re-reference the service.
          */
         for (int retry = 0; retry < 2; retry++) {
-            if (mPhoneService == null) {
-                loge("Ignoring mobile radio request because could not acquire PhoneService");
-                break;
-            }
+            if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+                if (mMSimPhoneService == null) {
+                    loge("Ignoring mobile radio request because "
+                            + "could not acquire MSim Phone Service");
+                    break;
+                }
 
-            try {
-                return mPhoneService.setRadio(turnOn);
-            } catch (RemoteException e) {
-                if (retry == 0) getPhoneService(true);
+                try {
+                    boolean result = true;
+                    for (int i = 0; i < MSimTelephonyManager.getDefault().getPhoneCount(); i++) {
+                        result = result && mMSimPhoneService.setRadio(turnOn, i);
+                    }
+                    return result;
+                } catch (RemoteException e) {
+                    if (retry == 0) getPhoneService(true);
+                }
+            } else {
+                if (mPhoneService == null) {
+                    loge("Ignoring mobile radio request because could not acquire PhoneService");
+                    break;
+                }
+
+                try {
+                    return mPhoneService.setRadio(turnOn);
+                } catch (RemoteException e) {
+                    if (retry == 0) getPhoneService(true);
+                }
             }
         }
 
@@ -689,19 +752,36 @@ public class MobileDataStateTracker extends BaseNetworkStateTracker {
          * RemoteException and need to re-reference the service.
          */
         for (int retry = 0; retry < 2; retry++) {
-            if (mPhoneService == null) {
-                loge("Ignoring feature request because could not acquire PhoneService");
-                break;
-            }
+            if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+                if (mMSimPhoneService == null) {
+                    loge("Ignoring feature request because could not acquire MSim Phone Service");
+                    break;
+                }
 
-            try {
-                if (enable) {
-                    return mPhoneService.enableApnType(apnType);
-                } else {
-                    return mPhoneService.disableApnType(apnType);
+                try {
+                    if (enable) {
+                        return mMSimPhoneService.enableApnType(apnType);
+                    } else {
+                        return mMSimPhoneService.disableApnType(apnType);
+                    }
+                } catch (RemoteException e) {
+                    if (retry == 0) getPhoneService(true);
+                }
+            } else {
+                if (mPhoneService == null) {
+                    loge("Ignoring feature request because could not acquire PhoneService");
+                    break;
+                }
+
+                try {
+                    if (enable) {
+                        return mPhoneService.enableApnType(apnType);
+                    } else {
+                        return mPhoneService.disableApnType(apnType);
+                    }
+                } catch (RemoteException e) {
+                    if (retry == 0) getPhoneService(true);
                 }
-            } catch (RemoteException e) {
-                if (retry == 0) getPhoneService(true);
             }
         }
 
diff --git a/core/java/android/net/NetworkIdentity.java b/core/java/android/net/NetworkIdentity.java
index 3c67bf9..c3fb7cf 100644
--- a/core/java/android/net/NetworkIdentity.java
+++ b/core/java/android/net/NetworkIdentity.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2011 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -24,8 +26,8 @@ import android.content.Context;
 import android.net.wifi.WifiInfo;
 import android.net.wifi.WifiManager;
 import android.os.Build;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.TelephonyManager;
-
 import com.android.internal.util.Objects;
 
 /**
@@ -148,13 +150,12 @@ public class NetworkIdentity {
         boolean roaming = false;
 
         if (isNetworkTypeMobile(type)) {
-            final TelephonyManager telephony = (TelephonyManager) context.getSystemService(
-                    Context.TELEPHONY_SERVICE);
-            roaming = telephony.isNetworkRoaming();
+            roaming = isDdsRoaming();
             if (state.subscriberId != null) {
                 subscriberId = state.subscriberId;
             } else {
-                subscriberId = telephony.getSubscriberId();
+                //used for dual sim data traffic statistics
+                subscriberId = getDdsSubscriberId();
             }
 
         } else if (type == TYPE_WIFI) {
@@ -170,4 +171,35 @@ public class NetworkIdentity {
 
         return new NetworkIdentity(type, subType, subscriberId, networkId, roaming);
     }
+
+    private static boolean isDdsRoaming() {
+        MSimTelephonyManager mtm = MSimTelephonyManager.getDefault();
+        TelephonyManager tm = TelephonyManager.getDefault();
+        if (mtm.isMultiSimEnabled()) {
+            return mtm.isNetworkRoaming(mtm.getPreferredDataSubscription());
+        } else {
+            return tm.isNetworkRoaming();
+        }
+    }
+
+    public static String getDdsSubscriberId() {
+        MSimTelephonyManager mtm = MSimTelephonyManager.getDefault();
+        TelephonyManager tm = TelephonyManager.getDefault();
+        if (mtm.isMultiSimEnabled()) {
+            return mtm.getSubscriberId(mtm.getPreferredDataSubscription());
+        } else {
+            return tm.getSubscriberId();
+        }
+    }
+
+    public static boolean isDdsReady() {
+        MSimTelephonyManager mtm = MSimTelephonyManager.getDefault();
+        TelephonyManager tm = TelephonyManager.getDefault();
+        if (mtm.isMultiSimEnabled()) {
+            return mtm.getSimState(mtm.getPreferredDataSubscription())
+                    == TelephonyManager.SIM_STATE_READY;
+        } else {
+            return tm.getSimState() == TelephonyManager.SIM_STATE_READY;
+        }
+    }
 }
diff --git a/core/java/android/provider/CallLog.java b/core/java/android/provider/CallLog.java
index a6f23a8..96c47d8 100644
--- a/core/java/android/provider/CallLog.java
+++ b/core/java/android/provider/CallLog.java
@@ -28,6 +28,7 @@ import android.provider.ContactsContract.DataUsageFeedback;
 import android.text.TextUtils;
 
 import com.android.internal.telephony.CallerInfo;
+import com.android.internal.telephony.MSimConstants;
 import com.android.internal.telephony.PhoneConstants;
 
 /**
@@ -287,6 +288,13 @@ public class CallLog {
         public static final String CACHED_FORMATTED_NUMBER = "formatted_number";
 
         /**
+         * The subscription id.
+         * <P>Type: Integer</P>
+         * @hide
+         */
+        public static final String SUBSCRIPTION = MSimConstants.SUBSCRIPTION_KEY;
+
+         /**
          * Adds a call to the call log.
          *
          * @param ci the CallerInfo object to get the target contact from.  Can be null
@@ -304,6 +312,28 @@ public class CallLog {
          */
         public static Uri addCall(CallerInfo ci, Context context, String number,
                 int presentation, int callType, long start, int duration) {
+            return addCall(ci, context, number, presentation,
+                    callType, start, duration, MSimConstants.DEFAULT_SUBSCRIPTION);
+        }
+
+        /**
+         * Add a call to the call log for multi sim, and it can be used in TSTS.
+         *
+         * @param ci the CallerInfo object to get the target contact from.  Can be null
+         * if the contact is unknown.
+         * @param context the context used to get the ContentResolver
+         * @param number the phone number to be added to the calls db
+         * @param presentation the number presenting rules set by the network for
+         *        "allowed", "payphone", "restricted" or "unknown"
+         * @param callType enumerated values for "incoming", "outgoing", or "missed"
+         * @param start time stamp for the call in milliseconds
+         * @param duration call duration in seconds
+         * @param subscription valid value is 0,1 or 2
+         *
+         * {@hide}
+         */
+        public static Uri addCall(CallerInfo ci, Context context, String number,
+                int presentation, int callType, long start, int duration, int subscription) {
             final ContentResolver resolver = context.getContentResolver();
             int numberPresentation = PRESENTATION_ALLOWED;
 
@@ -335,6 +365,7 @@ public class CallLog {
             values.put(DATE, Long.valueOf(start));
             values.put(DURATION, Long.valueOf(duration));
             values.put(NEW, Integer.valueOf(1));
+            values.put(SUBSCRIPTION, Integer.valueOf(subscription));
             if (callType == MISSED_TYPE) {
                 values.put(IS_READ, Integer.valueOf(0));
             }
diff --git a/core/java/android/provider/ContactsContract.java b/core/java/android/provider/ContactsContract.java
index b16df28..bbab99f 100644
--- a/core/java/android/provider/ContactsContract.java
+++ b/core/java/android/provider/ContactsContract.java
@@ -5172,6 +5172,31 @@ public final class ContactsContract {
             public static final String LABEL = DataColumns.DATA3;
         }
 
+        /** @hide */
+        public static final class LocalGroup implements DataColumnsWithJoins {
+            /** @hide */
+            private LocalGroup() {
+            }
+
+            /** @hide */
+            public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/local-groups";
+
+            /** @hide */
+            public static final String GROUP = DATA1;
+
+            /** @hide */
+            public static final Uri CONTENT_URI = Uri.withAppendedPath(Data.CONTENT_URI,
+                    "local-groups");
+
+            /** @hide */
+            public static final Uri CONTENT_LOOKUP_URI = Uri
+                    .withAppendedPath(CONTENT_URI, "lookup");
+
+            /** @hide */
+            public static final Uri CONTENT_FILTER_URI = Uri
+                    .withAppendedPath(CONTENT_URI, "filter");
+        }
+
         /**
          * A data kind representing the contact's proper name. You can use all
          * columns defined for {@link ContactsContract.Data} as well as the following aliases.
diff --git a/core/java/android/provider/LocalGroups.java b/core/java/android/provider/LocalGroups.java
new file mode 100644
index 0000000..e5c3be4
--- /dev/null
+++ b/core/java/android/provider/LocalGroups.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package android.provider;
+
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.ContactsContract.CommonDataKinds;
+import android.provider.ContactsContract.Data;
+
+/**
+ * @hide
+ */
+public class LocalGroups {
+
+    public static final String AUTHORITY = "com.android.contacts.groups";
+
+    public static final Uri AUTHORITY_URI = Uri.parse("content://" + AUTHORITY);
+
+    public static final Uri CONTENT_URI = Uri.withAppendedPath(AUTHORITY_URI, "local-groups");
+
+    public static interface GroupColumns {
+
+        public static final String _ID = "_id";
+
+        public static final String TITLE = "title";
+
+        public static final String COUNT = "count";
+    }
+
+    public static class Group {
+        private long id = -1;
+
+        private String title = "";
+
+        private int count;
+
+        public long getId() {
+            return id;
+        }
+
+        public void setId(long id) {
+            this.id = id;
+        }
+
+        public String getTitle() {
+            return title;
+        }
+
+        public void setTitle(String title) {
+            this.title = title;
+        }
+
+        public int getCount() {
+            return count;
+        }
+
+        public void setCount(int count) {
+            this.count = count;
+        }
+
+        public static Group restoreGroup(Cursor cursor) {
+            if (cursor == null && cursor.getCount() == 0) {
+                return null;
+            }
+            Group group = new Group();
+            group.setId(cursor.getLong(cursor.getColumnIndex(GroupColumns._ID)));
+            group.setTitle(cursor.getString(cursor.getColumnIndex(GroupColumns.TITLE)));
+            group.setCount(cursor.getInt(cursor.getColumnIndex(GroupColumns.COUNT)));
+            return group;
+        }
+
+        public ContentValues toContentValues() {
+            ContentValues values = new ContentValues();
+            values.put(GroupColumns.TITLE, getTitle());
+            values.put(GroupColumns.COUNT, getCount());
+            return values;
+        }
+
+        public boolean save(ContentResolver cr) {
+            if (cr == null) {
+                return false;
+            }
+            Uri uri = cr.insert(CONTENT_URI, toContentValues());
+            if (uri != null) {
+                setId(ContentUris.parseId(uri));
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        public boolean update(ContentResolver cr) {
+            if (cr == null) {
+                return false;
+            }
+            return cr.update(CONTENT_URI, toContentValues(), GroupColumns._ID + "=?", new String[] {
+                String.valueOf(id)
+            }) > 0;
+        }
+
+        public boolean delete(ContentResolver cr) {
+            cr.delete(Data.CONTENT_URI, Data.MIMETYPE + "=? and "
+                    + CommonDataKinds.LocalGroup.DATA1 + "=?", new String[] {
+                    CommonDataKinds.LocalGroup.CONTENT_ITEM_TYPE, String.valueOf(getId())
+            });
+            return cr.delete(CONTENT_URI, GroupColumns._ID + "=?", new String[] {
+                String.valueOf(id)
+            }) > 0;
+        }
+
+        public static Group restoreGroupById(ContentResolver cr, long groupId) {
+            Uri uri = ContentUris.withAppendedId(LocalGroups.CONTENT_URI, groupId);
+            Cursor c = null;
+            try {
+                c = cr.query(uri, null, null, null, null);
+                if (c != null && c.moveToNext())
+                    return restoreGroup(c);
+            } finally {
+                if (c != null)
+                    c.close();
+            }
+            return null;
+        }
+    }
+
+}
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index f4c3435..ce92db8 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2006 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -7451,6 +7453,66 @@ public final class Settings {
         public static boolean putFloat(ContentResolver cr, String name, float value) {
             return putString(cr, name, Float.toString(value));
         }
+
+
+        /**
+          * Subscription to be used for voice call on a multi sim device. The supported values
+          * are 0 = SUB1, 1 = SUB2 and etc.
+          * @hide
+          */
+        public static final String MULTI_SIM_VOICE_CALL_SUBSCRIPTION = "multi_sim_voice_call";
+
+        /**
+          * Used to provide option to user to select subscription during dial.
+          * The supported values are 0 = disable or 1 = enable prompt.
+          * @hide
+          */
+        public static final String MULTI_SIM_VOICE_PROMPT = "multi_sim_voice_prompt";
+
+        /**
+          * Subscription to be used for data call on a multi sim device. The supported values
+          * are 0 = SUB1, 1 = SUB2 and etc.
+          * @hide
+          */
+        public static final String MULTI_SIM_DATA_CALL_SUBSCRIPTION = "multi_sim_data_call";
+
+        /**
+          * Subscription to be used for SMS on a multi sim device. The supported values
+          * are 0 = SUB1, 1 = SUB2 and etc.
+          * @hide
+          */
+        public static final String MULTI_SIM_SMS_SUBSCRIPTION = "multi_sim_sms";
+
+       /**
+          * Used to provide option to user to select subscription during send SMS.
+          * The value 1 - enable, 0 - disable
+          * @hide
+          */
+        public static final String MULTI_SIM_SMS_PROMPT = "multi_sim_sms_prompt";
+
+
+
+        /** User preferred subscriptions setting.
+          * This holds the details of the user selected subscription from the card and
+          * the activation status. Each settings string have the coma separated values
+          * iccId,appType,appId,activationStatus,3gppIndex,3gpp2Index
+          * @hide
+         */
+        public static final String[] MULTI_SIM_USER_PREFERRED_SUBS = {"user_preferred_sub1",
+                "user_preferred_sub2","user_preferred_sub3"};
+        /**
+          * Subscription to be used decide priority sub on a multi sim device. The supported values
+          * are 0 = SUB1, 1 = SUB2, 2 = SUB3.
+          * @hide
+          */
+        public static final String MULTI_SIM_PRIORITY_SUBSCRIPTION = "multi_sim_priority";
+
+        /**
+          * To know the status of tune away. The supported values
+          * are false = disable, true = enable.
+          * @hide
+          */
+        public static final String TUNE_AWAY_STATUS = "tune_away";
     }
 
     /**
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index f5e2c0e..7eb4472 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -899,7 +899,7 @@
         @hide -->
     <permission android:name="android.permission.PREVENT_POWER_KEY"
         android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
-        android:protectionLevel="dangerous"
+        android:protectionLevel="signatureOrSystem"
         android:label="@string/permlab_preventpower"
         android:description="@string/permdesc_preventpower" />
 
diff --git a/core/res/res/values-zh-rCN/strings.xml b/core/res/res/values-zh-rCN/strings.xml
index ba226af..ddedca4 100644
--- a/core/res/res/values-zh-rCN/strings.xml
+++ b/core/res/res/values-zh-rCN/strings.xml
@@ -859,6 +859,7 @@
     <string name="lockscreen_sim_puk_locked_instructions" msgid="8127916255245181063">"请参阅《用户指南》或与客服人员联系。"</string>
     <string name="lockscreen_sim_locked_message" msgid="8066660129206001039">"SIM 卡被锁定"</string>
     <string name="lockscreen_sim_unlock_progress_dialog_message" msgid="595323214052881264">"正在解锁 SIM 卡..."</string>
+    <string name="lockscreen_airplane_mode_on">"飞行模式"</string>
     <string name="lockscreen_too_many_failed_attempts_dialog_message" msgid="6481623830344107222">"您已经 <xliff:g id="NUMBER_0">%d</xliff:g> 次错误地绘制了解锁图案。\n\n请在 <xliff:g id="NUMBER_1">%d</xliff:g> 秒后重试。"</string>
     <string name="lockscreen_too_many_failed_password_attempts_dialog_message" msgid="2725973286239344555">"您已经 <xliff:g id="NUMBER_0">%d</xliff:g> 次错误地输入了密码。\n\n请在 <xliff:g id="NUMBER_1">%d</xliff:g> 秒后重试。"</string>
     <string name="lockscreen_too_many_failed_pin_attempts_dialog_message" msgid="6216672706545696955">"您已经 <xliff:g id="NUMBER_0">%d</xliff:g> 次错误地输入了 PIN。\n\n请在 <xliff:g id="NUMBER_1">%d</xliff:g> 秒后重试。"</string>
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 4348cc3..b7e0cd0 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -1,6 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
 /*
+** Copyright (c) 2013 The Linux Foundation. All rights reserved.
+** Not a Contribution.
 ** Copyright 2009, The Android Open Source Project
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
@@ -35,6 +37,7 @@
        <item><xliff:g id="id">volume</xliff:g></item>
        <item><xliff:g id="id">wifi</xliff:g></item>
        <item><xliff:g id="id">cdma_eri</xliff:g></item>
+       <item><xliff:g id="id">phone_signal_second_sub</xliff:g></item>
        <item><xliff:g id="id">data_connection</xliff:g></item>
        <item><xliff:g id="id">phone_evdo_signal</xliff:g></item>
        <item><xliff:g id="id">phone_signal</xliff:g></item>
@@ -1152,6 +1155,10 @@
     <!-- Set to true to add links to Cell Broadcast app from Settings and MMS app. -->
     <bool name="config_cellBroadcastAppLinks">false</bool>
 
+    <!-- Boolean indicating if RADIO POWER OFF should be skipped on receiving SIM REFRESH with RESET-->
+    <!-- This will be handled by modem if it is true-->
+    <bool translatable="false" name="skip_radio_power_off_on_sim_refresh_reset">true</bool>
+
     <!-- The default value if the SyncStorageEngine should sync automatically or not -->
     <bool name="config_syncstorageengine_masterSyncAutomatically">true</bool>
 
@@ -1183,6 +1190,11 @@
          may have a specific value set in an overlay config.xml file. -->
     <integer name="config_mobile_mtu">1500</integer>
 
+
+    <!-- Configuration to send sms on 1x when UE is attached to eHRPD and there is an active
+         1xRTT voice call, irrespective of IMS registration state  -->
+    <bool name="config_send_sms1x_on_voice_call">true</bool>
+
     <!-- Whether WiFi display is supported by this device.
          There are many prerequisites for this feature to work correctly.
          Here are a few of them:
@@ -1452,4 +1464,18 @@
     <!-- bool value to for enabling motion accelerometer -->
     <bool name="use_motion_accel">false</bool>
 
+    <!-- set to false if we dont need to consider data
+         service state to display signal strength bars -->
+    <bool name="config_combined_signal">true</bool>
+
+    <!-- Configuration to restart radio upon PDP_DEACTIVATE with
+         error cause as Regular deactivation(36). -->
+    <bool name="config_radio_reset_on_regular_deactivation">true</bool>
+
+    <!-- Configuartion to support 7bit Ascii encoding and decoding
+         for long messages. -->
+    <bool name="config_ascii_7bit_support_for_long_message">false</bool>
+
+    <!-- Configuration to sending and receiving Mms when mobile data is disable.-->
+    <bool name="config_setup_mms_data">false</bool>
 </resources>
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 9a4a2c6..9dcd1d3 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -2275,6 +2275,9 @@
          to unlock the keyguard.  Displayed in one line in a large font.  -->
     <string name="keyguard_password_wrong_pin_code">Incorrect PIN code.</string>
 
+    <!-- Displayed when a SIM PIN/PUK is entered incorrectly. -->
+    <string name="pinpuk_attempts">\nAttempts Remaining :</string>
+
     <!-- Instructions telling the user how to unlock the phone. -->
     <string name="keyguard_label_text">To unlock, press Menu then 0.</string>
 
@@ -2354,6 +2357,8 @@
 
     <!-- Shown in the lock screen when there is emergency calls only mode. -->
     <string name="emergency_calls_only" msgid="2485604591272668370">Emergency calls only</string>
+    <!-- Shown in the lock screen when there is SIM card IO error. -->
+    <string name="lockscreen_sim_error_message_short">Invalid Card.</string>
 
     <!-- When the user inserts a sim card from an unsupported network, it becomes network
          locked -->
@@ -2364,16 +2369,19 @@
          PUK locked (Pin Unlock Kode) -->
     <string name="lockscreen_sim_puk_locked_message">SIM card is PUK-locked.</string>
     <!-- Shown in the lock screen when the SIM has become PUK locked and the user must call customer care to unlock it. -->
-    <string name="lockscreen_sim_puk_locked_instructions">See the User Guide or contact Customer Care.</string>
+    <string name="lockscreen_sim_puk_locked_instructions">PIN1 Blocked. Enter PUK1\nor\nPlease see the User Guide or contact Customer Care.</string>
 
-    <!-- Shown in the lock screen to tell the user that their SIM is locked and they must unlock it. -->
-    <string name="lockscreen_sim_locked_message">SIM card is locked.</string>
+    <!-- Shown in the lock screen to tell the user that their SIM/RUIM is locked and they must unlock it. -->
+    <string name="lockscreen_sim_locked_message">SIM/RUIM card is locked.</string>
 
     <!-- For the unlock screen, When the user enters a sim unlock code, it takes a little while to check
          whether it is valid, and to unlock the sim if it is valid.  we display a
          progress dialog in the meantime.  this is the emssage. -->
     <string name="lockscreen_sim_unlock_progress_dialog_message">Unlocking SIM card\u2026</string>
 
+    <!-- Shown in the lock screen to tell the user that phone is in airplane mode-->
+    <string name="lockscreen_airplane_mode_on">Airplane Mode</string>
+
     <!-- For the unlock screen, Information message shown in dialog when user has too many failed attempts at
          drawing the unlock pattern -->
     <string name="lockscreen_too_many_failed_attempts_dialog_message">
@@ -4193,7 +4201,7 @@
     <!-- Message shown when the user enters an invalid SIM pin password in PUK screen -->
     <string name="kg_invalid_sim_pin_hint">Type a PIN that is 4 to 8 numbers.</string>
     <!-- Message shown when the user enters an invalid PUK code in the PUK screen -->
-    <string name="kg_invalid_sim_puk_hint">PUK code should be 8 numbers or more.</string>
+    <string name="kg_invalid_sim_puk_hint">PUK code should be 8 numbers.</string>
     <!-- Message shown when the user enters an invalid PUK code -->
     <string name="kg_invalid_puk">Re-enter the correct PUK code. Repeated attempts will permanently disable the SIM.</string>
       <!-- String shown in PUK screen when PIN codes don't match -->
@@ -4526,4 +4534,14 @@
     <!-- Longer version of toast bar message when hiding the transient navigation bar (if room) -->
     <string name="transient_navigation_confirmation_long">Swipe from edge of screen to reveal system bar</string>
     <add-resource type="bool" name="config_hotswapCapable"></add-resource>
+
+    <!-- Displayed when the USSD/SS request is modified by STK CC to a
+    different request. This will be displayed in a toast. -->
+    <string name="stk_cc_ussd_to_dial">USSD request is modified to DIAL request.</string>
+    <string name="stk_cc_ussd_to_ss">USSD request is modified to SS request.</string>
+    <string name="stk_cc_ussd_to_ussd">USSD request is modified to new USSD request.</string>
+    <string name="stk_cc_ss_to_dial">SS request is modified to DIAL request.</string>
+    <string name="stk_cc_ss_to_ussd">SS request is modified to USSD request.</string>
+    <string name="stk_cc_ss_to_ss">SS request is modified to new SS request.</string>
+
 </resources>
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index d47afd2..d2da5dc 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -290,6 +290,10 @@
   <java-symbol type="bool" name="config_forceDefaultOrientation" />
   <java-symbol type="bool" name="config_wifi_batched_scan_supported" />
   <java-symbol type="bool" name="flip_controller_fallback_keys" />
+  <java-symbol type="bool" name="skip_radio_power_off_on_sim_refresh_reset" />
+  <java-symbol type="bool" name="config_radio_reset_on_regular_deactivation" />
+  <java-symbol type="bool" name="config_send_sms1x_on_voice_call" />
+  <java-symbol type="bool" name="config_ascii_7bit_support_for_long_message" />
 
   <java-symbol type="integer" name="config_cursorWindowSize" />
   <java-symbol type="integer" name="config_extraFreeKbytesAdjust" />
@@ -457,6 +461,8 @@
   <java-symbol type="string" name="autofill_zip_code_re" />
   <java-symbol type="string" name="badPin" />
   <java-symbol type="string" name="badPuk" />
+  <java-symbol type="string" name="lockscreen_sim_error_message_short" />
+  <java-symbol type="string" name="pinpuk_attempts" />
   <java-symbol type="string" name="byteShort" />
   <java-symbol type="string" name="capability_desc_canRequestEnhancedWebAccessibility" />
   <java-symbol type="string" name="capability_title_canRequestFilterKeyEvents" />
@@ -633,6 +639,7 @@
   <java-symbol type="string" name="orgTypeOther" />
   <java-symbol type="string" name="orgTypeWork" />
   <java-symbol type="string" name="passwordIncorrect" />
+  <java-symbol type="string" name="enablePin" />
   <java-symbol type="string" name="perms_description_app" />
   <java-symbol type="string" name="perms_new_perm_prefix" />
   <java-symbol type="string" name="petabyteShort" />
@@ -838,6 +845,12 @@
   <java-symbol type="string" name="default_audio_route_name_dock_speakers" />
   <java-symbol type="string" name="default_media_route_name_hdmi" />
   <java-symbol type="string" name="default_audio_route_category_name" />
+  <java-symbol type="string" name="stk_cc_ss_to_dial" />
+  <java-symbol type="string" name="stk_cc_ss_to_ss" />
+  <java-symbol type="string" name="stk_cc_ss_to_ussd" />
+  <java-symbol type="string" name="stk_cc_ussd_to_dial" />
+  <java-symbol type="string" name="stk_cc_ussd_to_ss" />
+  <java-symbol type="string" name="stk_cc_ussd_to_ussd" />
   <java-symbol type="string" name="safe_media_volume_warning" />
   <java-symbol type="string" name="media_route_status_scanning" />
   <java-symbol type="string" name="media_route_status_connecting" />
@@ -1395,7 +1408,12 @@
   <java-symbol type="string" name="global_action_silent_mode_on_status" />
   <java-symbol type="string" name="global_action_toggle_silent_mode" />
   <java-symbol type="string" name="invalidPuk" />
+  <java-symbol type="string" name="lockscreen_missing_sim_message_short" />
+  <java-symbol type="string" name="lockscreen_permanent_disabled_sim_message_short" />
   <java-symbol type="string" name="lockscreen_carrier_default" />
+  <java-symbol type="string" name="lockscreen_sim_locked_message" />
+  <java-symbol type="string" name="lockscreen_sim_puk_locked_message" />
+  <java-symbol type="string" name="lockscreen_airplane_mode_on" />
   <java-symbol type="style" name="Animation.LockScreen" />
   <java-symbol type="style" name="Theme.Dialog.RecentApplications" />
   <java-symbol type="style" name="Theme.ExpandedMenu" />
@@ -1678,6 +1696,7 @@
   <java-symbol type="string" name="usb_storage_stop_title" />
   <java-symbol type="string" name="usb_storage_title" />
   <java-symbol type="style" name="Animation.RecentApplications" />
+  <java-symbol type="bool" name="config_combined_signal" />
 
   <!-- ImfTest -->
   <java-symbol type="layout" name="auto_complete_list" />
@@ -1954,4 +1973,5 @@
   <java-symbol type="dimen" name="edge_gesture_trigger_thickness" />
 
   <java-symbol type="bool" name="use_motion_accel" />
+  <java-symbol type="bool" name="config_setup_mms_data" />
 </resources>
diff --git a/data/sounds/ringtones/BOOTES.ogg b/data/sounds/ringtones/BOOTES.ogg
index 0716a4f881a7e2a2711eb7cecb792ce16f0c362c..b23b043bc2b3e5570d5c20ce6f64b201e3befc9a 100644
GIT binary patch
delta 36
scmX?hmhtFW#t8vzj42jh`N}7TrSkGHFffF8hWNPJI_2kYJoz^j0Q8IvMF0Q*

delta 37
tcmX?lmhsqG#t8vzpB7d8=c||)mdeM=z`zjV8RFw=>y&?Z+r|@rQvod?56S=l

diff --git a/data/sounds/ringtones/ogg/Bootes.ogg b/data/sounds/ringtones/ogg/Bootes.ogg
index 46342940ff086d7093ebc304ccd5290be2443058..61f67d79beccdf1c4206bca24ef47f63dda8ab07 100644
GIT binary patch
delta 36
scmZ2@mT|#Z#t8vz4a<Y{`GO{f`SJ2FFffF8hWNPJI_2kY-1I&b0O@=TumAu6

delta 37
tcmZ2*mT}=(#t8vzMNN77e8CgL{P=ho7#Ko4LwsCqo$?QF+qm(4DggGH4W$48

diff --git a/media/java/android/media/AudioService.java b/media/java/android/media/AudioService.java
index 4c88365..3038c16 100644
--- a/media/java/android/media/AudioService.java
+++ b/media/java/android/media/AudioService.java
@@ -1449,6 +1449,13 @@ public class AudioService extends IAudioService.Stub {
         if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
             ringerMode = AudioManager.RINGER_MODE_SILENT;
         }
+
+        if ((ringerMode == AudioManager.RINGER_MODE_SILENT) ||
+            (ringerMode == AudioManager.RINGER_MODE_VIBRATE))
+            SystemProperties.set("persist.sys.silent", "1");
+        else
+            SystemProperties.set("persist.sys.silent", "0");
+
         if (ringerMode != getRingerMode()) {
             setRingerModeInt(ringerMode, true);
             // Send sticky broadcast
@@ -2653,9 +2660,10 @@ public class AudioService extends IAudioService.Stub {
                  (1 << AudioSystem.STREAM_SYSTEM)|(1 << AudioSystem.STREAM_SYSTEM_ENFORCED)),
                  UserHandle.USER_CURRENT);
 
-        // ringtone and system streams are always affected by ringer mode
+        // ringtone, system and dtmf streams are always affected by ringer mode
         ringerModeAffectedStreams |= (1 << AudioSystem.STREAM_RING)|
-                                        (1 << AudioSystem.STREAM_SYSTEM);
+                                        (1 << AudioSystem.STREAM_SYSTEM)|
+                                        (1 << AudioSystem.STREAM_DTMF);
 
         if (mVoiceCapable) {
             ringerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_MUSIC);
diff --git a/packages/Keyguard/res/drawable-hdpi/sym_keyboard_cancel.png b/packages/Keyguard/res/drawable-hdpi/sym_keyboard_cancel.png
new file mode 100644
index 0000000000000000000000000000000000000000..dbe9587e789a70dc2003d309591e005e3e4d9bd7
GIT binary patch
literal 2573
zcmV+o3i9=dP)<h;3K|Lk000e1NJLTq003kF001Qj1^@s6wB}5m00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2i*${
z3N0p}!f`wR011srL_t(&-tC&{b64dR$3NdEB!NI!!m1UaNC5+iI*JQWL8nZuwa(Pe
zIPJT>=&Sw@{WJQyopz?SooT1*(AHWPIwFFCB4Kv{K?qAoLL}Ss?F-JO*Gqm`e!(uz
z@62Qp?!C{s&vTaV`JQuuhJ0>f8{3n<4v-pV``?m=Lq6vW0W`)f)mo#RGm^>*NGVM#
zMeAMv1$IoU?M`40(3MiUQ1juO^9@7VCg(h@h?vg$FR(+F<(z+Edtc6Z$9T`qkc4d{
z-N=-j^9*3Aq=mNU1G6PH2gGGy5V&glBG4_V4;U=gH{>R10Xl8pE2(2#hl~YLk~(Z}
zvAqen2Uu=<9?&dlC>-$-uou{6`>>=l;jD(-oFQ3KpY2{?c)|=REt~_~ZM##_24IQp
zK1uJ}ZjsakWJ!az2PEANY>guI$#fi2rh&Jj4i)<9t&0Wp7WSD+_E&3Zpiq{SU5oFQ
zGo++wCGZ1DYk^BZm!y9J9|HZrD9{QlkaP#|FtEw?72s81<W?|~TLFD#J=4)w&wi?F
z%E2*_t{D*x&5{-Z8*Hxt47?5O0p1BXD!-t`c6S_h061CAj+}E7upGDx=#bO~G>6mr
zf%CxeLU(newr2v50*iq|K#%Q}l9t(SlQbjt`Kj&8q35Ket7B!FZP{)IZj-bUSYUgm
zuD|%2?Q;=$-I99CwY9JjFkjN0wwFt4x7{qsz(CmJtfW(t`YR>ihOP+`<hny7EePnj
z59o{9@N-EgbI!^+e<tN^4+EzHrd|YwB@LIHk$?_hGw>}*>w#rJTM&XXz<%I`ob#oW
z(zP-6HV^n===ibiL%>tEAC|Nfm<8mhXUBlofL{Yg3WzE*KHIZ_uSnWrdxxZTvBwl>
zut(BP+k1enfadakIwWnd{WVG3fjcG5jzH`N4g{L)jP><r2rw6TAYO9Z_FhS+;$Szq
zG_H-t&rQaZbRY0Ia2s$DcsrtT29Rvejf{Li(tz!QlFn7sGyzM(kvoF%B}s>DACV;6
z3ZgLw=mfS!7IaCvno=U3nH|CQ6tE&#;r=j=0^f&$jgl^eQ*#(G0Ufp<0k%q71e^#`
zlfuZB)B@aZ`--p2>6B9clrtpftSIK|qdxo|cx##vz6tn#kp;Go1D69D764BGj{)m#
zFOoC_oU26DsH97AfQ^y{CH)R~Ju>WS1k_sF&jRZtJsl1_8~2H3Y_;uelAeouKLOqf
zn99JS2%xRN?Uhb?A+Rp?yg4%QH^2wB`@<>Af#)PW6nf?Ye<?C$su_}inZcNbfwQ(x
z+a8^ULyiM~1m3g#W=g5MbgwVx{O54c^T7Ra$ZD3U1gY=EGkbwUDW!oDJRS_AXWQQh
z=eCtpEwa4@SQWMIKxFKpl+tMExD<71IHJE?4_5<U4JW+_ybSCvLo{&Fb_;Mx(xbp;
zNe2suOesT32cH|wUVpLCX~;i-S8b1^l=2vmci#3Zwx0%8M)O%M>H=m0p8|id{WD4D
zB@I?|_2!)aCaKx>w{71UnO^8w3Ty|OZ2uN`Q_|7O88fio_Pg<S`QAEUyQDq93&4qr
zGl~G(WBUT|An;I-k-BS$f&rz88kfoNZ%L!TsO=Rw=ldkxZhM}jmZ$>*f$N(C|Hs^=
zq!g^|<CM~=niJBLoOAApj(B#gD|EC6WOW0Ffy0unRn`|y8LN+Kw|!R>@K)QsIp+}|
z#d{oQAF{nL3Vug9OQ+1TLg`3ssHt9ul!lZorDFU{MA?#XLQ_P)BRl&l5&0RFwk_$?
z$!|fbIJgB^0Q3OoYcRTrP-G#nGNM2Dgp2)&e_vEw?+G?pSBBX3NO0#tNwaT3bJiKf
zZC&WzC+SKQY66DZfM=qhw$yTN@chwo2VIV|5*>G8l*--{&?+g}zE;Os+Ja&qvHe$I
zD5e&rQg<C<CFNpjVf&qGhEyjKH60R#@RNY8#lUU0yCv1zd2h7+yrf=WH}Jacx1*4c
zM1;+W$o)<k^J`>Ds=y01NPxqERO-W!?L5JIYDqINZ2KkPM=7PA=^)5N4oTtFe%ptm
zLE310<3tN5kY$qA+P)%bC$KxEbUvjtTo^2joF?<0a>VDHYmWG9d>S2!Ko|xV=bWeN
zl&fJEB7mknSDUbg*zT3IKcMPvNh7uo1ZTei6Oujy86}9YZI{Lrvw-$!3ip?bXy9yz
zq>WK$@<bH7e30>mgf(Ec-}cG)dkt_U=X@-sG+2Q^6{R3Dtyo`-c;?yOo^zfh=}@&$
z7d558u&{^g9i8+5yMi@rhz6-Q=e!p<TK>Wn-R}%ZOMuQ8L>>*QI}-YaqJv)yY{)qu
zNGTQUtv%|?)3(<Gqhry?=|o~>uy<b4E5N<BpOv)I_AhOBNphSg0ryC{2lybG&mu^=
zfWHIxOZuMe#lT3;`D6j<Vdz%dU$Xt6r1{Y|b=8$25y2;-i@pG?mh^b^2h9;-y<zZK
z5#cMsahsxHx-spI4)|CM;GUG!YWrXm*wvCAw*45eFeq@XvAw2<(KlF6=~{OfXD;yF
z2#6!VXwLauK=u+zo1y{S1-wym$g!v+t88zHvCBt6;Xk%LBxx3~6j&o^N6fuGs5FL}
z%;b4S<=-cOpW0q8>C2Mtvb`#>J_S=DHai%<4+2NyV1*I(1HX!oTVJ=m4d@9t5O7V>
zyU`T3#er_BZ_xwH9gBt4ILo~F-Bikueo04yM9cy10KOSNMabr2R1@UJrS(0Mx?=Ls
z56rKuPo=hD$o8<LeYQWT1Xg>jZJxA4BwYq}#$@$L+mA#VFOS1E2OM39S<aggeeXpx
zSjgdktR_k8Y~LHyaU@1Ff0FciL{%p+Fvi|SZJ(2L#`eG@95M)e96ifW31TzQYkObp
zX=_CB+JF`T7bU%6`?aVSxw8IZ&iSPnxIPJNk7jXE3>Ay<{gHsj-N5PcSz=aq+V;3T
zmCDSdRFqqQ6)~+{3e2_L8mw$Il=etEYx^{CS<*n6lLvoaZF^08&}xn*ug~`Jn5wRc
zK4ecsVHx{pMP@COv@0NBy!x>OcswHg<%st3{S?!JJ8Z9t>G8~>FS30`()++U+r23z
zSH6d&fZ&w@*9#)Mo1)jcYWq@5fzJTFMcvFfw@KP&dqJG#!*Lx_{nAx$Q#hUf1~kzp
z+*-QJ46w!+r>?Jt(_KH_p2s2|Wt<-OfqISlpOT5FWW9U36=(Tx*rOp0X-GpF(vXHU
jq#+GyNJAR(e=h$5-tZLxkyrOx00000NkvXXu0mjfRa4vB

literal 0
HcmV?d00001

diff --git a/packages/Keyguard/res/drawable-ldpi/sym_keyboard_cancel.png b/packages/Keyguard/res/drawable-ldpi/sym_keyboard_cancel.png
new file mode 100755
index 0000000000000000000000000000000000000000..70258d5c7a7bb7fbd8e1351767ef380e593155c7
GIT binary patch
literal 573
zcmV-D0>b@?P)<h;3K|Lk000e1NJLTq001)p000vR1^@s6Jq<M+00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2i*n*
z2_!22XtO*300F&8L_t(Y$L-Y5i;Ynj2k__InLF-`1s0d3LdsZJC@BkN6dEjSl$BUp
zSW>c*tv^5(VyC8PD2fu3@+&e~SZGK}HW<Icd@P))x7T&OU9%az-#UwPo~QGi@A*E@
zH=;(3IR%u@8iimB$1sU6c!z7)Ip0_=z-^qtFb1#~J8*fvC^H*4g0mGaSb>Z9kkz|_
zrR5^nhX)0PFQ8q@+l_lUX9@>9#2?}-UgISCtB`q&^%clWVhaYb2&Zta1DQwIlof7g
z#m5Rcqj-s}xhqx`KNH(<9~;oba$LfRDr7#R)q~VSc+-K*n$p=4Oc(YO-DVLtv95Hs
z46o*l3|3-1x6UkPI*>`-dK{lH)TPcxe9!9#X3Dj?x!JRb7_K13`G~k15vwDjFCv-|
z@!P{wO8#-a8xhe?DfOq6`cg`b^b3tD?Q*oD0emYeh>hhR`jh-6WhOA%rOqwv@72v(
zxP#N#nw#00w->EB8^Gb5zcvqgFJyM%MK+Ux4hArSx7dq?d5vKFuViv?5XbQ}+u?g$
zE&gD3mnT`FDIDsBOy2J)SnqQjD8)D9I;QiC-6*|9)TmLT#(#;Qol}F}9ZS<`00000
LNkvXXu0mjfAGGz&

literal 0
HcmV?d00001

diff --git a/packages/Keyguard/res/drawable-mdpi/sym_keyboard_cancel.png b/packages/Keyguard/res/drawable-mdpi/sym_keyboard_cancel.png
new file mode 100644
index 0000000000000000000000000000000000000000..70258d5c7a7bb7fbd8e1351767ef380e593155c7
GIT binary patch
literal 573
zcmV-D0>b@?P)<h;3K|Lk000e1NJLTq001)p000vR1^@s6Jq<M+00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2i*n*
z2_!22XtO*300F&8L_t(Y$L-Y5i;Ynj2k__InLF-`1s0d3LdsZJC@BkN6dEjSl$BUp
zSW>c*tv^5(VyC8PD2fu3@+&e~SZGK}HW<Icd@P))x7T&OU9%az-#UwPo~QGi@A*E@
zH=;(3IR%u@8iimB$1sU6c!z7)Ip0_=z-^qtFb1#~J8*fvC^H*4g0mGaSb>Z9kkz|_
zrR5^nhX)0PFQ8q@+l_lUX9@>9#2?}-UgISCtB`q&^%clWVhaYb2&Zta1DQwIlof7g
z#m5Rcqj-s}xhqx`KNH(<9~;oba$LfRDr7#R)q~VSc+-K*n$p=4Oc(YO-DVLtv95Hs
z46o*l3|3-1x6UkPI*>`-dK{lH)TPcxe9!9#X3Dj?x!JRb7_K13`G~k15vwDjFCv-|
z@!P{wO8#-a8xhe?DfOq6`cg`b^b3tD?Q*oD0emYeh>hhR`jh-6WhOA%rOqwv@72v(
zxP#N#nw#00w->EB8^Gb5zcvqgFJyM%MK+Ux4hArSx7dq?d5vKFuViv?5XbQ}+u?g$
zE&gD3mnT`FDIDsBOy2J)SnqQjD8)D9I;QiC-6*|9)TmLT#(#;Qol}F}9ZS<`00000
LNkvXXu0mjfAGGz&

literal 0
HcmV?d00001

diff --git a/packages/Keyguard/res/drawable-xhdpi/sym_keyboard_cancel.png b/packages/Keyguard/res/drawable-xhdpi/sym_keyboard_cancel.png
new file mode 100644
index 0000000000000000000000000000000000000000..dbe9587e789a70dc2003d309591e005e3e4d9bd7
GIT binary patch
literal 2573
zcmV+o3i9=dP)<h;3K|Lk000e1NJLTq003kF001Qj1^@s6wB}5m00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2i*${
z3N0p}!f`wR011srL_t(&-tC&{b64dR$3NdEB!NI!!m1UaNC5+iI*JQWL8nZuwa(Pe
zIPJT>=&Sw@{WJQyopz?SooT1*(AHWPIwFFCB4Kv{K?qAoLL}Ss?F-JO*Gqm`e!(uz
z@62Qp?!C{s&vTaV`JQuuhJ0>f8{3n<4v-pV``?m=Lq6vW0W`)f)mo#RGm^>*NGVM#
zMeAMv1$IoU?M`40(3MiUQ1juO^9@7VCg(h@h?vg$FR(+F<(z+Edtc6Z$9T`qkc4d{
z-N=-j^9*3Aq=mNU1G6PH2gGGy5V&glBG4_V4;U=gH{>R10Xl8pE2(2#hl~YLk~(Z}
zvAqen2Uu=<9?&dlC>-$-uou{6`>>=l;jD(-oFQ3KpY2{?c)|=REt~_~ZM##_24IQp
zK1uJ}ZjsakWJ!az2PEANY>guI$#fi2rh&Jj4i)<9t&0Wp7WSD+_E&3Zpiq{SU5oFQ
zGo++wCGZ1DYk^BZm!y9J9|HZrD9{QlkaP#|FtEw?72s81<W?|~TLFD#J=4)w&wi?F
z%E2*_t{D*x&5{-Z8*Hxt47?5O0p1BXD!-t`c6S_h061CAj+}E7upGDx=#bO~G>6mr
zf%CxeLU(newr2v50*iq|K#%Q}l9t(SlQbjt`Kj&8q35Ket7B!FZP{)IZj-bUSYUgm
zuD|%2?Q;=$-I99CwY9JjFkjN0wwFt4x7{qsz(CmJtfW(t`YR>ihOP+`<hny7EePnj
z59o{9@N-EgbI!^+e<tN^4+EzHrd|YwB@LIHk$?_hGw>}*>w#rJTM&XXz<%I`ob#oW
z(zP-6HV^n===ibiL%>tEAC|Nfm<8mhXUBlofL{Yg3WzE*KHIZ_uSnWrdxxZTvBwl>
zut(BP+k1enfadakIwWnd{WVG3fjcG5jzH`N4g{L)jP><r2rw6TAYO9Z_FhS+;$Szq
zG_H-t&rQaZbRY0Ia2s$DcsrtT29Rvejf{Li(tz!QlFn7sGyzM(kvoF%B}s>DACV;6
z3ZgLw=mfS!7IaCvno=U3nH|CQ6tE&#;r=j=0^f&$jgl^eQ*#(G0Ufp<0k%q71e^#`
zlfuZB)B@aZ`--p2>6B9clrtpftSIK|qdxo|cx##vz6tn#kp;Go1D69D764BGj{)m#
zFOoC_oU26DsH97AfQ^y{CH)R~Ju>WS1k_sF&jRZtJsl1_8~2H3Y_;uelAeouKLOqf
zn99JS2%xRN?Uhb?A+Rp?yg4%QH^2wB`@<>Af#)PW6nf?Ye<?C$su_}inZcNbfwQ(x
z+a8^ULyiM~1m3g#W=g5MbgwVx{O54c^T7Ra$ZD3U1gY=EGkbwUDW!oDJRS_AXWQQh
z=eCtpEwa4@SQWMIKxFKpl+tMExD<71IHJE?4_5<U4JW+_ybSCvLo{&Fb_;Mx(xbp;
zNe2suOesT32cH|wUVpLCX~;i-S8b1^l=2vmci#3Zwx0%8M)O%M>H=m0p8|id{WD4D
zB@I?|_2!)aCaKx>w{71UnO^8w3Ty|OZ2uN`Q_|7O88fio_Pg<S`QAEUyQDq93&4qr
zGl~G(WBUT|An;I-k-BS$f&rz88kfoNZ%L!TsO=Rw=ldkxZhM}jmZ$>*f$N(C|Hs^=
zq!g^|<CM~=niJBLoOAApj(B#gD|EC6WOW0Ffy0unRn`|y8LN+Kw|!R>@K)QsIp+}|
z#d{oQAF{nL3Vug9OQ+1TLg`3ssHt9ul!lZorDFU{MA?#XLQ_P)BRl&l5&0RFwk_$?
z$!|fbIJgB^0Q3OoYcRTrP-G#nGNM2Dgp2)&e_vEw?+G?pSBBX3NO0#tNwaT3bJiKf
zZC&WzC+SKQY66DZfM=qhw$yTN@chwo2VIV|5*>G8l*--{&?+g}zE;Os+Ja&qvHe$I
zD5e&rQg<C<CFNpjVf&qGhEyjKH60R#@RNY8#lUU0yCv1zd2h7+yrf=WH}Jacx1*4c
zM1;+W$o)<k^J`>Ds=y01NPxqERO-W!?L5JIYDqINZ2KkPM=7PA=^)5N4oTtFe%ptm
zLE310<3tN5kY$qA+P)%bC$KxEbUvjtTo^2joF?<0a>VDHYmWG9d>S2!Ko|xV=bWeN
zl&fJEB7mknSDUbg*zT3IKcMPvNh7uo1ZTei6Oujy86}9YZI{Lrvw-$!3ip?bXy9yz
zq>WK$@<bH7e30>mgf(Ec-}cG)dkt_U=X@-sG+2Q^6{R3Dtyo`-c;?yOo^zfh=}@&$
z7d558u&{^g9i8+5yMi@rhz6-Q=e!p<TK>Wn-R}%ZOMuQ8L>>*QI}-YaqJv)yY{)qu
zNGTQUtv%|?)3(<Gqhry?=|o~>uy<b4E5N<BpOv)I_AhOBNphSg0ryC{2lybG&mu^=
zfWHIxOZuMe#lT3;`D6j<Vdz%dU$Xt6r1{Y|b=8$25y2;-i@pG?mh^b^2h9;-y<zZK
z5#cMsahsxHx-spI4)|CM;GUG!YWrXm*wvCAw*45eFeq@XvAw2<(KlF6=~{OfXD;yF
z2#6!VXwLauK=u+zo1y{S1-wym$g!v+t88zHvCBt6;Xk%LBxx3~6j&o^N6fuGs5FL}
z%;b4S<=-cOpW0q8>C2Mtvb`#>J_S=DHai%<4+2NyV1*I(1HX!oTVJ=m4d@9t5O7V>
zyU`T3#er_BZ_xwH9gBt4ILo~F-Bikueo04yM9cy10KOSNMabr2R1@UJrS(0Mx?=Ls
z56rKuPo=hD$o8<LeYQWT1Xg>jZJxA4BwYq}#$@$L+mA#VFOS1E2OM39S<aggeeXpx
zSjgdktR_k8Y~LHyaU@1Ff0FciL{%p+Fvi|SZJ(2L#`eG@95M)e96ifW31TzQYkObp
zX=_CB+JF`T7bU%6`?aVSxw8IZ&iSPnxIPJNk7jXE3>Ay<{gHsj-N5PcSz=aq+V;3T
zmCDSdRFqqQ6)~+{3e2_L8mw$Il=etEYx^{CS<*n6lLvoaZF^08&}xn*ug~`Jn5wRc
zK4ecsVHx{pMP@COv@0NBy!x>OcswHg<%st3{S?!JJ8Z9t>G8~>FS30`()++U+r23z
zSH6d&fZ&w@*9#)Mo1)jcYWq@5fzJTFMcvFfw@KP&dqJG#!*Lx_{nAx$Q#hUf1~kzp
z+*-QJ46w!+r>?Jt(_KH_p2s2|Wt<-OfqISlpOT5FWW9U36=(Tx*rOp0X-GpF(vXHU
jq#+GyNJAR(e=h$5-tZLxkyrOx00000NkvXXu0mjfRa4vB

literal 0
HcmV?d00001

diff --git a/packages/Keyguard/res/layout/keyguard_emergency_carrier_area.xml b/packages/Keyguard/res/layout/keyguard_emergency_carrier_area.xml
index b4847f0..d101548 100644
--- a/packages/Keyguard/res/layout/keyguard_emergency_carrier_area.xml
+++ b/packages/Keyguard/res/layout/keyguard_emergency_carrier_area.xml
@@ -1,6 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
 **
+** Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+** Not a Contribution.
 ** Copyright 2012, The Android Open Source Project
 **
 ** Licensed under the Apache License, Version 2.0 (the "License")
@@ -28,6 +30,13 @@
     android:layout_alignParentBottom="true"
     android:clickable="true">
 
+    <!-- Used only for Multi Sim case -->
+    <ViewStub android:id="@+id/stub_msim_carrier_text"
+        android:inflatedId="@+id/msim_keyguard_carrier_area"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout="@layout/msim_keyguard_carrier_area" />
+
     <com.android.keyguard.CarrierText
         android:id="@+id/carrier_text"
         android:layout_width="wrap_content"
diff --git a/packages/Keyguard/res/layout/msim_keyguard_carrier_area.xml b/packages/Keyguard/res/layout/msim_keyguard_carrier_area.xml
new file mode 100644
index 0000000..4169403
--- /dev/null
+++ b/packages/Keyguard/res/layout/msim_keyguard_carrier_area.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+**
+** Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+** Not a Contribution.
+** Copyright 2012, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License")
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<!-- This contains emergency call button and carrier as shared by pin/pattern/password screens -->
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:orientation="vertical"
+    android:gravity="center"
+    android:layout_gravity="center_horizontal"
+    android:layout_alignParentBottom="true"
+    android:clickable="true">
+
+    <com.android.keyguard.MSimCarrierText
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:singleLine="true"
+        android:ellipsize="marquee"
+        android:textAppearance="?android:attr/textAppearanceMedium"
+        android:textSize="@dimen/kg_status_line_font_size"
+        android:textColor="?android:attr/textColorSecondary"/>
+</LinearLayout>
diff --git a/packages/Keyguard/res/layout/msim_keyguard_sim_pin_view.xml b/packages/Keyguard/res/layout/msim_keyguard_sim_pin_view.xml
new file mode 100644
index 0000000..4bc1992
--- /dev/null
+++ b/packages/Keyguard/res/layout/msim_keyguard_sim_pin_view.xml
@@ -0,0 +1,237 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+**
+** Copyright (c) 2012 - 2013, The Linux Foundation. All rights reserved.
+** Not a Contribution.
+** Copyright 2012, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License")
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+<!-- This is the SIM PIN view that allows the user to enter a SIM PIN to unlock the device. -->
+<com.android.keyguard.MSimKeyguardSimPinView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:androidprv="http://schemas.android.com/apk/res/com.android.keyguard"
+    android:id="@+id/msim_keyguard_sim_pin_view"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    androidprv:layout_maxWidth="@dimen/keyguard_security_width"
+    androidprv:layout_maxHeight="@dimen/keyguard_security_height"
+    android:gravity="center_horizontal">
+
+    <ImageView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:src="@drawable/ic_lockscreen_sim"/>
+
+    <include layout="@layout/keyguard_message_area"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        />
+    <LinearLayout
+       android:id="@+id/keyguard_bouncer_frame"
+       android:background="@drawable/kg_bouncer_bg_white"
+       android:layout_width="match_parent"
+       android:layout_height="0dp"
+       android:orientation="vertical"
+       android:layout_weight="1"
+       android:layoutDirection="ltr"
+       >
+       <LinearLayout
+           android:layout_width="match_parent"
+           android:layout_height="0dp"
+           android:orientation="horizontal"
+           android:layout_weight="1"
+           >
+           <TextView android:id="@+id/pinEntry"
+               android:editable="true"
+               android:layout_width="0dip"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               android:gravity="center"
+               android:layout_marginStart="@*android:dimen/keyguard_lockscreen_pin_margin_left"
+               android:singleLine="true"
+               android:cursorVisible="false"
+               android:background="@null"
+               android:textAppearance="@style/TextAppearance.NumPadKey"
+               android:imeOptions="flagForceAscii|actionDone"
+               />
+           <ImageButton android:id="@+id/delete_button"
+               android:layout_width="wrap_content"
+               android:layout_height="match_parent"
+               android:gravity="center_vertical"
+               android:src="@*android:drawable/ic_input_delete"
+               android:clickable="true"
+               android:paddingTop="8dip"
+               android:paddingBottom="8dip"
+               android:paddingLeft="24dp"
+               android:paddingRight="24dp"
+               android:background="?android:attr/selectableItemBackground"
+               android:contentDescription="@string/keyboardview_keycode_delete"
+               />
+       </LinearLayout>
+       <View
+           android:layout_width="wrap_content"
+           android:layout_height="1dp"
+           android:background="#55FFFFFF"
+           />
+       <LinearLayout
+           android:layout_width="match_parent"
+           android:layout_height="0dp"
+           android:layout_weight="1"
+           android:orientation="horizontal"
+           >
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key1"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="1"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key2"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="2"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key3"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="3"
+               />
+       </LinearLayout>
+       <LinearLayout
+           android:layout_width="match_parent"
+           android:layout_height="0dp"
+           android:layout_weight="1"
+           android:orientation="horizontal"
+           >
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key4"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="4"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key5"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="5"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key6"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="6"
+               />
+       </LinearLayout>
+       <LinearLayout
+           android:layout_width="match_parent"
+           android:layout_height="0dp"
+           android:orientation="horizontal"
+           android:layout_weight="1"
+           >
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key7"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="7"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key8"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="8"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key9"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="9"
+               />
+       </LinearLayout>
+       <LinearLayout
+           android:layout_width="match_parent"
+           android:layout_height="0dp"
+           android:layout_weight="1"
+           android:orientation="horizontal"
+           >
+           <ImageButton
+               android:id="@+id/key_cancel"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               android:paddingRight="30dp"
+               android:src="@drawable/sym_keyboard_cancel"
+               android:contentDescription="@string/keyboardview_keycode_cancel"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key0"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="0"
+               />
+           <ImageButton
+               android:id="@+id/key_enter"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               android:paddingRight="30dp"
+               android:src="@drawable/sym_keyboard_return_holo"
+               android:contentDescription="@string/keyboardview_keycode_enter"
+               />
+       </LinearLayout>
+    </LinearLayout>
+
+    <include layout="@layout/keyguard_eca"
+                   android:id="@+id/keyguard_selector_fade_container"
+                   android:layout_width="match_parent"
+                   android:layout_height="wrap_content"
+                   android:orientation="vertical"
+                   android:layout_gravity="bottom|center_horizontal"
+                   android:gravity="center_horizontal" />
+
+</com.android.keyguard.MSimKeyguardSimPinView>
diff --git a/packages/Keyguard/res/layout/msim_keyguard_sim_puk_view.xml b/packages/Keyguard/res/layout/msim_keyguard_sim_puk_view.xml
new file mode 100644
index 0000000..fe4baff
--- /dev/null
+++ b/packages/Keyguard/res/layout/msim_keyguard_sim_puk_view.xml
@@ -0,0 +1,232 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+**
+** Copyright (c) 2012 - 2013, The Linux Foundation. All rights reserved.
+** Not a Contribution.
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License")
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+<!-- This is the SIM PUK view that allows the user to recover their device by entering the
+    carrier-provided PUK code and entering a new SIM PIN for it. -->
+<com.android.keyguard.MSimKeyguardSimPukView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:androidprv="http://schemas.android.com/apk/res/com.android.keyguard"
+    android:id="@+id/msim_keyguard_sim_puk_view"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    androidprv:layout_maxWidth="@dimen/keyguard_security_width"
+    androidprv:layout_maxHeight="@dimen/keyguard_security_height"
+    android:gravity="center_horizontal">
+
+    <ImageView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:src="@drawable/ic_lockscreen_sim"/>
+
+    <include layout="@layout/keyguard_message_area"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        />
+    <LinearLayout
+       android:id="@+id/keyguard_bouncer_frame"
+       android:background="@drawable/kg_bouncer_bg_white"
+       android:layout_width="match_parent"
+       android:layout_height="0dp"
+       android:orientation="vertical"
+       android:layout_weight="1"
+       android:layoutDirection="ltr"
+       >
+       <LinearLayout
+           android:layout_width="match_parent"
+           android:layout_height="0dp"
+           android:orientation="horizontal"
+           android:layout_weight="1"
+           >
+           <TextView android:id="@+id/pinEntry"
+               android:editable="true"
+               android:layout_width="0dip"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               android:gravity="center"
+               android:layout_marginStart="@*android:dimen/keyguard_lockscreen_pin_margin_left"
+               android:singleLine="true"
+               android:cursorVisible="false"
+               android:background="@null"
+               android:textAppearance="@style/TextAppearance.NumPadKey"
+               android:imeOptions="flagForceAscii|actionDone"
+               />
+           <ImageButton android:id="@+id/delete_button"
+               android:layout_width="wrap_content"
+               android:layout_height="match_parent"
+               android:gravity="center_vertical"
+               android:src="@*android:drawable/ic_input_delete"
+               android:clickable="true"
+               android:paddingTop="8dip"
+               android:paddingBottom="8dip"
+               android:paddingLeft="24dp"
+               android:paddingRight="24dp"
+               android:background="?android:attr/selectableItemBackground"
+               android:contentDescription="@string/keyboardview_keycode_delete"
+               />
+       </LinearLayout>
+       <View
+           android:layout_width="wrap_content"
+           android:layout_height="1dp"
+           android:background="#55FFFFFF"
+           />
+       <LinearLayout
+           android:layout_width="match_parent"
+           android:layout_height="0dp"
+           android:layout_weight="1"
+           android:orientation="horizontal"
+           >
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key1"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="1"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key2"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="2"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key3"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="3"
+               />
+       </LinearLayout>
+       <LinearLayout
+           android:layout_width="match_parent"
+           android:layout_height="0dp"
+           android:layout_weight="1"
+           android:orientation="horizontal"
+           >
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key4"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="4"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key5"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="5"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key6"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="6"
+               />
+       </LinearLayout>
+       <LinearLayout
+           android:layout_width="match_parent"
+           android:layout_height="0dp"
+           android:orientation="horizontal"
+           android:layout_weight="1"
+           >
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key7"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="7"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key8"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="8"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key9"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="9"
+               />
+       </LinearLayout>
+       <LinearLayout
+           android:layout_width="match_parent"
+           android:layout_height="0dp"
+           android:layout_weight="1"
+           android:orientation="horizontal"
+           >
+           <Space
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               />
+           <view class="com.android.keyguard.NumPadKey"
+               android:id="@+id/key0"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               androidprv:textView="@+id/pinEntry"
+               androidprv:digit="0"
+               />
+           <ImageButton
+               android:id="@+id/key_enter"
+               style="@style/Widget.Button.NumPadKey"
+               android:layout_width="0px"
+               android:layout_height="match_parent"
+               android:layout_weight="1"
+               android:paddingRight="30dp"
+               android:src="@drawable/sym_keyboard_return_holo"
+               android:contentDescription="@string/keyboardview_keycode_enter"
+               />
+       </LinearLayout>
+    </LinearLayout>
+
+    <include layout="@layout/keyguard_eca"
+                   android:id="@+id/keyguard_selector_fade_container"
+                   android:layout_width="match_parent"
+                   android:layout_height="wrap_content"
+                   android:orientation="vertical"
+                   android:layout_gravity="bottom|center_horizontal"
+                   android:gravity="center_horizontal" />
+</com.android.keyguard.MSimKeyguardSimPukView>
diff --git a/packages/Keyguard/res/values/strings.xml b/packages/Keyguard/res/values/strings.xml
index 5ae81da..eab1c12 100644
--- a/packages/Keyguard/res/values/strings.xml
+++ b/packages/Keyguard/res/values/strings.xml
@@ -46,6 +46,28 @@
          to unlock the keyguard.  Displayed in one line in a large font.  -->
     <string name="keyguard_password_wrong_pin_code">Incorrect PIN code.</string>
 
+    <!-- Instructions telling the user that they entered the wrong puk while trying
+         to unlock the keyguard.  Displayed in one line in a large font.  -->
+    <string name="keyguard_password_wrong_puk_code">Incorrect PUK code!</string>
+
+    <!-- Instructions telling the user that the operation to unlock the keyguard
+         with PIN failed. Displayed in one line in a large font.  -->
+    <string name="keyguard_password_pin_failed">PIN operation failed!</string>
+
+    <!-- Instructions telling the user that the operation to unlock the keyguard
+         with PUK failed. Displayed in one line in a large font.  -->
+    <string name="keyguard_password_puk_failed">PUK operation failed!</string>
+
+
+    <!-- Notification telling the user that the PIN1 they entered is valid -->
+    <string name="keyguard_pin_accepted">Code Accepted!</string>
+
+    <!-- Displayed when a SIM PIN/PUK is entered incorrectly. -->
+    <string name="pinpuk_attempts">\nAttempts Remaining :</string>
+
+    <!-- Shown in the lock screen when there is SIM card IO error. -->
+    <string name="lockscreen_sim_error_message_short">Invalid Card.</string>
+
     <!-- Instructions telling the user how to unlock the phone. -->
     <string name="keyguard_label_text">To unlock, press Menu then 0.</string>
 
@@ -70,6 +92,10 @@
     <!-- SIM messages --><skip />
     <!-- When the user inserts a sim card from an unsupported network, it becomes network locked -->
     <string name="keyguard_network_locked_message">Network locked</string>
+
+    <!-- When the user inserts a sim card with some personalization enabled -->
+    <string name="keyguard_perso_locked_message">SIM/RUIM is Perso locked</string>
+
     <!-- Shown when there is no SIM card. -->
     <string name="keyguard_missing_sim_message_short">No SIM card</string>
     <!-- Shown when there is no SIM card. -->
@@ -375,4 +401,10 @@
         This is displayed if the phone is not connected to a carrier.-->
     <string name="keyguard_carrier_default">No service.</string>
 
+    <!-- Multi SIM related -->
+    <!-- Message used in Multi SIM enabled SIM PIN view -->
+    <string name="msim_kg_sim_pin_msg_format">SUB:<xliff:g id="number">%d</xliff:g> : <xliff:g id="msg">%s</xliff:g>.</string>
+
+    <!-- Carrier text used in Multi SIM enabled view -->
+    <string name="msim_carrier_text_format"><xliff:g id="text_1">%s</xliff:g>, <xliff:g id="text_2">%s</xliff:g></string>
 </resources>
diff --git a/packages/Keyguard/src/com/android/keyguard/CarrierText.java b/packages/Keyguard/src/com/android/keyguard/CarrierText.java
index 88558cd..be5c1b9 100644
--- a/packages/Keyguard/src/com/android/keyguard/CarrierText.java
+++ b/packages/Keyguard/src/com/android/keyguard/CarrierText.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -65,13 +67,14 @@ public class CarrierText extends TextView {
      */
     private static enum StatusMode {
         Normal, // Normal case (sim card present, it's not locked)
-        NetworkLocked, // SIM card is 'network locked'.
+        PersoLocked, // SIM card is 'perso locked'.
         SimMissing, // SIM card is missing.
         SimMissingLocked, // SIM card is missing, and device isn't provisioned; don't allow access
         SimPukLocked, // SIM card is PUK locked because SIM entered wrong too many times
         SimLocked, // SIM card is currently locked
         SimPermDisabled, // SIM card is permanently disabled due to PUK unlock failure
-        SimNotReady; // SIM is not ready yet. May never be on devices w/o a SIM.
+        SimNotReady, // SIM is not ready yet. May never be on devices w/o a SIM.
+        SimIoError; //The sim card is faulty
     }
 
     public CarrierText(Context context) {
@@ -100,6 +103,9 @@ public class CarrierText extends TextView {
     @Override
     protected void onAttachedToWindow() {
         super.onAttachedToWindow();
+        if (KeyguardUpdateMonitor.sIsMultiSimEnabled) {
+            return;
+        }
         KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mCallback);
     }
 
@@ -118,7 +124,7 @@ public class CarrierText extends TextView {
      * @param spn
      * @return
      */
-    private CharSequence getCarrierTextForSimState(IccCardConstants.State simState,
+    protected CharSequence getCarrierTextForSimState(IccCardConstants.State simState,
             CharSequence plmn, CharSequence spn) {
         CharSequence carrierText = null;
         StatusMode status = getStatusForIccState(simState);
@@ -131,9 +137,9 @@ public class CarrierText extends TextView {
                 carrierText = null; // nothing to display yet.
                 break;
 
-            case NetworkLocked:
+            case PersoLocked:
                 carrierText = makeCarrierStringOnEmergencyCapable(
-                        mContext.getText(R.string.keyguard_network_locked_message), plmn);
+                        getContext().getText(R.string.keyguard_perso_locked_message), plmn);
                 break;
 
             case SimMissing:
@@ -168,6 +174,12 @@ public class CarrierText extends TextView {
                         getContext().getText(R.string.keyguard_sim_puk_locked_message),
                         plmn);
                 break;
+
+            case SimIoError:
+                carrierText = makeCarrierStringOnEmergencyCapable(
+                        getContext().getText(R.string.lockscreen_sim_error_message_short),
+                        plmn);
+                break;
         }
 
         return carrierText;
@@ -198,13 +210,13 @@ public class CarrierText extends TextView {
                 && (simState == IccCardConstants.State.ABSENT ||
                         simState == IccCardConstants.State.PERM_DISABLED);
 
-        // Assume we're NETWORK_LOCKED if not provisioned
-        simState = missingAndNotProvisioned ? IccCardConstants.State.NETWORK_LOCKED : simState;
+        // Assume we're PERSO_LOCKED if not provisioned
+        simState = missingAndNotProvisioned ? IccCardConstants.State.PERSO_LOCKED : simState;
         switch (simState) {
             case ABSENT:
                 return StatusMode.SimMissing;
-            case NETWORK_LOCKED:
-                return StatusMode.SimMissingLocked;
+            case PERSO_LOCKED:
+                return StatusMode.PersoLocked;
             case NOT_READY:
                 return StatusMode.SimNotReady;
             case PIN_REQUIRED:
@@ -217,6 +229,8 @@ public class CarrierText extends TextView {
                 return StatusMode.SimPermDisabled;
             case UNKNOWN:
                 return StatusMode.SimMissing;
+            case CARD_IO_ERROR:
+                return StatusMode.SimIoError;
         }
         return StatusMode.SimMissing;
     }
@@ -240,7 +254,7 @@ public class CarrierText extends TextView {
         int carrierHelpTextId = 0;
         StatusMode status = getStatusForIccState(simState);
         switch (status) {
-            case NetworkLocked:
+            case PersoLocked:
                 carrierHelpTextId = R.string.keyguard_instructions_when_pattern_disabled;
                 break;
 
diff --git a/packages/Keyguard/src/com/android/keyguard/KeyguardHostView.java b/packages/Keyguard/src/com/android/keyguard/KeyguardHostView.java
index 4f9a334..76471c7 100644
--- a/packages/Keyguard/src/com/android/keyguard/KeyguardHostView.java
+++ b/packages/Keyguard/src/com/android/keyguard/KeyguardHostView.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -48,6 +50,7 @@ import android.os.SystemClock;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.Settings;
+import android.telephony.MSimTelephonyManager;
 import android.util.AttributeSet;
 import android.util.Log;
 import android.util.Slog;
@@ -55,6 +58,7 @@ import android.view.HapticFeedbackConstants;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.View;
+import android.view.ViewStub;
 import android.view.WindowManager;
 import android.widget.RemoteViews.OnClickHandler;
 
@@ -980,6 +984,12 @@ public class KeyguardHostView extends KeyguardViewBase {
             final LayoutInflater inflater = LayoutInflater.from(mContext);
             if (DEBUG) Log.v(TAG, "inflating id = " + layoutId);
             View v = inflater.inflate(layoutId, mSecurityViewContainer, false);
+            if (KeyguardUpdateMonitor.sIsMultiSimEnabled) {
+                ViewStub vStub = (ViewStub) (v.findViewById(R.id.stub_msim_carrier_text));
+                if (vStub != null) {
+                    vStub.inflate();
+                }
+            }
             mSecurityViewContainer.addView(v);
             updateSecurityView(v);
             view = (KeyguardSecurityView)v;
@@ -1152,8 +1162,16 @@ public class KeyguardHostView extends KeyguardViewBase {
             case Password: return R.id.keyguard_password_view;
             case Biometric: return R.id.keyguard_face_unlock_view;
             case Account: return R.id.keyguard_account_view;
-            case SimPin: return R.id.keyguard_sim_pin_view;
-            case SimPuk: return R.id.keyguard_sim_puk_view;
+            case SimPin:
+                if (KeyguardUpdateMonitor.sIsMultiSimEnabled) {
+                    return R.id.msim_keyguard_sim_pin_view;
+                }
+                return R.id.keyguard_sim_pin_view;
+            case SimPuk:
+                if (KeyguardUpdateMonitor.sIsMultiSimEnabled) {
+                    return R.id.msim_keyguard_sim_puk_view;
+                }
+                return R.id.keyguard_sim_puk_view;
         }
         return 0;
     }
@@ -1166,8 +1184,16 @@ public class KeyguardHostView extends KeyguardViewBase {
             case Password: return R.layout.keyguard_password_view;
             case Biometric: return R.layout.keyguard_face_unlock_view;
             case Account: return R.layout.keyguard_account_view;
-            case SimPin: return R.layout.keyguard_sim_pin_view;
-            case SimPuk: return R.layout.keyguard_sim_puk_view;
+            case SimPin:
+                if (KeyguardUpdateMonitor.sIsMultiSimEnabled) {
+                    return R.layout.msim_keyguard_sim_pin_view;
+                }
+                return R.layout.keyguard_sim_pin_view;
+            case SimPuk:
+                if (KeyguardUpdateMonitor.sIsMultiSimEnabled) {
+                    return R.layout.msim_keyguard_sim_puk_view;
+                }
+                return R.layout.keyguard_sim_puk_view;
             default:
                 return 0;
         }
diff --git a/packages/Keyguard/src/com/android/keyguard/KeyguardSecurityModel.java b/packages/Keyguard/src/com/android/keyguard/KeyguardSecurityModel.java
index 4ff4d7a..67f2283 100644
--- a/packages/Keyguard/src/com/android/keyguard/KeyguardSecurityModel.java
+++ b/packages/Keyguard/src/com/android/keyguard/KeyguardSecurityModel.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -18,6 +20,7 @@ package com.android.keyguard;
 import android.app.Profile;
 import android.app.admin.DevicePolicyManager;
 import android.content.Context;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.TelephonyManager;
 
 import com.android.internal.telephony.IccCardConstants;
@@ -76,7 +79,20 @@ public class KeyguardSecurityModel {
 
     SecurityMode getSecurityMode() {
         KeyguardUpdateMonitor updateMonitor = KeyguardUpdateMonitor.getInstance(mContext);
-        final IccCardConstants.State simState = updateMonitor.getSimState();
+        IccCardConstants.State simState = updateMonitor.getSimState();
+
+        int numPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+        for (int i = 0; i < numPhones; i++) {
+            simState = updateMonitor.getSimState(i);
+            // We are intereseted only in PIN_REQUIRED or PUK_REQUIRED
+            // So continue to the next sub if the sim state is other
+            // than these two.
+            if (simState == IccCardConstants.State.PIN_REQUIRED
+                    || simState == IccCardConstants.State.PUK_REQUIRED) {
+                break;
+            }
+        }
+
         SecurityMode mode = SecurityMode.None;
         if (simState == IccCardConstants.State.PIN_REQUIRED) {
             mode = SecurityMode.SimPin;
diff --git a/packages/Keyguard/src/com/android/keyguard/KeyguardSimPinView.java b/packages/Keyguard/src/com/android/keyguard/KeyguardSimPinView.java
index 9accbb4..b5a0e3c 100644
--- a/packages/Keyguard/src/com/android/keyguard/KeyguardSimPinView.java
+++ b/packages/Keyguard/src/com/android/keyguard/KeyguardSimPinView.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -48,10 +50,12 @@ public class KeyguardSimPinView extends KeyguardAbsKeyInputView
     private static final boolean DEBUG = KeyguardViewMediator.DEBUG;
     public static final String TAG = "KeyguardSimPinView";
 
-    private ProgressDialog mSimUnlockProgressDialog = null;
+    protected ProgressDialog mSimUnlockProgressDialog = null;
     private CheckSimPin mCheckSimPinThread;
 
     private AlertDialog mRemainingAttemptsDialog;
+    
+    protected volatile boolean mSimCheckInProgress;
 
     public KeyguardSimPinView(Context context) {
         this(context, null);
@@ -61,8 +65,33 @@ public class KeyguardSimPinView extends KeyguardAbsKeyInputView
         super(context, attrs);
     }
 
+    protected void showCancelButton() {
+        final View cancel = findViewById(R.id.key_cancel);
+        if (cancel != null) {
+            cancel.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    doHapticKeyClick();
+                }
+            });
+        }
+    }
+
     public void resetState() {
-        mSecurityMessageDisplay.setMessage(R.string.kg_sim_pin_instructions, true);
+        String  displayMessage = "";
+        try {
+            int attemptsRemaining = ITelephony.Stub.asInterface(ServiceManager
+                    .checkService("phone")).getIccPin1RetryCount();
+            if (attemptsRemaining >= 0) {
+                displayMessage = getContext().getString(R.string.keyguard_password_wrong_pin_code)
+                        + getContext().getString(R.string.pinpuk_attempts)
+                        + attemptsRemaining + ". ";
+            }
+        } catch (RemoteException ex) {
+            displayMessage = getContext().getString(R.string.keyguard_password_pin_failed);
+        }
+        displayMessage = displayMessage + getContext().getString(R.string.kg_sim_pin_instructions) ;
+        mSecurityMessageDisplay.setMessage(displayMessage, true);
         mPasswordEntry.setEnabled(true);
     }
 
@@ -108,6 +137,7 @@ public class KeyguardSimPinView extends KeyguardAbsKeyInputView
                 }
             });
         }
+        showCancelButton();
 
         // The delete button is of the PIN keyboard itself in some (e.g. tablet) layouts,
         // not a separate view
@@ -190,7 +220,7 @@ public class KeyguardSimPinView extends KeyguardAbsKeyInputView
         }
     }
 
-    private Dialog getSimUnlockProgressDialog() {
+    protected Dialog getSimUnlockProgressDialog() {
         if (mSimUnlockProgressDialog == null) {
             mSimUnlockProgressDialog = new ProgressDialog(mContext);
             mSimUnlockProgressDialog.setMessage(
@@ -242,6 +272,8 @@ public class KeyguardSimPinView extends KeyguardAbsKeyInputView
                                 mSimUnlockProgressDialog.hide();
                             }
                             if (result == PhoneConstants.PIN_RESULT_SUCCESS) {
+                                // before closing the keyguard, report back that the sim is unlocked
+                                // so it knows right away.
                                 KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked();
                                 mCallback.dismiss(true);
                             } else {
diff --git a/packages/Keyguard/src/com/android/keyguard/KeyguardSimPukView.java b/packages/Keyguard/src/com/android/keyguard/KeyguardSimPukView.java
index 6e9e83e..0b430f1 100644
--- a/packages/Keyguard/src/com/android/keyguard/KeyguardSimPukView.java
+++ b/packages/Keyguard/src/com/android/keyguard/KeyguardSimPukView.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -47,19 +49,20 @@ public class KeyguardSimPukView extends KeyguardAbsKeyInputView
     private static final boolean DEBUG = KeyguardViewMediator.DEBUG;
     public static final String TAG = "KeyguardSimPukView";
 
-    private ProgressDialog mSimUnlockProgressDialog = null;
-    private CheckSimPuk mCheckSimPukThread;
-    private String mPukText;
-    private String mPinText;
-    private StateMachine mStateMachine = new StateMachine();
-    private AlertDialog mRemainingAttemptsDialog;
+    protected ProgressDialog mSimUnlockProgressDialog = null;
+    protected CheckSimPuk mCheckSimPukThread;
+    protected String mPukText;
+    protected String mPinText;
+    protected StateMachine mStateMachine = new StateMachine();
+    protected AlertDialog mRemainingAttemptsDialog;
+    protected volatile boolean mCheckInProgress;
 
-    private class StateMachine {
+    protected class StateMachine {
         final int ENTER_PUK = 0;
         final int ENTER_PIN = 1;
         final int CONFIRM_PIN = 2;
         final int DONE = 3;
-        private int state = ENTER_PUK;
+        protected int state = ENTER_PUK;
 
         public void next() {
             int msg = 0;
@@ -241,7 +244,7 @@ public class KeyguardSimPukView extends KeyguardAbsKeyInputView
         }
     }
 
-    private Dialog getSimUnlockProgressDialog() {
+    protected Dialog getSimUnlockProgressDialog() {
         if (mSimUnlockProgressDialog == null) {
             mSimUnlockProgressDialog = new ProgressDialog(mContext);
             mSimUnlockProgressDialog.setMessage(
@@ -256,7 +259,7 @@ public class KeyguardSimPukView extends KeyguardAbsKeyInputView
         return mSimUnlockProgressDialog;
     }
 
-    private Dialog getPukRemainingAttemptsDialog(int remaining) {
+    protected Dialog getPukRemainingAttemptsDialog(int remaining) {
         String msg = getPukPasswordErrorMessage(remaining);
         if (mRemainingAttemptsDialog == null) {
             AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
@@ -272,16 +275,16 @@ public class KeyguardSimPukView extends KeyguardAbsKeyInputView
         return mRemainingAttemptsDialog;
     }
 
-    private boolean checkPuk() {
+    protected boolean checkPuk() {
         // make sure the puk is at least 8 digits long.
-        if (mPasswordEntry.getText().length() >= 8) {
+        if (mPasswordEntry.getText().length() == 8) {
             mPukText = mPasswordEntry.getText().toString();
             return true;
         }
         return false;
     }
 
-    private boolean checkPin() {
+    protected boolean checkPin() {
         // make sure the PIN is between 4 and 8 digits
         int length = mPasswordEntry.getText().length();
         if (length >= 4 && length <= 8) {
@@ -295,7 +298,7 @@ public class KeyguardSimPukView extends KeyguardAbsKeyInputView
         return mPinText.equals(mPasswordEntry.getText().toString());
     }
 
-    private void updateSim() {
+    protected void updateSim() {
         getSimUnlockProgressDialog().show();
 
         if (mCheckSimPukThread == null) {
diff --git a/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java b/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
index c23bd45..9135540 100644
--- a/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
+++ b/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -46,8 +48,10 @@ import android.os.UserHandle;
 import android.provider.Settings;
 
 import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.MSimConstants;
 import com.android.internal.telephony.TelephonyIntents;
 
+import android.telephony.MSimTelephonyManager;
 import android.telephony.TelephonyManager;
 import android.util.Log;
 import com.google.android.collect.Lists;
@@ -100,9 +104,9 @@ public class KeyguardUpdateMonitor {
     private final Context mContext;
 
     // Telephony state
-    private IccCardConstants.State mSimState = IccCardConstants.State.READY;
-    private CharSequence mTelephonyPlmn;
-    private CharSequence mTelephonySpn;
+    private IccCardConstants.State []mSimState;
+    private CharSequence []mTelephonyPlmn;
+    private CharSequence []mTelephonySpn;
     private int mRingMode;
     private int mPhoneState;
     private boolean mKeyguardIsVisible;
@@ -129,6 +133,8 @@ public class KeyguardUpdateMonitor {
     private boolean mSwitchingUser;
 
     private boolean mScreenOn;
+    public static final boolean
+            sIsMultiSimEnabled = MSimTelephonyManager.getDefault().isMultiSimEnabled();
 
     private final Handler mHandler = new Handler() {
         @Override
@@ -141,7 +147,7 @@ public class KeyguardUpdateMonitor {
                     handleBatteryUpdate((BatteryStatus) msg.obj);
                     break;
                 case MSG_CARRIER_INFO_UPDATE:
-                    handleCarrierInfoUpdate();
+                    handleCarrierInfoUpdate(msg.arg1);
                     break;
                 case MSG_SIM_STATE_CHANGE:
                     handleSimStateChange((SimArgs) msg.obj);
@@ -264,9 +270,15 @@ public class KeyguardUpdateMonitor {
                     || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
                 mHandler.sendEmptyMessage(MSG_TIME_UPDATE);
             } else if (TelephonyIntents.SPN_STRINGS_UPDATED_ACTION.equals(action)) {
-                mTelephonyPlmn = getTelephonyPlmnFrom(intent);
-                mTelephonySpn = getTelephonySpnFrom(intent);
-                mHandler.sendEmptyMessage(MSG_CARRIER_INFO_UPDATE);
+                // Get the subscription from the intent.
+                final int subscription = intent.getIntExtra(MSimConstants.SUBSCRIPTION_KEY, 0);
+                Log.d(TAG, "Received SPN update on sub :" + subscription);
+                // Update PLMN and SPN for corresponding subscriptions.
+                mTelephonyPlmn[subscription] = getTelephonyPlmnFrom(intent);
+                mTelephonySpn[subscription] = getTelephonySpnFrom(intent);
+                final Message msg = mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE);
+                msg.arg1 = subscription;
+                mHandler.sendMessage(msg);
             } else if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
                 final int status = intent.getIntExtra(EXTRA_STATUS, BATTERY_STATUS_UNKNOWN);
                 final int plugged = intent.getIntExtra(EXTRA_PLUGGED, 0);
@@ -320,16 +332,22 @@ public class KeyguardUpdateMonitor {
      */
     private static class SimArgs {
         public final IccCardConstants.State simState;
+        public int subscription;
 
-        SimArgs(IccCardConstants.State state) {
+        SimArgs(IccCardConstants.State state, int sub) {
             simState = state;
+            subscription = sub;
         }
 
         static SimArgs fromIntent(Intent intent) {
             IccCardConstants.State state;
+            int subscription;
             if (!TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(intent.getAction())) {
                 throw new IllegalArgumentException("only handles intent ACTION_SIM_STATE_CHANGED");
             }
+            subscription = intent.getIntExtra(MSimConstants.SUBSCRIPTION_KEY, 0);
+            Log.d(TAG,"ACTION_SIM_STATE_CHANGED intent received on sub = " + subscription);
+
             String stateExtra = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
             if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(stateExtra)) {
                 final String absentReason = intent
@@ -350,11 +368,13 @@ public class KeyguardUpdateMonitor {
                     state = IccCardConstants.State.PIN_REQUIRED;
                 } else if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK.equals(lockedReason)) {
                     state = IccCardConstants.State.PUK_REQUIRED;
+                } else if (IccCardConstants.INTENT_VALUE_LOCKED_PERSO.equals(stateExtra)) {
+                    state = IccCardConstants.State.PERSO_LOCKED;
                 } else {
                     state = IccCardConstants.State.UNKNOWN;
                 }
-            } else if (IccCardConstants.INTENT_VALUE_LOCKED_NETWORK.equals(stateExtra)) {
-                state = IccCardConstants.State.NETWORK_LOCKED;
+            } else if (IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR.equals(stateExtra)) {
+                state = IccCardConstants.State.CARD_IO_ERROR;
             } else if (IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(stateExtra)
                         || IccCardConstants.INTENT_VALUE_ICC_IMSI.equals(stateExtra)) {
                 // This is required because telephony doesn't return to "READY" after
@@ -363,7 +383,7 @@ public class KeyguardUpdateMonitor {
             } else {
                 state = IccCardConstants.State.UNKNOWN;
             }
-            return new SimArgs(state);
+            return new SimArgs(state, subscription);
         }
 
         public String toString() {
@@ -506,9 +526,19 @@ public class KeyguardUpdateMonitor {
         }
 
         // Take a guess at initial SIM state, battery status and PLMN until we get an update
-        mSimState = IccCardConstants.State.NOT_READY;
         mBatteryStatus = new BatteryStatus(BATTERY_STATUS_UNKNOWN, 100, 0, 0);
-        mTelephonyPlmn = getDefaultPlmn();
+        // MSimTelephonyManager.getDefault().getPhoneCount() returns '1' for single SIM
+        // mode and '2' for dual SIM mode.
+        int numPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+        // Initialize PLMN, SPN strings and SIM states for the subscriptions.
+        mTelephonyPlmn = new CharSequence[numPhones];
+        mTelephonySpn = new CharSequence[numPhones];
+        mSimState = new IccCardConstants.State[numPhones];
+        for (int i = 0; i < numPhones; i++) {
+            mTelephonyPlmn[i] = getDefaultPlmn();
+            mTelephonySpn[i] = null;
+            mSimState[i] = IccCardConstants.State.NOT_READY;
+        }
 
         // Watch for interesting updates
         final IntentFilter filter = new IntentFilter();
@@ -759,14 +789,19 @@ public class KeyguardUpdateMonitor {
     /**
      * Handle {@link #MSG_CARRIER_INFO_UPDATE}
      */
-    private void handleCarrierInfoUpdate() {
-        if (DEBUG) Log.d(TAG, "handleCarrierInfoUpdate: plmn = " + mTelephonyPlmn
-            + ", spn = " + mTelephonySpn);
-
+    private void handleCarrierInfoUpdate(int subscription) {
+        if (DEBUG) Log.d(TAG, "handleCarrierInfoUpdate: plmn = " + mTelephonyPlmn[subscription]
+                + ", spn = " + mTelephonySpn[subscription] + ", subscription = " + subscription);
         for (int i = 0; i < mCallbacks.size(); i++) {
             KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
             if (cb != null) {
-                cb.onRefreshCarrierInfo(mTelephonyPlmn, mTelephonySpn);
+                if (sIsMultiSimEnabled) {
+                    cb.onRefreshCarrierInfo(mTelephonyPlmn[subscription],
+                            mTelephonySpn[subscription], subscription);
+                } else {
+                    cb.onRefreshCarrierInfo(mTelephonyPlmn[subscription],
+                            mTelephonySpn[subscription]);
+                }
             }
         }
     }
@@ -776,18 +811,25 @@ public class KeyguardUpdateMonitor {
      */
     private void handleSimStateChange(SimArgs simArgs) {
         final IccCardConstants.State state = simArgs.simState;
+        final int subscription = simArgs.subscription;
 
-        if (DEBUG) {
-            Log.d(TAG, "handleSimStateChange: intentValue = " + simArgs + " "
-                    + "state resolved to " + state.toString());
-        }
+        Log.d(TAG, "handleSimStateChange: intentValue = " + simArgs + " "
+                + "state resolved to " + state.toString() + " "
+                + "subscription =" + subscription);
 
-        if (state != IccCardConstants.State.UNKNOWN && state != mSimState) {
-            mSimState = state;
+        if (state != IccCardConstants.State.UNKNOWN && state != mSimState[subscription]) {
+            if (DEBUG_SIM_STATES) Log.v(TAG, "dispatching state: " + state
+                    + "subscription: " + subscription);
+
+            mSimState[subscription] = state;
             for (int i = 0; i < mCallbacks.size(); i++) {
                 KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
                 if (cb != null) {
-                    cb.onSimStateChanged(state);
+                    if (sIsMultiSimEnabled) {
+                        cb.onSimStateChanged(state, subscription);
+                    } else {
+                        cb.onSimStateChanged(state);
+                    }
                 }
             }
         }
@@ -951,9 +993,18 @@ public class KeyguardUpdateMonitor {
         callback.onTimeChanged();
         callback.onRingerModeChanged(mRingMode);
         callback.onPhoneStateChanged(mPhoneState);
-        callback.onRefreshCarrierInfo(mTelephonyPlmn, mTelephonySpn);
         callback.onClockVisibilityChanged();
-        callback.onSimStateChanged(mSimState);
+        int subscription = MSimTelephonyManager.getDefault().getDefaultSubscription();
+        if (sIsMultiSimEnabled) {
+            for (int i=0; i < MSimTelephonyManager.getDefault().getPhoneCount(); i++) {
+                callback.onRefreshCarrierInfo(mTelephonyPlmn[i], mTelephonySpn[i], i);
+                callback.onSimStateChanged(mSimState[i], i);
+            }
+        } else {
+            callback.onRefreshCarrierInfo(mTelephonyPlmn[subscription],
+                   mTelephonySpn[subscription]);
+            callback.onSimStateChanged(mSimState[subscription]);
+        }
         callback.onMusicClientIdChanged(
                 mDisplayClientState.clientGeneration,
                 mDisplayClientState.clearing,
@@ -975,7 +1026,33 @@ public class KeyguardUpdateMonitor {
     }
 
     public IccCardConstants.State getSimState() {
-        return mSimState;
+        return getSimState(MSimTelephonyManager.getDefault().getDefaultSubscription());
+    }
+
+    public IccCardConstants.State getSimState(int subscription) {
+        return mSimState[subscription];
+    }
+
+    public int getPinLockedSubscription() {
+        int sub = -1;
+        for (int i = 0; i < mSimState.length; i++) {
+            if (mSimState[i] == IccCardConstants.State.PIN_REQUIRED) {
+                sub = i;
+                break;
+            }
+        }
+        return sub;
+    }
+
+    public int getPukLockedSubscription() {
+        int sub = -1;
+        for (int i = 0; i < mSimState.length; i++) {
+            if (mSimState[i] == IccCardConstants.State.PUK_REQUIRED) {
+                sub = i;
+                break;
+            }
+        }
+        return sub;
     }
 
     /**
@@ -987,7 +1064,13 @@ public class KeyguardUpdateMonitor {
      * through mHandler, this *must* be called from the UI thread.
      */
     public void reportSimUnlocked() {
-        handleSimStateChange(new SimArgs(IccCardConstants.State.READY));
+        reportSimUnlocked(MSimTelephonyManager.getDefault().getDefaultSubscription());
+    }
+
+    public void reportSimUnlocked(int subscription) {
+        if (DEBUG) Log.d(TAG, "reportSimUnlocked(" + subscription + ")");
+        mSimState[subscription] = IccCardConstants.State.READY;
+        handleSimStateChange(new SimArgs(mSimState[subscription], subscription));
     }
 
     /**
@@ -1007,11 +1090,19 @@ public class KeyguardUpdateMonitor {
     }
 
     public CharSequence getTelephonyPlmn() {
-        return mTelephonyPlmn;
+        return getTelephonyPlmn(MSimTelephonyManager.getDefault().getDefaultSubscription());
+    }
+
+    public CharSequence getTelephonyPlmn(int subscription) {
+        return mTelephonyPlmn[subscription];
     }
 
     public CharSequence getTelephonySpn() {
-        return mTelephonySpn;
+        return getTelephonySpn(MSimTelephonyManager.getDefault().getDefaultSubscription());
+    }
+
+    public CharSequence getTelephonySpn(int subscription) {
+        return mTelephonySpn[subscription];
     }
 
     /**
@@ -1060,7 +1151,18 @@ public class KeyguardUpdateMonitor {
     }
 
     public boolean isSimLocked() {
-        return isSimLocked(mSimState);
+        boolean isLocked = false;
+        for (IccCardConstants.State simState : mSimState) {
+            if (isSimLocked(simState)) {
+                isLocked = true;
+                break;
+            }
+        }
+        return isLocked;
+    }
+
+    public boolean isSimLocked(int subscription) {
+        return isSimLocked(mSimState[subscription]);
     }
 
     public static boolean isSimLocked(IccCardConstants.State state) {
@@ -1070,7 +1172,17 @@ public class KeyguardUpdateMonitor {
     }
 
     public boolean isSimPinSecure() {
-        return isSimPinSecure(mSimState);
+        boolean isSecure = false;
+        for (IccCardConstants.State simState : mSimState) {
+            if (isSimPinSecure(simState)) {
+                isSecure = true;
+                break;
+            }
+        }
+        return isSecure;
+    }
+    public boolean isSimPinSecure(int subscription) {
+        return isSimPinSecure(mSimState[subscription]);
     }
 
     public static boolean isSimPinSecure(IccCardConstants.State state) {
diff --git a/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitorCallback.java b/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitorCallback.java
index c08880d..a941672 100644
--- a/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitorCallback.java
+++ b/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitorCallback.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -172,4 +174,20 @@ class KeyguardUpdateMonitorCallback {
      *   {@link WindowManagerPolicy#OFF_BECAUSE_OF_PROX_SENSOR}.
      */
     public void onScreenTurnedOff(int why) { }
+    /**
+     * Called when the SIM state changes on subscription.
+     * @param simState
+     * @param subscription
+     */
+    void onSimStateChanged(IccCardConstants.State simState, int subscription) { }
+
+    /**
+     * Called when the carrier PLMN or SPN changes.
+     *
+     * @param plmn The operator name of the registered network.  May be null if it shouldn't
+     *   be displayed.
+     * @param spn The service provider name.  May be null if it shouldn't be displayed.
+     * @param subscription The subscription for which onRefreshCarrierInfo is meant
+     */
+    void onRefreshCarrierInfo(CharSequence plmn, CharSequence spn, int subscription) { }
 }
diff --git a/packages/Keyguard/src/com/android/keyguard/KeyguardViewMediator.java b/packages/Keyguard/src/com/android/keyguard/KeyguardViewMediator.java
index 4729f05..8901317 100644
--- a/packages/Keyguard/src/com/android/keyguard/KeyguardViewMediator.java
+++ b/packages/Keyguard/src/com/android/keyguard/KeyguardViewMediator.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2007 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -47,6 +49,7 @@ import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.Settings;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.TelephonyManager;
 import android.util.EventLog;
 import android.util.Log;
@@ -385,8 +388,12 @@ public class KeyguardViewMediator {
 
         @Override
         public void onSimStateChanged(IccCardConstants.State simState) {
-            if (DEBUG) Log.d(TAG, "onSimStateChanged: " + simState);
+            onSimStateChanged(simState, MSimTelephonyManager.getDefault().getDefaultSubscription());
+        }
 
+        @Override
+        public void onSimStateChanged(IccCardConstants.State simState, int subscription) {
+            if (DEBUG) Log.d(TAG, "onSimStateChanged: " + simState);
             switch (simState) {
                 case NOT_READY:
                 case ABSENT:
@@ -432,7 +439,7 @@ public class KeyguardViewMediator {
                     break;
                 case READY:
                     synchronized (this) {
-                        if (isShowing()) {
+                        if (isShowing() && !isSecure()) {
                             resetStateLocked(null);
                         }
                     }
@@ -941,14 +948,15 @@ public class KeyguardViewMediator {
         }
 
         // if the setup wizard hasn't run yet, don't show
-        final boolean requireSim = !SystemProperties.getBoolean("keyguard.no_require_sim",
-                false);
         final boolean provisioned = mUpdateMonitor.isDeviceProvisioned();
-        final IccCardConstants.State state = mUpdateMonitor.getSimState();
-        final boolean lockedOrMissing = state.isPinLocked()
-                || ((state == IccCardConstants.State.ABSENT
-                || state == IccCardConstants.State.PERM_DISABLED)
-                && requireSim);
+        int numPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+        final IccCardConstants.State []state = new IccCardConstants.State[numPhones];
+        boolean lockedOrMissing = false;
+        for (int i = 0; i < numPhones; i++) {
+            state[i] = mUpdateMonitor.getSimState(i);
+            lockedOrMissing = lockedOrMissing || isLockedOrMissing(state[i]);
+            if (lockedOrMissing) break;
+        }
 
         if (!lockedOrMissing && !provisioned) {
             if (DEBUG) Log.d(TAG, "doKeyguard: not showing because device isn't provisioned"
@@ -976,6 +984,15 @@ public class KeyguardViewMediator {
         showLocked(options);
     }
 
+    boolean isLockedOrMissing(IccCardConstants.State state) {
+        final boolean requireSim = !SystemProperties.getBoolean("keyguard.no_require_sim",
+                false);
+        return (state.isPinLocked()
+                || ((state == IccCardConstants.State.ABSENT
+                        || state == IccCardConstants.State.PERM_DISABLED)
+                    && requireSim));
+    }
+
     /**
      * Dismiss the keyguard through the security layers.
      */
diff --git a/packages/Keyguard/src/com/android/keyguard/msim/MSimCarrierText.java b/packages/Keyguard/src/com/android/keyguard/msim/MSimCarrierText.java
new file mode 100644
index 0000000..794b697
--- /dev/null
+++ b/packages/Keyguard/src/com/android/keyguard/msim/MSimCarrierText.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.keyguard;
+
+import android.content.Context;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.widget.TextView;
+
+import android.util.Log;
+
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.IccCardConstants.State;
+import com.android.internal.widget.LockPatternUtils;
+
+import android.telephony.MSimTelephonyManager;
+
+public class MSimCarrierText extends CarrierText {
+    private static final String TAG = "MSimCarrierText";
+    private CharSequence []mPlmn;
+    private CharSequence []mSpn;
+    private State []mSimState;
+
+    private KeyguardUpdateMonitorCallback mMSimCallback = new KeyguardUpdateMonitorCallback() {
+
+        @Override
+        public void onRefreshCarrierInfo(CharSequence plmn, CharSequence spn, int sub) {
+            mPlmn[sub] = plmn;
+            mSpn[sub] = spn;
+            updateCarrierText(mSimState, mPlmn, mSpn);
+        }
+
+        @Override
+        public void onSimStateChanged(IccCardConstants.State simState, int sub) {
+            mSimState[sub] = simState;
+            updateCarrierText(mSimState, mPlmn, mSpn);
+        }
+    };
+
+    private void initialize() {
+        int numPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+        mPlmn = new CharSequence[numPhones];
+        mSpn = new CharSequence[numPhones];
+        mSimState = new State[numPhones];
+    }
+
+    public MSimCarrierText(Context context) {
+        this(context, null);
+    }
+
+    public MSimCarrierText(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initialize();
+    }
+
+    protected void updateCarrierText(State []simState, CharSequence []plmn, CharSequence []spn) {
+        CharSequence text = "";
+        for (int i = 0; i < simState.length; i++) {
+            CharSequence displayText = getCarrierTextForSimState(simState[i], plmn[i], spn[i]);
+            if (mContext.getResources().getBoolean(R.bool.kg_use_all_caps)) {
+                displayText = (displayText != null ? displayText.toString().toUpperCase() : "");
+            }
+            text = (TextUtils.isEmpty(text)
+                    ? displayText
+                    : getContext().getString(R.string.msim_carrier_text_format, text, displayText));
+        }
+        Log.d(TAG, "updateCarrierText: text = " + text);
+        setText(text);
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mMSimCallback);
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        KeyguardUpdateMonitor.getInstance(mContext).removeCallback(mMSimCallback);
+    }
+}
+
diff --git a/packages/Keyguard/src/com/android/keyguard/msim/MSimKeyguardSimPinView.java b/packages/Keyguard/src/com/android/keyguard/msim/MSimKeyguardSimPinView.java
new file mode 100644
index 0000000..a95a4dc
--- /dev/null
+++ b/packages/Keyguard/src/com/android/keyguard/msim/MSimKeyguardSimPinView.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.keyguard;
+
+import com.android.internal.telephony.msim.ITelephonyMSim;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.telephony.MSimTelephonyManager;
+import android.util.AttributeSet;
+import android.view.View;
+import android.util.Log;
+
+import com.android.internal.telephony.IccCardConstants;
+
+/**
+ * Displays a PIN pad for unlocking.
+ */
+public class MSimKeyguardSimPinView extends KeyguardSimPinView {
+    private final static boolean DEBUG = KeyguardViewMediator.DEBUG;
+    private static String TAG = "MSimKeyguardSimPinView";
+    private static int sCancelledCount = 0;
+    private int mSubscription = -1;
+
+    public MSimKeyguardSimPinView(Context context) {
+        this(context, null);
+    }
+
+    public MSimKeyguardSimPinView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    protected void showCancelButton() {
+        final View cancel = findViewById(R.id.key_cancel);
+        if (cancel != null) {
+            cancel.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    doHapticKeyClick();
+                    closeKeyGuard(false);
+                }
+            });
+        }
+    }
+
+    /*
+    * CloseKeyGuard: Method used to Close the keyguard.
+    * @param bAuthenticated:
+    *               true:  user entered correct PIN and pressed OK.
+    *               false: user pressed cancel.
+    *
+    * Description: used to close keyguard when user presses cancel or
+    * user enters correct PIN and presses OK
+    *
+    * Logic:
+    * 1. Calculate number of SIMs configured i.e. selected from MultiSIM settings
+    * 2. Calculate number of SIMs which are PIN Locked
+    * 3. sCancelledCount will tell us number of keyguards got cancelled. If user tries to cancel
+    *    all Keyguard screens, do not allow him to close Keyguard as atleast one SIM has to
+    *    be authenticated before allowing user to access HomeScreen.
+    * 4. If present keyguard screen is last one we are about to show HomeScreen after closing this
+    *    keyguard so reset the sCancelledCount.
+    * 5. Report SIM unlocked to KGUpdateMonitor so that keyguard is closed right away without
+    *    waiting for indication from framework.
+    */
+    private void closeKeyGuard(boolean bAuthenticated) {
+        KeyguardUpdateMonitor updateMonitor = KeyguardUpdateMonitor.getInstance(getContext());
+        int numCardsConfigured = 0;
+        int numPinLocked = 0;
+        IccCardConstants.State simState = IccCardConstants.State.UNKNOWN;
+
+        int numPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+        for (int i = 0; i < numPhones; i++) {
+            simState = updateMonitor.getSimState(i);
+            if (simState == IccCardConstants.State.PIN_REQUIRED) {
+                numPinLocked++;
+            }
+
+            //Get number of cards that are present and configured.
+            //Exclude cards with DETECTED state as they are not configured and are not used.
+            if (simState == IccCardConstants.State.READY ||
+                simState == IccCardConstants.State.PIN_REQUIRED ||
+                simState == IccCardConstants.State.PUK_REQUIRED ||
+                simState == IccCardConstants.State.PERSO_LOCKED) {
+                numCardsConfigured++;
+            }
+        }
+
+        //If Cancel is pressed for last configured sub return without incrementing sCancelledCount
+        // else increment sCancelledCount.
+        if (!bAuthenticated) {
+            if (MSimKeyguardSimPinView.sCancelledCount >= (numCardsConfigured - 1)) {
+                return;
+            } else {
+                MSimKeyguardSimPinView.sCancelledCount++;
+            }
+        }
+
+        //If this is last PIN lock screen, we will show HomeScreen now.
+        //Hence reset the static sCancelledCount variable.
+        if (numPinLocked <= 1) {
+            MSimKeyguardSimPinView.sCancelledCount = 0;
+        }
+
+        //If Cancel is pressed get current locked sub,
+        //In case user presses OK we anyways have locked sub, no need to get again.
+        if (!bAuthenticated) mSubscription = updateMonitor.getPinLockedSubscription();
+
+        //Before closing the keyguard, report back that the sim is unlocked
+        //so it knows right away.
+        if (mSubscription >= 0) updateMonitor.reportSimUnlocked(mSubscription);
+        mCallback.dismiss(true);
+    }
+
+    public void resetState() {
+        String  displayMessage = "";
+        try {
+            mSubscription = KeyguardUpdateMonitor.getInstance(mContext)
+                    .getPinLockedSubscription();
+            int attemptsRemaining = ITelephonyMSim.Stub.asInterface(ServiceManager
+                    .checkService("phone_msim")).getIccPin1RetryCount(mSubscription);
+
+            if (attemptsRemaining >= 0) {
+                displayMessage = getContext().getString(R.string.keyguard_password_wrong_pin_code)
+                        + getContext().getString(R.string.pinpuk_attempts)
+                        + attemptsRemaining + ". ";
+            }
+        } catch (RemoteException ex) {
+            displayMessage = getContext().getString(R.string.keyguard_password_pin_failed);
+        }
+        displayMessage = getSecurityMessageDisplay(R.string.kg_sim_pin_instructions)
+                + displayMessage;
+        mSecurityMessageDisplay.setMessage(displayMessage, true);
+        mPasswordEntry.setEnabled(true);
+    }
+
+    /**
+     * Since the IPC can block, we want to run the request in a separate thread
+     * with a callback.
+     */
+    private abstract class MSimCheckSimPin extends Thread {
+        private final String mPin;
+
+        protected MSimCheckSimPin(String pin, int sub) {
+            mPin = pin;
+            mSubscription = sub;
+        }
+
+        abstract void onSimCheckResponse(boolean success);
+
+        @Override
+        public void run() {
+            try {
+                if (DEBUG) Log.d(TAG, "MSimCheckSimPin:run(), mPin = " + mPin
+                        + " mSubscription = " + mSubscription);
+                final boolean result = ITelephonyMSim.Stub.asInterface(ServiceManager
+                        .checkService("phone_msim")).supplyPin(mPin, mSubscription);
+                post(new Runnable() {
+                    public void run() {
+                        onSimCheckResponse(result);
+                    }
+                });
+            } catch (RemoteException e) {
+                post(new Runnable() {
+                    public void run() {
+                        onSimCheckResponse(false);
+                    }
+                });
+            }
+        }
+    }
+
+    @Override
+    protected void verifyPasswordAndUnlock() {
+        String entry = mPasswordEntry.getText().toString();
+        if (DEBUG) Log.d(TAG, "verifyPasswordAndUnlock(): entry = " + entry);
+
+        if (entry.length() < 4) {
+            // otherwise, display a message to the user, and don't submit.
+            mSecurityMessageDisplay.setMessage(
+                    getSecurityMessageDisplay(R.string.kg_invalid_sim_pin_hint), true);
+            mPasswordEntry.setText("");
+            mCallback.userActivity(0);
+            return;
+        }
+
+        getSimUnlockProgressDialog().show();
+
+        if (!mSimCheckInProgress) {
+            mSimCheckInProgress = true; // there should be only one
+
+            if (DEBUG) Log.d(TAG, "startCheckSimPin(), Multi SIM enabled");
+            new MSimCheckSimPin(mPasswordEntry.getText().toString(),
+                    KeyguardUpdateMonitor.getInstance(mContext).getPinLockedSubscription()) {
+                void onSimCheckResponse(final boolean success) {
+                    post(new Runnable() {
+                        public void run() {
+                            if (mSimUnlockProgressDialog != null) {
+                                mSimUnlockProgressDialog.hide();
+                            }
+                            if (success) {
+                                // before closing the keyguard, report back that the sim is unlocked
+                                // so it knows right away.
+                                closeKeyGuard(success);
+                            } else {
+                                mSecurityMessageDisplay.setMessage(getSecurityMessageDisplay
+                                        (R.string.kg_password_wrong_pin_code), true);
+                                mPasswordEntry.setText("");
+                            }
+                            mCallback.userActivity(0);
+                            mSimCheckInProgress = false;
+                        }
+                    });
+                }
+            }.start();
+        }
+    }
+
+    protected CharSequence getSecurityMessageDisplay(int resId) {
+        // Returns the String in the format
+        // "SUB:%d : %s", sub, msg
+        return getContext().getString(R.string.msim_kg_sim_pin_msg_format,
+                KeyguardUpdateMonitor.getInstance(mContext).getPinLockedSubscription()+1,
+                getContext().getResources().getText(resId));
+    }
+}
+
diff --git a/packages/Keyguard/src/com/android/keyguard/msim/MSimKeyguardSimPukView.java b/packages/Keyguard/src/com/android/keyguard/msim/MSimKeyguardSimPukView.java
new file mode 100644
index 0000000..a990454
--- /dev/null
+++ b/packages/Keyguard/src/com/android/keyguard/msim/MSimKeyguardSimPukView.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.keyguard;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.AttributeSet;
+import android.util.Log;
+
+import com.android.internal.telephony.msim.ITelephonyMSim;
+
+/**
+ * Displays a PIN pad for entering a PUK (Pin Unlock Kode) provided by a carrier.
+ */
+public class MSimKeyguardSimPukView extends KeyguardSimPukView {
+    private final static boolean DEBUG = KeyguardViewMediator.DEBUG;
+    private static String TAG = "MSimKeyguardSimPukView";
+
+    protected class MSimStateMachine extends KeyguardSimPukView.StateMachine {
+        public void next() {
+            int msg = 0;
+            if (state == ENTER_PUK) {
+                if (checkPuk()) {
+                    state = ENTER_PIN;
+                    msg = R.string.kg_puk_enter_pin_hint;
+                } else {
+                    msg = R.string.kg_invalid_sim_puk_hint;
+                }
+            } else if (state == ENTER_PIN) {
+                if (checkPin()) {
+                    state = CONFIRM_PIN;
+                    msg = R.string.kg_enter_confirm_pin_hint;
+                } else {
+                    msg = R.string.kg_invalid_sim_pin_hint;
+                }
+            } else if (state == CONFIRM_PIN) {
+                if (confirmPin()) {
+                    state = DONE;
+                    msg = R.string.keyguard_sim_unlock_progress_dialog_message;
+                    updateSim();
+                } else {
+                    state = ENTER_PIN; // try again?
+                    msg = R.string.kg_invalid_confirm_pin_hint;
+                }
+            }
+            mPasswordEntry.setText(null);
+            if (msg != 0) {
+                mSecurityMessageDisplay.setMessage(getSecurityMessageDisplay(msg), true);
+            }
+        }
+
+        void reset() {
+            String  displayMessage = "";
+            try {
+                int attemptsRemaining = ITelephonyMSim.Stub.asInterface(ServiceManager
+                        .checkService("phone_msim")).getIccPin1RetryCount(KeyguardUpdateMonitor
+                        .getInstance(mContext).getPukLockedSubscription());
+                if (attemptsRemaining >= 0) {
+                    displayMessage = getContext().getString(
+                            R.string.keyguard_password_wrong_puk_code)
+                            + getContext().getString(R.string.pinpuk_attempts)
+                            + attemptsRemaining + ". ";
+                }
+            } catch (RemoteException ex) {
+                displayMessage = getContext().getString(
+                        R.string.keyguard_password_puk_failed);
+            }
+            displayMessage = getSecurityMessageDisplay(R.string.kg_puk_enter_puk_hint)
+                    + displayMessage;
+            mPinText="";
+            mPukText="";
+            state = ENTER_PUK;
+            mSecurityMessageDisplay.setMessage(displayMessage, true);
+            mPasswordEntry.requestFocus();
+        }
+    }
+
+    public MSimKeyguardSimPukView(Context context) {
+        this(context, null);
+    }
+
+    public MSimKeyguardSimPukView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        mStateMachine = new MSimStateMachine();
+    }
+
+    /**
+     * Since the IPC can block, we want to run the request in a separate thread
+     * with a callback.
+     */
+    private abstract class MSimCheckSimPuk extends Thread {
+        private final String mPin, mPuk;
+        protected final int mSubscription;
+
+        protected MSimCheckSimPuk(String puk, String pin, int sub) {
+            mPuk = puk;
+            mPin = pin;
+            mSubscription = sub;
+        }
+
+        abstract void onSimLockChangedResponse(boolean success);
+
+        @Override
+        public void run() {
+            if (DEBUG) Log.d(TAG, "MSimCheckSimPuk:run(), mPuk = " + mPuk
+                    + " mPin = " + mPin + " mSubscription = " + mSubscription);
+            try {
+                final boolean result = ITelephonyMSim.Stub.asInterface(ServiceManager
+                        .checkService("phone_msim")).supplyPuk(mPuk, mPin, mSubscription);
+
+                post(new Runnable() {
+                    public void run() {
+                        onSimLockChangedResponse(result);
+                    }
+                });
+            } catch (RemoteException e) {
+                post(new Runnable() {
+                    public void run() {
+                        onSimLockChangedResponse(false);
+                    }
+                });
+            }
+        }
+    }
+
+    @Override
+    protected void updateSim() {
+        getSimUnlockProgressDialog().show();
+
+        if (DEBUG) Log.d(TAG, "updateSim()");
+
+        if (!mCheckInProgress) {
+            mCheckInProgress = true;
+
+            new MSimCheckSimPuk(mPukText, mPinText,
+                    KeyguardUpdateMonitor.getInstance(mContext).getPukLockedSubscription()) {
+                void onSimLockChangedResponse(final boolean success) {
+                    post(new Runnable() {
+                        public void run() {
+                            if (mSimUnlockProgressDialog != null) {
+                                mSimUnlockProgressDialog.hide();
+                            }
+                            if (success) {
+                                mCallback.dismiss(true);
+                            } else {
+                                mStateMachine.reset();
+                                mSecurityMessageDisplay.setMessage(
+                                    getSecurityMessageDisplay(R.string.kg_invalid_puk), true);
+                            }
+                            mCheckInProgress = false;
+                        }
+                    });
+                }
+            }.start();
+        }
+    }
+
+    protected CharSequence getSecurityMessageDisplay(int resId) {
+        // Returns the String in the format
+        // "SUB:%d : %s", sub, msg
+        return getContext().getString(R.string.msim_kg_sim_pin_msg_format,
+                KeyguardUpdateMonitor.getInstance(mContext).getPukLockedSubscription()+1,
+                getContext().getResources().getText(resId));
+    }
+}
+
diff --git a/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
index 4f6f223..9a14bd5 100644
--- a/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+++ b/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2007 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -40,6 +42,7 @@ import android.os.UserHandle;
 import android.provider.Settings;
 import android.provider.Settings.Global;
 import android.provider.Settings.Secure;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import android.util.Log;
@@ -61,6 +64,8 @@ import java.io.IOException;
 import java.util.HashSet;
 import java.util.List;
 
+import static com.android.internal.telephony.MSimConstants.MAX_PHONE_COUNT_TRI_SIM;
+
 /**
  * Database helper class for {@link SettingsProvider}.
  * Mostly just has a bit {@link #onCreate} to initialize the database.
@@ -2289,6 +2294,19 @@ public class DatabaseHelper extends SQLiteOpenHelper {
                             SystemProperties.get("ro.com.android.mobiledata",
                                     "true")) ? 1 : 0);
 
+            // SUB specific flags for Multisim devices
+            for (int i = 0; i < MAX_PHONE_COUNT_TRI_SIM; i++) {
+                // Mobile Data default, based on build
+                loadSetting(stmt, Settings.Global.MOBILE_DATA + i,
+                        "true".equalsIgnoreCase(
+                        SystemProperties.get("ro.com.android.mobiledata", "true")) ? 1 : 0);
+
+                // Data roaming default, based on build
+                loadSetting(stmt, Settings.Global.DATA_ROAMING + i,
+                        "true".equalsIgnoreCase(
+                        SystemProperties.get("ro.com.android.dataroaming", "true")) ? 1 : 0);
+            }
+
             loadBooleanSetting(stmt, Settings.Global.NETSTATS_ENABLED,
                     R.bool.def_netstats_enabled);
 
@@ -2349,7 +2367,11 @@ public class DatabaseHelper extends SQLiteOpenHelper {
             int type;
             type = SystemProperties.getInt("ro.telephony.default_network",
                         RILConstants.PREFERRED_NETWORK_MODE);
-            loadSetting(stmt, Settings.Global.PREFERRED_NETWORK_MODE, type);
+            String val = Integer.toString(type);
+            if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+                val = type + "," + type;
+            }
+            loadSetting(stmt, Settings.Global.PREFERRED_NETWORK_MODE, val);
 
             // Set the preferred cdma subscription source to target desired value or default
             // value defined in CdmaSubscriptionSourceManager
diff --git a/packages/SystemUI/res/layout/msim_signal_cluster_view.xml b/packages/SystemUI/res/layout/msim_signal_cluster_view.xml
new file mode 100644
index 0000000..ffc631a
--- /dev/null
+++ b/packages/SystemUI/res/layout/msim_signal_cluster_view.xml
@@ -0,0 +1,210 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* apps/common/assets/default/default/skins/StatusBar.xml
+**
+** Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+** Not a Contribution.
+** Copyright 2011 The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<com.android.systemui.statusbar.MSimSignalClusterView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_height="wrap_content"
+    android:layout_width="wrap_content"
+    android:orientation="horizontal"
+    >
+    <FrameLayout
+        android:id="@+id/wifi_combo"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        android:layout_marginRight="-6dp"
+        >
+        <ImageView
+            android:id="@+id/wifi_signal"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:layout_alignParentRight="true"
+            android:layout_centerVertical="true"
+            android:scaleType="center"
+            />
+        <ImageView
+            android:id="@+id/wifi_inout"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:layout_gravity="center|bottom"
+            />
+    </FrameLayout>
+    <View
+        android:layout_height="6dp"
+        android:layout_width="6dp"
+        android:visibility="gone"
+        android:id="@+id/spacer"
+        />
+    <!--<FrameLayout
+        android:id="@+id/wimax_combo"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        android:layout_marginRight="-6dp"
+        >
+        <ImageView
+            android:id="@+id/wimax_signal"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:layout_alignParentRight="true"
+            android:layout_centerVertical="true"
+            android:scaleType="center"
+            />
+        <ImageView
+            android:id="@+id/wimax_inout"
+            android:layout_height="wrap_content"
+            android:layout_width="wrap_content"
+            android:layout_gravity="center|bottom"
+            />
+    </FrameLayout>
+    -->
+    <FrameLayout
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        >
+        <View
+            android:layout_height="6dp"
+            android:layout_width="6dp"
+            android:visibility="invisible"
+            />
+        <FrameLayout
+            android:id="@+id/mobile_combo_sub3"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            >
+            <ImageView
+                android:id="@+id/mobile_signal_sub3"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="center|bottom"
+                />
+            <ImageView
+                android:id="@+id/mobile_type_sub3"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="center|bottom"
+                />
+            <ImageView
+                android:id="@+id/mobile_inout_sub3"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="right|bottom"
+                />
+            <ImageView
+                android:id="@+id/no_sim_slot3"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                />
+        </FrameLayout>
+    </FrameLayout>
+    <View
+        android:layout_height="8dp"
+        android:layout_width="8dp"
+        android:id="@+id/spacer"
+        />
+    <FrameLayout
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        >
+        <View
+            android:layout_height="6dp"
+            android:layout_width="6dp"
+            android:visibility="invisible"
+            />
+        <FrameLayout
+            android:id="@+id/mobile_combo_sub2"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            >
+            <ImageView
+                android:id="@+id/mobile_signal_sub2"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="center|bottom"
+                />
+            <ImageView
+                android:id="@+id/mobile_type_sub2"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="center|bottom"
+                />
+            <ImageView
+                android:id="@+id/mobile_inout_sub2"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="right|bottom"
+                />
+            <ImageView
+                android:id="@+id/no_sim_slot2"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                />
+        </FrameLayout>
+    </FrameLayout>
+    <View
+        android:layout_height="8dp"
+        android:layout_width="8dp"
+        android:id="@+id/spacer"
+        />
+    <FrameLayout
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        >
+        <View
+            android:layout_height="6dp"
+            android:layout_width="6dp"
+            android:visibility="invisible"
+            />
+        <FrameLayout
+            android:id="@+id/mobile_combo"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            >
+            <ImageView
+                android:id="@+id/mobile_signal"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="center|bottom"
+                />
+            <ImageView
+                android:id="@+id/mobile_type"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="center|bottom"
+                />
+            <ImageView
+                android:id="@+id/mobile_inout"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_gravity="right|bottom"
+                />
+            <ImageView
+                android:id="@+id/no_sim"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                />
+        </FrameLayout>
+    </FrameLayout>
+    <ImageView
+        android:id="@+id/airplane"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        />
+</com.android.systemui.statusbar.MSimSignalClusterView>
diff --git a/packages/SystemUI/res/layout/msim_status_bar.xml b/packages/SystemUI/res/layout/msim_status_bar.xml
new file mode 100644
index 0000000..49124c1
--- /dev/null
+++ b/packages/SystemUI/res/layout/msim_status_bar.xml
@@ -0,0 +1,162 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* apps/common/assets/default/default/skins/StatusBar.xml
+**
+** Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+** Not a Contribution.
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<!--    android:background="@drawable/status_bar_closed_default_background" -->
+<com.android.systemui.statusbar.phone.PhoneStatusBarView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:systemui="http://schemas.android.com/apk/res/com.android.systemui"
+    android:id="@+id/msim_status_bar"
+    android:background="@drawable/system_bar_background"
+    android:orientation="vertical"
+    android:focusable="true"
+    android:descendantFocusability="afterDescendants"
+    android:fitsSystemWindows="true"
+    >
+
+    <ImageView
+        android:id="@+id/notification_lights_out"
+        android:layout_width="@dimen/status_bar_icon_size"
+        android:layout_height="match_parent"
+        android:paddingLeft="6dip"
+        android:paddingBottom="2dip"
+        android:src="@drawable/ic_sysbar_lights_out_dot_small"
+        android:scaleType="center"
+        android:visibility="gone"
+        />
+
+    <LinearLayout android:id="@+id/status_bar_contents"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:paddingLeft="6dip"
+        android:paddingRight="6dip"
+        android:orientation="horizontal"
+        >
+
+        <LinearLayout
+            android:id="@+id/notification_icon_area"
+            android:layout_width="0dip"
+            android:layout_height="match_parent"
+            android:layout_weight="1"
+            android:orientation="horizontal"
+            >
+            <com.android.systemui.statusbar.StatusBarIconView android:id="@+id/moreIcon"
+                android:layout_width="@dimen/status_bar_icon_size"
+                android:layout_height="match_parent"
+                android:src="@drawable/stat_notify_more"
+                android:visibility="gone"
+                />
+
+            <com.android.systemui.statusbar.phone.IconMerger android:id="@+id/notificationIcons"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:layout_alignParentLeft="true"
+                android:gravity="center_vertical"
+                android:orientation="horizontal"/>
+        </LinearLayout>
+
+        <LinearLayout android:id="@+id/system_icon_area"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:orientation="horizontal">
+
+            <LinearLayout android:id="@+id/statusIcons"
+                android:layout_width="wrap_content"
+                android:layout_height="match_parent"
+                android:gravity="center_vertical"
+                android:orientation="horizontal"/>
+
+            <LinearLayout
+                android:id="@+id/signal_battery_cluster"
+                android:layout_width="wrap_content"
+                android:layout_height="match_parent"
+                android:paddingLeft="2dp"
+                android:orientation="horizontal"
+                android:gravity="center"
+                >
+                <include layout="@layout/msim_signal_cluster_view"
+                    android:id="@+id/msim_signal_cluster"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    />
+                <ImageView
+                    android:id="@+id/battery"
+                    android:layout_height="wrap_content"
+                    android:layout_width="wrap_content"
+                    android:paddingLeft="4dip"
+                    />
+            </LinearLayout>
+
+            <com.android.systemui.statusbar.policy.Clock
+                android:id="@+id/clock"
+                android:textAppearance="@style/TextAppearance.StatusBar.Clock"
+                android:layout_width="wrap_content"
+                android:layout_height="match_parent"
+                android:singleLine="true"
+                android:paddingLeft="6dip"
+                android:gravity="center_vertical|left"
+                />
+        </LinearLayout>
+    </LinearLayout>
+
+    <LinearLayout android:id="@+id/ticker"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:paddingLeft="6dip"
+        android:animationCache="false"
+        android:orientation="horizontal" >
+        <ImageSwitcher android:id="@+id/tickerIcon"
+            android:layout_width="@dimen/status_bar_icon_size"
+            android:layout_height="@dimen/status_bar_icon_size"
+            android:layout_marginRight="4dip"
+            >
+            <com.android.systemui.statusbar.AnimatedImageView
+                android:layout_width="@dimen/status_bar_icon_size"
+                android:layout_height="@dimen/status_bar_icon_size"
+                android:scaleType="center"
+                />
+            <com.android.systemui.statusbar.AnimatedImageView
+                android:layout_width="@dimen/status_bar_icon_size"
+                android:layout_height="@dimen/status_bar_icon_size"
+                android:scaleType="center"
+                />
+        </ImageSwitcher>
+        <com.android.systemui.statusbar.phone.TickerView android:id="@+id/tickerText"
+            android:layout_width="0dip"
+            android:layout_weight="1"
+            android:layout_height="wrap_content"
+            android:paddingTop="2dip"
+            android:paddingRight="10dip">
+            <TextView
+                android:textAppearance="@style/TextAppearance.StatusBar.PhoneTicker"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:singleLine="true"
+                />
+            <TextView
+                android:textAppearance="@style/TextAppearance.StatusBar.PhoneTicker"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:singleLine="true"
+                />
+        </com.android.systemui.statusbar.phone.TickerView>
+    </LinearLayout>
+</com.android.systemui.statusbar.phone.PhoneStatusBarView>
diff --git a/packages/SystemUI/res/layout/msim_super_status_bar.xml b/packages/SystemUI/res/layout/msim_super_status_bar.xml
new file mode 100644
index 0000000..e3e4295
--- /dev/null
+++ b/packages/SystemUI/res/layout/msim_super_status_bar.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+**
+** Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+** Not a Contribution.
+** Copyright 2012, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<!-- This is the combined status bar / notification panel window. -->
+<com.android.systemui.statusbar.phone.StatusBarWindowView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:systemui="http://schemas.android.com/apk/res/com.android.systemui"
+    android:focusable="true"
+    android:descendantFocusability="afterDescendants"
+    android:fitsSystemWindows="true"
+    android:background="@android:color/transparent"
+    >
+
+    <include layout="@layout/msim_status_bar"
+        android:layout_width="match_parent"
+        android:layout_height="@*android:dimen/status_bar_height"
+        />
+
+    <com.android.systemui.statusbar.phone.PanelHolder
+        android:id="@+id/msim_panel_holder"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        >
+        <include layout="@layout/status_bar_expanded"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            />
+        <ViewStub android:id="@+id/quick_settings_stub"
+            android:layout="@layout/quick_settings"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            />
+    </com.android.systemui.statusbar.phone.PanelHolder>
+
+</com.android.systemui.statusbar.phone.StatusBarWindowView>
diff --git a/packages/SystemUI/res/layout/signal_cluster_view.xml b/packages/SystemUI/res/layout/signal_cluster_view.xml
index 66b06ef..5938f50 100644
--- a/packages/SystemUI/res/layout/signal_cluster_view.xml
+++ b/packages/SystemUI/res/layout/signal_cluster_view.xml
@@ -2,6 +2,8 @@
 <!--
 /* apps/common/assets/default/default/skins/StatusBar.xml
 **
+** Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+** Not a Contribution.
 ** Copyright 2011, The Android Open Source Project
 **
 ** Licensed under the Apache License, Version 2.0 (the "License"); 
@@ -104,6 +106,11 @@
                 android:layout_width="wrap_content"
                 android:layout_gravity="end|bottom"
                 />
+            <ImageView
+                android:id="@+id/no_sim"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                />
         </FrameLayout>
     </FrameLayout>
     <ImageView
diff --git a/packages/SystemUI/res/layout/status_bar_expanded.xml b/packages/SystemUI/res/layout/status_bar_expanded.xml
index fd2a4ee..65f9fd2 100644
--- a/packages/SystemUI/res/layout/status_bar_expanded.xml
+++ b/packages/SystemUI/res/layout/status_bar_expanded.xml
@@ -37,14 +37,28 @@
         android:visibility="invisible"
         />
 
-    <include
-        layout="@layout/carrier_label"
-        android:layout_height="@dimen/carrier_label_height"
+    <LinearLayout
         android:layout_width="match_parent"
-        android:layout_marginBottom="@dimen/close_handle_height"
+        android:layout_height="wrap_content"
         android:layout_gravity="bottom"
-        />
+        android:orientation="vertical"
+        android:animateLayoutChanges="false"
+        >
+        <include
+            layout="@layout/subs_label"
+            android:layout_height="@dimen/carrier_label_height"
+            android:layout_width="match_parent"
+            android:layout_gravity="bottom"
+            />
 
+        <include
+            layout="@layout/carrier_label"
+            android:layout_height="@dimen/carrier_label_height"
+            android:layout_width="match_parent"
+            android:layout_marginBottom="@dimen/close_handle_height"
+            android:layout_gravity="bottom"
+            />
+    </LinearLayout>
     <LinearLayout
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
@@ -83,7 +97,7 @@
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content"
                 />
-    
+
             <ScrollView
                 android:id="@+id/scroll"
                 android:layout_width="match_parent"
diff --git a/packages/SystemUI/res/layout/subs_label.xml b/packages/SystemUI/res/layout/subs_label.xml
new file mode 100644
index 0000000..dcde7e1
--- /dev/null
+++ b/packages/SystemUI/res/layout/subs_label.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+** Not a Contribution.
+** Copyright 2012, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+
+<TextView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/subs_label"
+    android:textAppearance="@style/TextAppearance.StatusBar.Expanded.Network"
+    android:layout_height="@dimen/carrier_label_height"
+    android:layout_width="match_parent"
+    android:layout_marginBottom="@dimen/close_handle_height"
+    android:layout_gravity="bottom"
+    android:gravity="center"
+    android:visibility="invisible"
+    />
+
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/MSimSignalClusterView.java b/packages/SystemUI/src/com/android/systemui/statusbar/MSimSignalClusterView.java
new file mode 100644
index 0000000..41cb249
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/MSimSignalClusterView.java
@@ -0,0 +1,242 @@
+/*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar;
+
+import android.content.Context;
+import android.telephony.MSimTelephonyManager;
+import android.telephony.TelephonyManager;
+import android.util.AttributeSet;
+import android.util.Slog;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+
+import com.android.internal.telephony.MSimConstants;
+import com.android.systemui.statusbar.policy.NetworkController;
+import com.android.systemui.statusbar.policy.MSimNetworkController;
+
+import com.android.systemui.R;
+
+// Intimately tied to the design of res/layout/msim_signal_cluster_view.xml
+public class MSimSignalClusterView
+        extends LinearLayout
+        implements MSimNetworkController.MSimSignalCluster {
+
+    static final boolean DEBUG = false;
+    static final String TAG = "MSimSignalClusterView";
+
+    MSimNetworkController mMSimNC;
+
+    private boolean mWifiVisible = false;
+    private int mWifiStrengthId = 0, mWifiActivityId = 0;
+    private boolean mMobileVisible = false;
+    private int[] mMobileStrengthId;
+    private int[] mMobileActivityId;
+    private int[] mMobileTypeId;
+    private int[] mNoSimIconId;
+    private boolean mIsAirplaneMode = false;
+    private int mAirplaneIconId = 0;
+    private String mWifiDescription, mMobileTypeDescription;
+    private String[] mMobileDescription;
+
+    ViewGroup mWifiGroup;
+    ViewGroup[] mMobileGroup;
+    ImageView mWifi, mWifiActivity, mAirplane;
+    ImageView[] mNoSimSlot;
+    ImageView[] mMobile;
+    ImageView[] mMobileActivity;
+    ImageView[] mMobileType;
+    View mSpacer;
+    private int[] mMobileGroupResourceId = {R.id.mobile_combo, R.id.mobile_combo_sub2,
+                                          R.id.mobile_combo_sub3};
+    private int[] mMobileResourceId = {R.id.mobile_signal, R.id.mobile_signal_sub2,
+                                     R.id.mobile_signal_sub3};
+    private int[] mMobileActResourceId = {R.id.mobile_inout, R.id.mobile_inout_sub2,
+                                        R.id.mobile_inout_sub3};
+    private int[] mMobileTypeResourceId = {R.id.mobile_type, R.id.mobile_type_sub2,
+                                         R.id.mobile_type_sub3};
+    private int[] mNoSimSlotResourceId = {R.id.no_sim, R.id.no_sim_slot2, R.id.no_sim_slot3};
+    private int mNumPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+
+    public MSimSignalClusterView(Context context) {
+        this(context, null);
+    }
+
+    public MSimSignalClusterView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public MSimSignalClusterView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        mMobileStrengthId = new int[mNumPhones];
+        mMobileDescription = new String[mNumPhones];
+        mMobileTypeId = new int[mNumPhones];
+        mMobileActivityId = new int[mNumPhones];
+        mNoSimIconId = new int[mNumPhones];
+        mMobileGroup = new ViewGroup[mNumPhones];
+        mNoSimSlot = new ImageView[mNumPhones];
+        mMobile = new ImageView[mNumPhones];
+        mMobileActivity = new ImageView[mNumPhones];
+        mMobileType = new ImageView[mNumPhones];
+        for(int i=0; i < mNumPhones; i++) {
+            mMobileStrengthId[i] = 0;
+            mMobileTypeId[i] = 0;
+            mMobileActivityId[i] = 0;
+            mNoSimIconId[i] = 0;
+        }
+    }
+
+    public void setNetworkController(MSimNetworkController nc) {
+        if (DEBUG) Slog.d(TAG, "MSimNetworkController=" + nc);
+        mMSimNC = nc;
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        mWifiGroup      = (ViewGroup) findViewById(R.id.wifi_combo);
+        mWifi           = (ImageView) findViewById(R.id.wifi_signal);
+        mWifiActivity   = (ImageView) findViewById(R.id.wifi_inout);
+        mSpacer         =             findViewById(R.id.spacer);
+        mAirplane       = (ImageView) findViewById(R.id.airplane);
+
+        for (int i = 0; i < mNumPhones; i++) {
+            mMobileGroup[i]    = (ViewGroup) findViewById(mMobileGroupResourceId[i]);
+            mMobile[i]         = (ImageView) findViewById(mMobileResourceId[i]);
+            mMobileActivity[i] = (ImageView) findViewById(mMobileActResourceId[i]);
+            mMobileType[i]     = (ImageView) findViewById(mMobileTypeResourceId[i]);
+            mNoSimSlot[i]      = (ImageView) findViewById(mNoSimSlotResourceId[i]);
+        }
+        applySubscription(MSimTelephonyManager.getDefault().getDefaultSubscription());
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        mWifiGroup      = null;
+        mWifi           = null;
+        mWifiActivity   = null;
+        mSpacer         = null;
+        mAirplane       = null;
+        for (int i = 0; i < mNumPhones; i++) {
+            mMobileGroup[i]    = null;
+            mMobile[i]         = null;
+            mMobileActivity[i] = null;
+            mMobileType[i]     = null;
+            mNoSimSlot[i]      = null;
+        }
+        super.onDetachedFromWindow();
+    }
+
+    @Override
+    public void setWifiIndicators(boolean visible, int strengthIcon, String contentDescription) {
+        mWifiVisible = visible;
+        mWifiStrengthId = strengthIcon;
+        mWifiDescription = contentDescription;
+
+        applySubscription(MSimTelephonyManager.getDefault().getDefaultSubscription());
+    }
+
+    @Override
+    public void setMobileDataIndicators(boolean visible, int strengthIcon,
+            int typeIcon, String contentDescription, String typeContentDescription,
+            int noSimIcon, int subscription) {
+        mMobileVisible = visible;
+        mMobileStrengthId[subscription] = strengthIcon;
+        mMobileTypeId[subscription] = typeIcon;
+        mMobileDescription[subscription] = contentDescription;
+        mMobileTypeDescription = typeContentDescription;
+        mNoSimIconId[subscription] = noSimIcon;
+
+        applySubscription(subscription);
+    }
+
+    @Override
+    public void setIsAirplaneMode(boolean is, int airplaneIconId) {
+        mIsAirplaneMode = is;
+        mAirplaneIconId = airplaneIconId;
+
+        applySubscription(MSimTelephonyManager.getDefault().getDefaultSubscription());
+    }
+
+    @Override
+    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
+        // Standard group layout onPopulateAccessibilityEvent() implementations
+        // ignore content description, so populate manually
+        if (mWifiVisible && mWifiGroup.getContentDescription() != null)
+            event.getText().add(mWifiGroup.getContentDescription());
+        if (mMobileVisible && mMobileGroup[MSimConstants.DEFAULT_SUBSCRIPTION].
+                getContentDescription() != null)
+            event.getText().add(mMobileGroup[MSimConstants.DEFAULT_SUBSCRIPTION].
+                    getContentDescription());
+        return super.dispatchPopulateAccessibilityEvent(event);
+    }
+
+    // Run after each indicator change.
+    private void applySubscription(int subscription) {
+        if (mWifiGroup == null) return;
+
+        if (mWifiVisible) {
+            mWifiGroup.setVisibility(View.VISIBLE);
+            mWifi.setImageResource(mWifiStrengthId);
+            mWifiActivity.setImageResource(mWifiActivityId);
+            mWifiGroup.setContentDescription(mWifiDescription);
+        } else {
+            mWifiGroup.setVisibility(View.GONE);
+        }
+
+        if (DEBUG) Slog.d(TAG,
+                String.format("wifi: %s sig=%d act=%d",
+                (mWifiVisible ? "VISIBLE" : "GONE"), mWifiStrengthId, mWifiActivityId));
+
+        if (mMobileVisible && !mIsAirplaneMode) {
+            mMobileGroup[subscription].setVisibility(View.VISIBLE);
+            mMobile[subscription].setImageResource(mMobileStrengthId[subscription]);
+            mMobileGroup[subscription].setContentDescription(mMobileTypeDescription + " "
+                + mMobileDescription[subscription]);
+            mMobileActivity[subscription].setImageResource(mMobileActivityId[subscription]);
+            mMobileType[subscription].setImageResource(mMobileTypeId[subscription]);
+            mMobileType[subscription].setVisibility(
+                !mWifiVisible ? View.VISIBLE : View.GONE);
+            mNoSimSlot[subscription].setImageResource(mNoSimIconId[subscription]);
+        } else {
+            mMobileGroup[subscription].setVisibility(View.GONE);
+        }
+
+        if (mIsAirplaneMode) {
+            mAirplane.setVisibility(View.VISIBLE);
+            mAirplane.setImageResource(mAirplaneIconId);
+        } else {
+            mAirplane.setVisibility(View.GONE);
+        }
+
+        if (subscription != 0) {
+            if (mMobileVisible && mWifiVisible && ((mIsAirplaneMode) ||
+                    (mNoSimIconId[subscription] != 0))) {
+                mSpacer.setVisibility(View.INVISIBLE);
+            } else {
+                mSpacer.setVisibility(View.GONE);
+            }
+        }
+
+    }
+}
+
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java b/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java
index 1f662ff..7a41bde 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/SignalClusterView.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2011 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -46,13 +48,14 @@ public class SignalClusterView
     private boolean mWifiVisible = false;
     private int mWifiStrengthId = 0, mWifiActivityId = 0;
     private boolean mMobileVisible = false;
-    private int mMobileStrengthId = 0, mMobileActivityId = 0, mMobileTypeId = 0;
+    private int mMobileStrengthId = 0, mMobileActivityId = 0;
+    private int mMobileTypeId = 0, mNoSimIconId = 0;
     private boolean mIsAirplaneMode = false;
     private int mAirplaneIconId = 0;
     private String mWifiDescription, mMobileDescription, mMobileTypeDescription;
 
     ViewGroup mWifiGroup, mMobileGroup;
-    ImageView mWifi, mMobile, mWifiActivity, mMobileActivity, mMobileType, mAirplane;
+    ImageView mWifi, mMobile, mWifiActivity, mMobileActivity, mMobileType, mAirplane, mNoSimSlot;
     View mSpacer;
 
     public SignalClusterView(Context context) {
@@ -83,6 +86,7 @@ public class SignalClusterView
         mMobile         = (ImageView) findViewById(R.id.mobile_signal);
         mMobileActivity = (ImageView) findViewById(R.id.mobile_inout);
         mMobileType     = (ImageView) findViewById(R.id.mobile_type);
+        mNoSimSlot      = (ImageView) findViewById(R.id.no_sim);
         mSpacer         =             findViewById(R.id.spacer);
         mAirplane       = (ImageView) findViewById(R.id.airplane);
 
@@ -98,6 +102,7 @@ public class SignalClusterView
         mMobile         = null;
         mMobileActivity = null;
         mMobileType     = null;
+        mNoSimSlot      = null;
         mSpacer         = null;
         mAirplane       = null;
 
@@ -117,13 +122,15 @@ public class SignalClusterView
 
     @Override
     public void setMobileDataIndicators(boolean visible, int strengthIcon, int activityIcon,
-            int typeIcon, String contentDescription, String typeContentDescription) {
+            int typeIcon, String contentDescription, String typeContentDescription,
+            int noSimIcon) {
         mMobileVisible = visible;
         mMobileStrengthId = strengthIcon;
         mMobileActivityId = activityIcon;
         mMobileTypeId = typeIcon;
         mMobileDescription = contentDescription;
         mMobileTypeDescription = typeContentDescription;
+        mNoSimIconId = noSimIcon;
 
         apply();
     }
@@ -201,6 +208,7 @@ public class SignalClusterView
 
             mMobileGroup.setContentDescription(mMobileTypeDescription + " " + mMobileDescription);
             mMobileGroup.setVisibility(View.VISIBLE);
+            mNoSimSlot.setImageResource(mNoSimIconId);
         } else {
             mMobileGroup.setVisibility(View.GONE);
         }
@@ -212,7 +220,8 @@ public class SignalClusterView
             mAirplane.setVisibility(View.GONE);
         }
 
-        if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
+        if (mMobileVisible && mWifiVisible &&
+                ((mIsAirplaneMode) || (mNoSimIconId != 0))) {
             mSpacer.setVisibility(View.INVISIBLE);
         } else {
             mSpacer.setVisibility(View.GONE);
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
index 784852c..bda5adb 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2010 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -64,6 +66,8 @@ import android.os.SystemClock;
 import android.os.UserHandle;
 import android.provider.Settings;
 import android.service.notification.StatusBarNotification;
+import android.telephony.MSimTelephonyManager;
+import android.telephony.TelephonyManager;
 import android.util.DisplayMetrics;
 import android.util.EventLog;
 import android.util.Log;
@@ -101,6 +105,7 @@ import com.android.systemui.BatteryMeterView;
 import com.android.systemui.statusbar.BaseStatusBar;
 import com.android.systemui.statusbar.CommandQueue;
 import com.android.systemui.statusbar.GestureRecorder;
+import com.android.systemui.statusbar.MSimSignalClusterView;
 import com.android.systemui.statusbar.NotificationData;
 import com.android.systemui.statusbar.NotificationData.Entry;
 import com.android.systemui.statusbar.SignalClusterTextView;
@@ -112,6 +117,7 @@ import com.android.systemui.statusbar.policy.DateView;
 import com.android.systemui.statusbar.policy.DockBatteryController;
 import com.android.systemui.statusbar.policy.HeadsUpNotificationView;
 import com.android.systemui.statusbar.policy.LocationController;
+import com.android.systemui.statusbar.policy.MSimNetworkController;
 import com.android.systemui.statusbar.policy.NetworkController;
 import com.android.systemui.statusbar.policy.NotificationRowLayout;
 import com.android.systemui.statusbar.policy.OnSizeChangedListener;
@@ -184,6 +190,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
     LocationController mLocationController;
     NetworkController mNetworkController;
     RotationLockController mRotationLockController;
+    MSimNetworkController mMSimNetworkController;
 
     int mNaturalBarHeight = -1;
     int mIconSize = -1;
@@ -248,6 +255,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
 
     // carrier/wifi label
     private TextView mCarrierLabel;
+    private TextView mSubsLabel;
     private boolean mCarrierLabelVisible = false;
     private int mCarrierLabelHeight;
     private TextView mEmergencyCallLabel;
@@ -536,8 +544,13 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
 
         mIconSize = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_icon_size);
 
-        mStatusBarWindow = (StatusBarWindowView) View.inflate(context,
-                R.layout.super_status_bar, null);
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            mStatusBarWindow = (StatusBarWindowView) View.inflate(context,
+                    R.layout.msim_super_status_bar, null);
+        } else {
+            mStatusBarWindow = (StatusBarWindowView) View.inflate(context,
+                    R.layout.super_status_bar, null);
+        }
         mStatusBarWindow.mService = this;
         mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {
             @Override
@@ -551,10 +564,20 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
                 return mStatusBarWindow.onTouchEvent(event);
             }});
 
-        mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(
+                    R.id.msim_status_bar);
+        } else {
+            mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
+        }
         mStatusBarView.setBar(this);
 
-        PanelHolder holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
+        PanelHolder holder;
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.msim_panel_holder);
+        } else {
+            holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
+        }
         mStatusBarView.setPanelHolder(holder);
 
         mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
@@ -710,12 +733,19 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
         mNetworkController.addSignalStrengthChangedCallback(mSignalTextView);
         mSignalClusterView.setNetworkController(mNetworkController);
 
-        final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
-        if (isAPhone) {
-            mEmergencyCallLabel =
-                    (TextView) mStatusBarWindow.findViewById(R.id.emergency_calls_only);
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            mMSimNetworkController = new MSimNetworkController(mContext);
+            MSimSignalClusterView mSimSignalCluster = (MSimSignalClusterView)
+              mStatusBarView.findViewById(R.id.msim_signal_cluster);
+            for (int i=0; i < MSimTelephonyManager.getDefault().getPhoneCount(); i++) {
+                mMSimNetworkController.addSignalCluster(mSimSignalCluster, i);
+            }
+            mSimSignalCluster.setNetworkController(mMSimNetworkController);
+
+            mEmergencyCallLabel = (TextView)mStatusBarWindow.findViewById(
+                                                          R.id.emergency_calls_only);
             if (mEmergencyCallLabel != null) {
-                mNetworkController.addEmergencyLabelView(mEmergencyCallLabel);
+                mMSimNetworkController.addEmergencyLabelView(mEmergencyCallLabel);
                 mEmergencyCallLabel.setOnClickListener(new View.OnClickListener() {
                     public void onClick(View v) { }});
                 mEmergencyCallLabel.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
@@ -725,29 +755,82 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
                         updateCarrierLabelVisibility(false);
                     }});
             }
-        }
 
-        mCarrierLabel = (TextView)mStatusBarWindow.findViewById(R.id.carrier_label);
-        mShowCarrierInPanel = (mCarrierLabel != null);
-        if (DEBUG) Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" + mShowCarrierInPanel);
-        if (mShowCarrierInPanel) {
-            mCarrierLabel.setVisibility(mCarrierLabelVisible ? View.VISIBLE : View.INVISIBLE);
+            mCarrierLabel = (TextView)mStatusBarWindow.findViewById(R.id.carrier_label);
+            mSubsLabel = (TextView)mStatusBarWindow.findViewById(R.id.subs_label);
+            mShowCarrierInPanel = (mCarrierLabel != null);
 
-            // for mobile devices, we always show mobile connection info here (SPN/PLMN)
-            // for other devices, we show whatever network is connected
-            if (mNetworkController.hasMobileDataFeature()) {
-                mNetworkController.addMobileLabelView(mCarrierLabel);
-            } else {
-                mNetworkController.addCombinedLabelView(mCarrierLabel);
+            if (DEBUG) Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" +
+                                    mShowCarrierInPanel + "operator label=" + mSubsLabel);
+            if (mShowCarrierInPanel) {
+                mCarrierLabel.setVisibility(mCarrierLabelVisible ? View.VISIBLE : View.INVISIBLE);
+
+                // for mobile devices, we always show mobile connection info here (SPN/PLMN)
+                // for other devices, we show whatever network is connected
+                if (mMSimNetworkController.hasMobileDataFeature()) {
+                    mMSimNetworkController.addMobileLabelView(mCarrierLabel);
+                } else {
+                    mMSimNetworkController.addCombinedLabelView(mCarrierLabel);
+                }
+                mSubsLabel.setVisibility(View.VISIBLE);
+                mMSimNetworkController.addSubsLabelView(mSubsLabel);
+                // set up the dynamic hide/show of the label
+                mPile.setOnSizeChangedListener(new OnSizeChangedListener() {
+                    @Override
+                    public void onSizeChanged(View view, int w, int h, int oldw, int oldh) {
+                        updateCarrierLabelVisibility(false);
+                    }
+                });
+            }
+        } else {
+            mNetworkController = new NetworkController(mContext);
+            final SignalClusterView signalCluster =
+                (SignalClusterView)mStatusBarView.findViewById(R.id.signal_cluster);
+
+            mNetworkController.addSignalCluster(signalCluster);
+            signalCluster.setNetworkController(mNetworkController);
+
+            final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
+            if (isAPhone) {
+                mEmergencyCallLabel = (TextView)mStatusBarWindow.findViewById(
+                                                       R.id.emergency_calls_only);
+                if (mEmergencyCallLabel != null) {
+                    mNetworkController.addEmergencyLabelView(mEmergencyCallLabel);
+                    mEmergencyCallLabel.setOnClickListener(new View.OnClickListener() {
+                        public void onClick(View v) { }});
+                    mEmergencyCallLabel.addOnLayoutChangeListener(
+                                                    new View.OnLayoutChangeListener() {
+                        @Override
+                        public void onLayoutChange(View v, int left, int top, int right, int bottom,
+                            int oldLeft, int oldTop, int oldRight, int oldBottom) {
+                            updateCarrierLabelVisibility(false);
+                        }});
+                }
             }
 
-            // set up the dynamic hide/show of the label
-            mPile.setOnSizeChangedListener(new OnSizeChangedListener() {
-                @Override
-                public void onSizeChanged(View view, int w, int h, int oldw, int oldh) {
-                    updateCarrierLabelVisibility(false);
+            mCarrierLabel = (TextView)mStatusBarWindow.findViewById(R.id.carrier_label);
+            mShowCarrierInPanel = (mCarrierLabel != null);
+            if (DEBUG) Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" +
+                                                                  mShowCarrierInPanel);
+            if (mShowCarrierInPanel) {
+                mCarrierLabel.setVisibility(mCarrierLabelVisible ? View.VISIBLE : View.INVISIBLE);
+
+                // for mobile devices, we always show mobile connection info here (SPN/PLMN)
+                // for other devices, we show whatever network is connected
+                if (mNetworkController.hasMobileDataFeature()) {
+                    mNetworkController.addMobileLabelView(mCarrierLabel);
+                } else {
+                    mNetworkController.addCombinedLabelView(mCarrierLabel);
                 }
-            });
+
+                // set up the dynamic hide/show of the label
+                mPile.setOnSizeChangedListener(new OnSizeChangedListener() {
+                    @Override
+                    public void onSizeChanged(View view, int w, int h, int oldw, int oldh) {
+                        updateCarrierLabelVisibility(false);
+                    }
+                });
+            }
         }
 
         // Quick Settings (where available, some restrictions apply)
@@ -1316,8 +1399,12 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
         }
 
         final boolean emergencyCallsShownElsewhere = mEmergencyCallLabel != null;
+        final boolean isEmergencyOnly = MSimTelephonyManager.getDefault().isMultiSimEnabled() ?
+             mMSimNetworkController.isEmergencyOnly() :
+             mNetworkController.isEmergencyOnly();
+
         final boolean makeVisible =
-            !(emergencyCallsShownElsewhere && mNetworkController.isEmergencyOnly())
+            !(emergencyCallsShownElsewhere && isEmergencyOnly)
             && mPile.getHeight() < (mNotificationPanel.getHeight() - mCarrierLabelHeight - mNotificationHeaderHeight)
             && mScrollView.getVisibility() == View.VISIBLE
             && !mAnimatingFlip;
@@ -2655,7 +2742,13 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
             mGestureRec.dump(fd, pw, args);
         }
 
-        mNetworkController.dump(fd, pw, args);
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            for(int i=0; i < MSimTelephonyManager.getDefault().getPhoneCount(); i++) {
+                mMSimNetworkController.dump(fd, pw, args, i);
+            }
+        } else {
+            mNetworkController.dump(fd, pw, args);
+        }
     }
 
     private static void dumpBarTransitions(PrintWriter pw, String var, BarTransitions transitions) {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java
index 8957a77..6d39ea5 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -24,9 +26,11 @@ import android.content.Intent;
 import android.content.IntentFilter;
 import android.media.AudioManager;
 import android.os.Handler;
+import android.telephony.MSimTelephonyManager;
 import android.util.Log;
 
 import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.MSimConstants;
 import com.android.internal.telephony.TelephonyIntents;
 import com.android.internal.telephony.cdma.TtyIntent;
 import com.android.systemui.R;
@@ -58,7 +62,7 @@ public class PhoneStatusBarPolicy {
 
     // Assume it's all good unless we hear otherwise.  We don't always seem
     // to get broadcasts that it *is* there.
-    IccCardConstants.State mSimState = IccCardConstants.State.READY;
+    IccCardConstants.State[] mSimState;
 
     // ringer volume
     private boolean mVolumeVisible;
@@ -117,6 +121,12 @@ public class PhoneStatusBarPolicy {
         filter.addAction(TtyIntent.TTY_ENABLED_CHANGE_ACTION);
         mContext.registerReceiver(mIntentReceiver, filter, null, mHandler);
 
+        int numPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+        mSimState = new IccCardConstants.State[numPhones];
+        for (int i=0; i < numPhones; i++) {
+            mSimState[i] = IccCardConstants.State.READY;
+        }
+
         // TTY status
         mService.setIcon("tty",  R.drawable.stat_sys_tty_mode, 0, null);
         mService.setIconVisibility("tty", false);
@@ -164,28 +174,38 @@ public class PhoneStatusBarPolicy {
     }
 
     private final void updateSimState(Intent intent) {
+        IccCardConstants.State simState;
         String stateExtra = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+
+        // Obtain the subscription info from intent
+        int sub = intent.getIntExtra(MSimConstants.SUBSCRIPTION_KEY, 0);
+        Log.d(TAG, "updateSimState for subscription :" + sub);
+
         if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(stateExtra)) {
-            mSimState = IccCardConstants.State.ABSENT;
+            simState = IccCardConstants.State.ABSENT;
+        }
+        else if (IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR.equals(stateExtra)) {
+            simState = IccCardConstants.State.CARD_IO_ERROR;
         }
         else if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(stateExtra)) {
-            mSimState = IccCardConstants.State.READY;
+            simState = IccCardConstants.State.READY;
         }
         else if (IccCardConstants.INTENT_VALUE_ICC_LOCKED.equals(stateExtra)) {
             final String lockedReason =
                     intent.getStringExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON);
             if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN.equals(lockedReason)) {
-                mSimState = IccCardConstants.State.PIN_REQUIRED;
+                simState = IccCardConstants.State.PIN_REQUIRED;
             }
             else if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK.equals(lockedReason)) {
-                mSimState = IccCardConstants.State.PUK_REQUIRED;
+                simState = IccCardConstants.State.PUK_REQUIRED;
             }
             else {
-                mSimState = IccCardConstants.State.NETWORK_LOCKED;
+                simState = IccCardConstants.State.PERSO_LOCKED;
             }
         } else {
-            mSimState = IccCardConstants.State.UNKNOWN;
+            simState = IccCardConstants.State.UNKNOWN;
         }
+        mSimState[sub] = simState;
     }
 
     private final void updateVolume() {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java
index d039c14..7788f06 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java
@@ -20,6 +20,7 @@ import android.animation.Animator;
 import android.animation.AnimatorSet;
 import android.animation.ObjectAnimator;
 import android.content.res.Resources;
+import android.telephony.MSimTelephonyManager;
 import android.view.View;
 
 import com.android.systemui.R;
@@ -46,7 +47,11 @@ public final class PhoneStatusBarTransitions extends BarTransitions {
     public void init() {
         mLeftSide = mView.findViewById(R.id.notification_icon_area);
         mStatusIcons = mView.findViewById(R.id.statusIcons);
-        mSignalCluster = mView.findViewById(R.id.signal_cluster);
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            mSignalCluster = mView.findViewById(R.id.msim_signal_cluster);
+        } else {
+            mSignalCluster = mView.findViewById(R.id.signal_cluster);
+        }
         mBattery = mView.findViewById(R.id.battery);
         mDockBattery = mView.findViewById(R.id.dock_battery);
         mClock = mView.findViewById(R.id.clock);
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/MSimNetworkController.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/MSimNetworkController.java
new file mode 100644
index 0000000..17d6487
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/MSimNetworkController.java
@@ -0,0 +1,1270 @@
+/*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.policy;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.wifi.WifiManager;
+import android.net.wimax.WimaxManagerConstants;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.provider.Telephony;
+import android.telephony.MSimTelephonyManager;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Slog;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.android.internal.telephony.IccCard;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.MSimConstants;
+import com.android.internal.telephony.cdma.EriInfo;
+import com.android.internal.util.AsyncChannel;
+
+import com.android.systemui.R;
+
+public class MSimNetworkController extends NetworkController {
+    // debug
+    static final String TAG = "StatusBar.MSimNetworkController";
+    static final boolean DEBUG = true;
+    static final boolean CHATTY = true; // additional diagnostics, but not logspew
+
+    // telephony
+    private MSimTelephonyManager mPhone;
+    boolean[] mMSimDataConnected;
+    IccCardConstants.State[] mMSimState;
+    int[] mMSimDataActivity;
+    int[] mMSimDataServiceState;
+    ServiceState[] mMSimServiceState;
+    SignalStrength[] mMSimSignalStrength;
+    private PhoneStateListener[] mMSimPhoneStateListener;
+    private CharSequence[] mCarrierTextSub;
+
+    String[] mMSimNetworkName;
+    int[] mMSimPhoneSignalIconId;
+    int[] mMSimLastPhoneSignalIconId;
+    private int[] mMSimIconId;
+    int[] mMSimDataDirectionIconId; // data + data direction on phones
+    int[] mMSimDataSignalIconId;
+    int[] mMSimDataTypeIconId;
+    int[] mNoMSimIconId;
+    int[] mMSimMobileActivityIconId; // overlay arrows for data direction
+
+    String[] mMSimContentDescriptionPhoneSignal;
+    String[] mMSimContentDescriptionCombinedSignal;
+    String[] mMSimContentDescriptionDataType;
+
+    int[] mMSimLastDataDirectionIconId;
+    int[] mMSimLastCombinedSignalIconId;
+    int[] mMSimLastDataTypeIconId;
+    int[] mMSimcombinedSignalIconId;
+    int[] mMSimcombinedActivityIconId;
+    int[] mMSimLastSimIconId;
+    private int mDefaultSubscription;
+    boolean[] mShowSpn;
+    boolean[] mShowPlmn;
+    String[] mSpn;
+    String[] mPlmn;
+
+    ArrayList<MSimSignalCluster> mSimSignalClusters = new ArrayList<MSimSignalCluster>();
+    ArrayList<TextView> mSubsLabelViews = new ArrayList<TextView>();
+
+    public interface MSimSignalCluster {
+        void setWifiIndicators(boolean visible, int strengthIcon, String contentDescription);
+        void setMobileDataIndicators(boolean visible, int strengthIcon,
+                int typeIcon, String contentDescription, String typeContentDescription,
+                int noSimIcon, int subscription);
+        void setIsAirplaneMode(boolean is, int airplaneIcon);
+    }
+
+    /**
+     * Construct this controller object and register for updates.
+     */
+    public MSimNetworkController(Context context) {
+        super(context);
+
+        int numPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+        mMSimSignalStrength = new SignalStrength[numPhones];
+        mMSimDataServiceState = new int[numPhones];
+        mMSimServiceState = new ServiceState[numPhones];
+        mMSimState = new IccCardConstants.State[numPhones];
+        mMSimIconId = new int[numPhones];
+        mMSimPhoneSignalIconId = new int[numPhones];
+        mMSimDataTypeIconId = new int[numPhones];
+        mNoMSimIconId = new int[numPhones];
+        mMSimMobileActivityIconId = new int[numPhones];
+        mMSimContentDescriptionPhoneSignal = new String[numPhones];
+        mMSimLastPhoneSignalIconId = new int[numPhones];
+        mMSimNetworkName = new String[numPhones];
+        mMSimLastDataTypeIconId = new int[numPhones];
+        mMSimDataConnected = new boolean[numPhones];
+        mMSimDataSignalIconId = new int[numPhones];
+        mMSimDataDirectionIconId = new int[numPhones];
+        mMSimLastDataDirectionIconId = new int[numPhones];
+        mMSimLastCombinedSignalIconId = new int[numPhones];
+        mMSimcombinedSignalIconId = new int[numPhones];
+        mMSimcombinedActivityIconId = new int[numPhones];
+        mMSimDataActivity = new int[numPhones];
+        mMSimContentDescriptionCombinedSignal = new String[numPhones];
+        mMSimContentDescriptionDataType = new String[numPhones];
+        mMSimLastSimIconId = new int[numPhones];
+        mCarrierTextSub = new CharSequence[numPhones];
+        mShowSpn = new boolean[numPhones];
+        mShowPlmn = new boolean[numPhones];
+        mSpn = new String[numPhones];
+        mPlmn = new String[numPhones];
+
+        for (int i=0; i < numPhones; i++) {
+            mMSimSignalStrength[i] = new SignalStrength();
+            mMSimServiceState[i] = new ServiceState();
+            mMSimState[i] = IccCardConstants.State.READY;
+            // phone_signal
+            mMSimPhoneSignalIconId[i] = R.drawable.stat_sys_signal_null;
+            mMSimLastPhoneSignalIconId[i] = -1;
+            mMSimLastDataTypeIconId[i] = -1;
+            mMSimDataConnected[i] = false;
+            mMSimLastDataDirectionIconId[i] = -1;
+            mMSimLastCombinedSignalIconId[i] = -1;
+            mMSimcombinedSignalIconId[i] = 0;
+            mMSimcombinedActivityIconId[i] = 0;
+            mMSimDataActivity[i] = TelephonyManager.DATA_ACTIVITY_NONE;
+            mMSimLastSimIconId[i] = 0;
+            mMSimNetworkName[i] = mNetworkNameDefault;
+            mMSimDataServiceState[i] = ServiceState.STATE_OUT_OF_SERVICE;
+        }
+
+        mDefaultSubscription = MSimTelephonyManager.getDefault().getDefaultSubscription();
+        mDataConnected = mMSimDataConnected[mDefaultSubscription];
+        mSimState = mMSimState[mDefaultSubscription];
+        mDataActivity = mMSimDataActivity[mDefaultSubscription];
+        mDataServiceState = mMSimDataServiceState[mDefaultSubscription];
+        mServiceState = mMSimServiceState[mDefaultSubscription];
+        mSignalStrength = mMSimSignalStrength[mDefaultSubscription];
+        mPhoneStateListener = mMSimPhoneStateListener[mDefaultSubscription];
+
+        mNetworkName = mMSimNetworkName[mDefaultSubscription];
+        mPhoneSignalIconId = mMSimPhoneSignalIconId[mDefaultSubscription];
+        mLastPhoneSignalIconId = mMSimLastPhoneSignalIconId[mDefaultSubscription];
+        // data + data direction on phones
+        mDataDirectionIconId = mMSimDataDirectionIconId[mDefaultSubscription];
+        mDataSignalIconId = mMSimDataSignalIconId[mDefaultSubscription];
+        mDataTypeIconId = mMSimDataTypeIconId[mDefaultSubscription];
+        mNoSimIconId = mNoMSimIconId[mDefaultSubscription];
+
+        mContentDescriptionPhoneSignal = mMSimContentDescriptionPhoneSignal[mDefaultSubscription];
+        mContentDescriptionCombinedSignal = mMSimContentDescriptionCombinedSignal[
+                mDefaultSubscription];
+        mContentDescriptionDataType = mMSimContentDescriptionDataType[mDefaultSubscription];
+
+        mLastDataDirectionIconId = mMSimLastDataDirectionIconId[mDefaultSubscription];
+        mLastCombinedSignalIconId = mMSimLastCombinedSignalIconId[mDefaultSubscription];
+        mLastDataTypeIconId = mMSimLastDataTypeIconId[mDefaultSubscription];
+        mLastSimIconId = mMSimLastSimIconId[mDefaultSubscription];
+    }
+
+    @Override
+    protected void registerPhoneStateListener(Context context) {
+        // telephony
+        int numPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+        mPhone = (MSimTelephonyManager)context.getSystemService(Context.MSIM_TELEPHONY_SERVICE);
+        mMSimPhoneStateListener = new PhoneStateListener[numPhones];
+        for (int i=0; i < numPhones; i++) {
+            mMSimPhoneStateListener[i] = getPhoneStateListener(i);
+            mPhone.listen(mMSimPhoneStateListener[i],
+                              PhoneStateListener.LISTEN_SERVICE_STATE
+                            | PhoneStateListener.LISTEN_SIGNAL_STRENGTHS
+                            | PhoneStateListener.LISTEN_CALL_STATE
+                            | PhoneStateListener.LISTEN_DATA_CONNECTION_STATE
+                            | PhoneStateListener.LISTEN_DATA_ACTIVITY);
+        }
+    }
+
+    public void addSignalCluster(MSimSignalCluster cluster, int subscription) {
+        mSimSignalClusters.add(cluster);
+        refreshSignalCluster(cluster, subscription);
+    }
+
+    public void refreshSignalCluster(MSimSignalCluster cluster, int subscription) {
+        cluster.setWifiIndicators(
+                // only show wifi in the cluster if connected or if wifi-only
+                mWifiEnabled && (mWifiConnected || !mHasMobileDataFeature),
+                mWifiIconId,
+                mContentDescriptionWifi);
+        cluster.setMobileDataIndicators(
+                mHasMobileDataFeature,
+                mMSimPhoneSignalIconId[subscription],
+                mMSimDataTypeIconId[subscription],
+                mMSimContentDescriptionPhoneSignal[subscription],
+                mMSimContentDescriptionDataType[subscription],
+                mNoMSimIconId[subscription], subscription);
+        if (mIsWimaxEnabled && mWimaxConnected) {
+            // wimax is special
+            cluster.setMobileDataIndicators(
+                    true,
+                    mAlwaysShowCdmaRssi ? mPhoneSignalIconId : mWimaxIconId,
+                    mMSimDataTypeIconId[subscription],
+                    mContentDescriptionWimax,
+                    mMSimContentDescriptionDataType[subscription],
+                    mNoMSimIconId[subscription], subscription);
+        } else {
+            // normal mobile data
+            cluster.setMobileDataIndicators(
+                    mHasMobileDataFeature,
+                    mShowPhoneRSSIForData ? mMSimPhoneSignalIconId[subscription]
+                        : mMSimDataSignalIconId[subscription],
+                    mMSimDataTypeIconId[subscription],
+                    mMSimContentDescriptionPhoneSignal[subscription],
+                    mMSimContentDescriptionDataType[subscription],
+                    mNoMSimIconId[subscription], subscription);
+        }
+        cluster.setIsAirplaneMode(mAirplaneMode, mAirplaneIconId);
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        final String action = intent.getAction();
+        if (action.equals(WifiManager.RSSI_CHANGED_ACTION)
+                || action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)
+                || action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
+            updateWifiState(intent);
+            refreshViews(mDefaultSubscription);
+        } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+            updateSimState(intent);
+            for (int sub = 0; sub < MSimTelephonyManager.getDefault().getPhoneCount(); sub++) {
+                updateDataIcon(sub);
+                refreshViews(sub);
+            }
+        } else if (action.equals(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION)) {
+            final int subscription = intent.getIntExtra(MSimConstants.SUBSCRIPTION_KEY, 0);
+            Slog.d(TAG, "Received SPN update on sub :" + subscription);
+            mShowSpn[subscription] = intent.getBooleanExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
+            mSpn[subscription] = intent.getStringExtra(TelephonyIntents.EXTRA_SPN);
+            mShowPlmn[subscription] = intent.getBooleanExtra(
+                    TelephonyIntents.EXTRA_SHOW_PLMN, false);
+            mPlmn[subscription] = intent.getStringExtra(TelephonyIntents.EXTRA_PLMN);
+
+            updateNetworkName(mShowSpn[subscription], mSpn[subscription], mShowPlmn[subscription],
+                    mPlmn[subscription], subscription);
+            updateCarrierText(subscription);
+            refreshViews(subscription);
+        } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION) ||
+                 action.equals(ConnectivityManager.INET_CONDITION_ACTION)) {
+            updateConnectivity(intent);
+            refreshViews(mDefaultSubscription);
+        } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
+            refreshViews(mDefaultSubscription);
+        } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+            updateAirplaneMode();
+            for (int i = 0; i < MSimTelephonyManager.getDefault().getPhoneCount(); i++) {
+                updateSimIcon(i);
+                updateCarrierText(i);
+            }
+            refreshViews(mDefaultSubscription);
+        } else if (action.equals(WimaxManagerConstants.NET_4G_STATE_CHANGED_ACTION) ||
+                action.equals(WimaxManagerConstants.SIGNAL_LEVEL_CHANGED_ACTION) ||
+                action.equals(WimaxManagerConstants.WIMAX_NETWORK_STATE_CHANGED_ACTION)) {
+            updateWimaxState(intent);
+            refreshViews(mDefaultSubscription);
+        }
+    }
+
+    public void addSubsLabelView(TextView v) {
+        mSubsLabelViews.add(v);
+    }
+
+    private void updateCarrierText(int sub) {
+        int textResId = 0;
+        if (mAirplaneMode) {
+            textResId = com.android.internal.R.string.lockscreen_airplane_mode_on;
+        } else {
+            if (DEBUG) {
+                Slog.d(TAG, "updateCarrierText for sub:" + sub + " simState =" + mMSimState[sub]);
+            }
+
+            switch (mMSimState[sub]) {
+                case ABSENT:
+                case UNKNOWN:
+                case NOT_READY:
+                    textResId = com.android.internal.R.string.lockscreen_missing_sim_message_short;
+                    break;
+                case PIN_REQUIRED:
+                    textResId = com.android.internal.R.string.lockscreen_sim_locked_message;
+                    break;
+                case PUK_REQUIRED:
+                    textResId = com.android.internal.R.string.lockscreen_sim_puk_locked_message;
+                    break;
+                case READY:
+                    // If the state is ready, set the text as network name.
+                    mCarrierTextSub[sub] = mMSimNetworkName[sub];
+                    break;
+                case PERM_DISABLED:
+                    textResId = com.android.internal.
+                            R.string.lockscreen_permanent_disabled_sim_message_short;
+                    break;
+                case CARD_IO_ERROR:
+                    textResId = com.android.internal.R.string.lockscreen_sim_error_message_short;
+                    break;
+                default:
+                    textResId = com.android.internal.R.string.lockscreen_missing_sim_message_short;
+                    break;
+            }
+        }
+
+        if (textResId != 0) {
+            mCarrierTextSub[sub] = mContext.getString(textResId);
+        }
+    }
+
+    private void setCarrierText() {
+        String carrierName = mCarrierTextSub[MSimConstants.SUB1]
+                  + "    " + mCarrierTextSub[MSimConstants.SUB2];
+        for (int i = 0; i < mSubsLabelViews.size(); i++) {
+            TextView v = mSubsLabelViews.get(i);
+            v.setText(carrierName);
+        }
+    }
+
+
+    // ===== Telephony ==============================================================
+
+    private PhoneStateListener getPhoneStateListener(int subscription) {
+        PhoneStateListener mMSimPhoneStateListener = new PhoneStateListener(subscription) {
+            @Override
+            public void onSignalStrengthsChanged(SignalStrength signalStrength) {
+                if (DEBUG) {
+                    Slog.d(TAG, "onSignalStrengthsChanged received on subscription :"
+                        + mSubscription + "signalStrength=" + signalStrength +
+                        ((signalStrength == null) ? "" : (" level=" + signalStrength.getLevel())));
+                }
+                mMSimSignalStrength[mSubscription] = signalStrength;
+                updateTelephonySignalStrength(mSubscription);
+                refreshViews(mSubscription);
+            }
+
+            @Override
+            public void onServiceStateChanged(ServiceState state) {
+                if (DEBUG) {
+                    Slog.d(TAG, "onServiceStateChanged received on subscription :"
+                        + mSubscription + "state=" + state.getState());
+                }
+                mMSimServiceState[mSubscription] = state;
+                if (SystemProperties.getBoolean("ro.config.combined_signal", true)) {
+                    /*
+                     * if combined_signal is set to true only then consider data
+                     * service state for signal display
+                     */
+                    mMSimDataServiceState[mSubscription] =
+                        mMSimServiceState[mSubscription].getDataRegState();
+                    if (DEBUG) {
+                        Slog.d(TAG, "Combining data service state " +
+                                mMSimDataServiceState[mSubscription] + " for signal");
+                    }
+                }
+                updateTelephonySignalStrength(mSubscription);
+                updateDataNetType(mSubscription);
+                updateDataIcon(mSubscription);
+                updateNetworkName(mShowSpn[mSubscription], mSpn[mSubscription],
+                                mShowPlmn[mSubscription], mPlmn[mSubscription], mSubscription);
+                updateCarrierText(mSubscription);
+
+                refreshViews(mSubscription);
+            }
+
+            @Override
+            public void onCallStateChanged(int state, String incomingNumber) {
+                if (DEBUG) {
+                    Slog.d(TAG, "onCallStateChanged received on subscription :"
+                    + mSubscription + "state=" + state);
+                }
+                // In cdma, if a voice call is made, RSSI should switch to 1x.
+                if (isCdma(mSubscription)) {
+                    updateTelephonySignalStrength(mSubscription);
+                    refreshViews(mSubscription);
+                }
+            }
+
+            @Override
+            public void onDataConnectionStateChanged(int state, int networkType) {
+                if (DEBUG) {
+                    Slog.d(TAG, "onDataConnectionStateChanged received on subscription :"
+                    + mSubscription + "state=" + state + " type=" + networkType);
+                }
+
+                // DSDS case: Data is active only on DDS. Ignore the Data Connection
+                // State changed notifications of the other NON-DDS.
+                if (mSubscription ==
+                        MSimTelephonyManager.getDefault().getPreferredDataSubscription()) {
+                    mDataState = state;
+                    mDataNetType = networkType;
+                }
+                updateDataNetType(mSubscription);
+                updateDataIcon(mSubscription);
+                refreshViews(mSubscription);
+            }
+
+            @Override
+            public void onDataActivity(int direction) {
+                if (DEBUG) {
+                    Slog.d(TAG, "onDataActivity received on subscription :"
+                        + mSubscription + "direction=" + direction);
+                }
+                mMSimDataActivity[mSubscription] = direction;
+                updateDataIcon(mSubscription);
+                refreshViews(mSubscription);
+            }
+        };
+        return mMSimPhoneStateListener;
+    }
+
+    // ===== Wifi ===================================================================
+
+    class MSimWifiHandler extends WifiHandler {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case WifiManager.DATA_ACTIVITY_NOTIFICATION:
+                    if (msg.arg1 != mWifiActivity) {
+                        mWifiActivity = msg.arg1;
+                        refreshViews(MSimTelephonyManager.getDefault().
+                                getPreferredDataSubscription());
+                    }
+                    break;
+                default:
+                    super.handleMessage(msg);
+                    break;
+            }
+        }
+    }
+
+    @Override
+    protected void updateSimState(Intent intent) {
+        IccCardConstants.State simState;
+        String stateExtra = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+        // Obtain the subscription info from intent.
+        int sub = intent.getIntExtra(MSimConstants.SUBSCRIPTION_KEY, 0);
+        Slog.d(TAG, "updateSimState for subscription :" + sub);
+        if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(stateExtra)) {
+            simState = IccCardConstants.State.ABSENT;
+        }
+        else if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(stateExtra)) {
+            simState = IccCardConstants.State.READY;
+        }
+        else if (IccCardConstants.INTENT_VALUE_ICC_LOCKED.equals(stateExtra)) {
+            final String lockedReason = intent.getStringExtra(IccCardConstants.
+                                                            INTENT_KEY_LOCKED_REASON);
+            if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN.equals(lockedReason)) {
+                simState = IccCardConstants.State.PIN_REQUIRED;
+            }
+            else if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK.equals(lockedReason)) {
+                simState = IccCardConstants.State.PUK_REQUIRED;
+            }
+            else {
+                simState = IccCardConstants.State.PERSO_LOCKED;
+            }
+        } else {
+            simState = IccCardConstants.State.UNKNOWN;
+        }
+        // Update the sim state and carrier text.
+        if (simState != IccCardConstants.State.UNKNOWN && simState != mMSimState[sub]) {
+            mMSimState[sub] = simState;
+            updateCarrierText(sub);
+            Slog.d(TAG, "updateSimState simState =" + mMSimState[sub]);
+        }
+        updateSimIcon(sub);
+        updateDataIcon(sub);
+    }
+
+    private boolean isCdma(int subscription) {
+        return (mMSimSignalStrength[subscription] != null) &&
+                !mMSimSignalStrength[subscription].isGsm();
+    }
+
+    private boolean hasService(int subscription) {
+        ServiceState ss = mMSimServiceState[subscription];
+        if (ss != null) {
+            switch (ss.getState()) {
+                case ServiceState.STATE_OUT_OF_SERVICE:
+                case ServiceState.STATE_POWER_OFF:
+                    return false;
+                default:
+                    return true;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private final void updateTelephonySignalStrength(int subscription) {
+        Slog.d(TAG, "updateTelephonySignalStrength: subscription =" + subscription);
+        if (!hasService(subscription) &&
+                (mMSimDataServiceState[subscription] != ServiceState.STATE_IN_SERVICE)) {
+            if (DEBUG) Slog.d(TAG, " No service");
+            mMSimPhoneSignalIconId[subscription] = R.drawable.stat_sys_signal_null;
+            mMSimDataSignalIconId[subscription] = R.drawable.stat_sys_signal_null;
+        } else {
+            if (mMSimSignalStrength[subscription] == null || (mMSimServiceState == null)) {
+                if (DEBUG) {
+                    Slog.d(TAG, " Null object, mMSimSignalStrength= "
+                            + mMSimSignalStrength[subscription]
+                            + " mMSimServiceState " + mMSimServiceState[subscription]);
+                }
+                mMSimPhoneSignalIconId[subscription] = R.drawable.stat_sys_signal_null;
+                mMSimDataSignalIconId[subscription] = R.drawable.stat_sys_signal_null;
+                mMSimContentDescriptionPhoneSignal[subscription] = mContext.getString(
+                        AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0]);
+            } else {
+                int iconLevel;
+                int[] iconList;
+                if (isCdma(subscription) && mAlwaysShowCdmaRssi) {
+                    mLastSignalLevel = iconLevel = mMSimSignalStrength[subscription].getCdmaLevel();
+                    if(DEBUG) Slog.d(TAG, "mAlwaysShowCdmaRssi= " + mAlwaysShowCdmaRssi
+                            + " set to cdmaLevel= "
+                            + mMSimSignalStrength[subscription].getCdmaLevel()
+                            + " instead of level= " + mMSimSignalStrength[subscription].getLevel());
+                } else {
+                    mLastSignalLevel = iconLevel = mMSimSignalStrength[subscription].getLevel();
+                }
+
+                // Though mPhone is a Manager, this call is not an IPC
+                if ((isCdma(subscription) && isCdmaEri(subscription)) ||
+                        mPhone.isNetworkRoaming(subscription)) {
+                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
+                } else {
+                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
+                }
+
+                Slog.d(TAG, "updateTelephonySignalStrength iconList = " + iconList + "iconLevel = "
+                        + iconLevel + " mInetCondition = " + mInetCondition);
+                mMSimPhoneSignalIconId[subscription] = iconList[iconLevel];
+                mMSimContentDescriptionPhoneSignal[subscription] = mContext.getString(
+                        AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[iconLevel]);
+
+                mMSimDataSignalIconId[subscription] = TelephonyIcons
+                        .DATA_SIGNAL_STRENGTH[mInetCondition][iconLevel];
+            }
+        }
+    }
+
+    private final void updateDataNetType(int subscription) {
+        // DSDS case: Data is active only on DDS. Clear the icon for NON-DDS
+        int dataSub = MSimTelephonyManager.getDefault().getPreferredDataSubscription();
+        if (subscription != dataSub) {
+            Slog.d(TAG,"updateDataNetType: SUB" + subscription
+                    + " is not DDS(=SUB" + dataSub + ")!");
+            mMSimDataTypeIconId[subscription] = 0;
+        } else {
+            if (mIsWimaxEnabled && mWimaxConnected) {
+                // wimax is a special 4g network not handled by telephony
+                mDataIconList = TelephonyIcons.DATA_4G[mInetCondition];
+                mMSimDataTypeIconId[subscription] = R.drawable.stat_sys_data_fully_connected_4g;
+                mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                        R.string.accessibility_data_connection_4g);
+            } else {
+                Slog.d(TAG,"updateDataNetType sub = " + subscription
+                        + " mDataNetType = " + mDataNetType);
+                switch (mDataNetType) {
+                    case TelephonyManager.NETWORK_TYPE_UNKNOWN:
+                        if (DEBUG) {
+                            Slog.e(TAG, "updateDataNetType NETWORK_TYPE_UNKNOWN");
+                        }
+                        if (!mShowAtLeastThreeGees) {
+                            mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
+                            mMSimDataTypeIconId[subscription] = 0;
+                            mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                    R.string.accessibility_data_connection_gprs);
+                            break;
+                        } else {
+                            // fall through
+                        }
+                    case TelephonyManager.NETWORK_TYPE_EDGE:
+                        if (!mShowAtLeastThreeGees) {
+                            mDataIconList = TelephonyIcons.DATA_E[mInetCondition];
+                            mMSimDataTypeIconId[subscription] =
+                                    R.drawable.stat_sys_data_fully_connected_e;
+                            mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                    R.string.accessibility_data_connection_edge);
+                            break;
+                        } else {
+                            // fall through
+                        }
+                    case TelephonyManager.NETWORK_TYPE_UMTS:
+                    case TelephonyManager.NETWORK_TYPE_TD_SCDMA:
+                        mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
+                        mMSimDataTypeIconId[subscription] =
+                                R.drawable.stat_sys_data_fully_connected_3g;
+                        mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                R.string.accessibility_data_connection_3g);
+                        break;
+                    case TelephonyManager.NETWORK_TYPE_HSDPA:
+                    case TelephonyManager.NETWORK_TYPE_HSUPA:
+                    case TelephonyManager.NETWORK_TYPE_HSPA:
+                    case TelephonyManager.NETWORK_TYPE_HSPAP:
+                        if (mHspaDataDistinguishable) {
+                            mDataIconList = TelephonyIcons.DATA_H[mInetCondition];
+                            mMSimDataTypeIconId[subscription] =
+                                    R.drawable.stat_sys_data_fully_connected_h;
+                            mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                    R.string.accessibility_data_connection_3_5g);
+                        } else {
+                            mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
+                            mMSimDataTypeIconId[subscription] =
+                                    R.drawable.stat_sys_data_fully_connected_3g;
+                            mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                    R.string.accessibility_data_connection_3g);
+                        }
+                        break;
+                    case TelephonyManager.NETWORK_TYPE_CDMA:
+                        // display 1xRTT for IS95A/B
+                        mDataIconList = TelephonyIcons.DATA_1X[mInetCondition];
+                        mMSimDataTypeIconId[subscription] =
+                                R.drawable.stat_sys_data_fully_connected_1x;
+                        mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                R.string.accessibility_data_connection_cdma);
+                        break;
+                    case TelephonyManager.NETWORK_TYPE_1xRTT:
+                        mDataIconList = TelephonyIcons.DATA_1X[mInetCondition];
+                        mMSimDataTypeIconId[subscription] =
+                                R.drawable.stat_sys_data_fully_connected_1x;
+                        mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                R.string.accessibility_data_connection_cdma);
+                        break;
+                    case TelephonyManager.NETWORK_TYPE_EVDO_0: //fall through
+                    case TelephonyManager.NETWORK_TYPE_EVDO_A:
+                    case TelephonyManager.NETWORK_TYPE_EVDO_B:
+                    case TelephonyManager.NETWORK_TYPE_EHRPD:
+                        mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
+                        mMSimDataTypeIconId[subscription] =
+                                R.drawable.stat_sys_data_fully_connected_3g;
+                        mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                R.string.accessibility_data_connection_3g);
+                        break;
+                    case TelephonyManager.NETWORK_TYPE_LTE:
+                        mDataIconList = TelephonyIcons.DATA_4G[mInetCondition];
+                        mMSimDataTypeIconId[subscription] =
+                                R.drawable.stat_sys_data_fully_connected_4g;
+                        mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                R.string.accessibility_data_connection_4g);
+                        break;
+                    case TelephonyManager.NETWORK_TYPE_GPRS:
+                        if (!mShowAtLeastThreeGees) {
+                            mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
+                            mMSimDataTypeIconId[subscription] =
+                                    R.drawable.stat_sys_data_fully_connected_g;
+                            mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                    R.string.accessibility_data_connection_gprs);
+                        } else {
+                            mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
+                            mMSimDataTypeIconId[subscription] =
+                                R.drawable.stat_sys_data_fully_connected_3g;
+                            mMSimContentDescriptionDataType[subscription] = mContext.getString(
+                                    R.string.accessibility_data_connection_3g);
+                        }
+                        break;
+                    default:
+                        if (DEBUG) {
+                            Slog.e(TAG, "updateDataNetType unknown radio:" + mDataNetType);
+                        }
+                        mDataNetType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
+                        mMSimDataTypeIconId[subscription] = 0;
+                        break;
+                }
+            }
+        }
+
+        if (isCdma(subscription)) {
+            if (isCdmaEri(subscription)) {
+                mMSimDataTypeIconId[subscription] = R.drawable.stat_sys_data_fully_connected_roam;
+            }
+        } else if (mPhone.isNetworkRoaming(subscription)) {
+            mMSimDataTypeIconId[subscription] = R.drawable.stat_sys_data_fully_connected_roam;
+        }
+    }
+
+    boolean isCdmaEri(int subscription) {
+        if ((mMSimServiceState[subscription] != null)
+                && (hasService(subscription) || (mMSimDataServiceState[subscription]
+                == ServiceState.STATE_IN_SERVICE))) {
+            final int iconIndex = mMSimServiceState[subscription].getCdmaEriIconIndex();
+            if (iconIndex != EriInfo.ROAMING_INDICATOR_OFF) {
+                final int iconMode = mMSimServiceState[subscription].getCdmaEriIconMode();
+                if (iconMode == EriInfo.ROAMING_ICON_MODE_NORMAL
+                        || iconMode == EriInfo.ROAMING_ICON_MODE_FLASH) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private final void updateSimIcon(int cardIndex) {
+        Slog.d(TAG,"In updateSimIcon card =" + cardIndex + ", simState= " + mMSimState[cardIndex]);
+        if (mMSimState[cardIndex] ==  IccCardConstants.State.ABSENT) {
+            mNoMSimIconId[cardIndex] = R.drawable.stat_sys_no_sim;
+        } else {
+            mNoMSimIconId[cardIndex] = 0;
+        }
+        refreshViews(cardIndex);
+    }
+
+    private final void updateDataIcon(int subscription) {
+        Slog.d(TAG,"updateDataIcon subscription =" + subscription);
+        int iconId = 0;
+        boolean visible = true;
+
+        int dataSub = MSimTelephonyManager.getDefault().getPreferredDataSubscription();
+        Slog.d(TAG,"updateDataIcon dataSub =" + dataSub);
+        // DSDS case: Data is active only on DDS. Clear the icon for NON-DDS
+        if (subscription != dataSub) {
+            mMSimDataConnected[subscription] = false;
+            Slog.d(TAG,"updateDataIconi: SUB" + subscription
+                     + " is not DDS.  Clear the mMSimDataConnected Flag and return");
+            return;
+        }
+
+        Slog.d(TAG,"updateDataIcon  when SimState =" + mMSimState[subscription]);
+        if (mDataNetType == TelephonyManager.NETWORK_TYPE_UNKNOWN) {
+            // If data network type is unknown do not display data icon
+            visible = false;
+        } else if (!isCdma(subscription)) {
+             Slog.d(TAG,"updateDataIcon  when gsm mMSimState =" + mMSimState[subscription]);
+            // GSM case, we have to check also the sim state
+            if (mMSimState[subscription] == IccCardConstants.State.READY ||
+                mMSimState[subscription] == IccCardConstants.State.UNKNOWN) {
+                if (mDataState == TelephonyManager.DATA_CONNECTED) {
+                    switch (mMSimDataActivity[subscription]) {
+                        case TelephonyManager.DATA_ACTIVITY_IN:
+                            iconId = mDataIconList[1];
+                            break;
+                        case TelephonyManager.DATA_ACTIVITY_OUT:
+                            iconId = mDataIconList[2];
+                            break;
+                        case TelephonyManager.DATA_ACTIVITY_INOUT:
+                            iconId = mDataIconList[3];
+                            break;
+                        default:
+                            iconId = mDataIconList[0];
+                            break;
+                    }
+                    mMSimDataDirectionIconId[subscription] = iconId;
+                } else {
+                    iconId = 0;
+                    visible = false;
+                }
+            } else {
+                Slog.d(TAG,"updateDataIcon when no sim");
+                iconId = R.drawable.stat_sys_no_sim;
+                visible = false; // no SIM? no data
+            }
+        } else {
+            // CDMA case, mMSimDataActivity can be also DATA_ACTIVITY_DORMANT
+            if (mDataState == TelephonyManager.DATA_CONNECTED) {
+                switch (mMSimDataActivity[subscription]) {
+                    case TelephonyManager.DATA_ACTIVITY_IN:
+                        iconId = mDataIconList[1];
+                        break;
+                    case TelephonyManager.DATA_ACTIVITY_OUT:
+                        iconId = mDataIconList[2];
+                        break;
+                    case TelephonyManager.DATA_ACTIVITY_INOUT:
+                        iconId = mDataIconList[3];
+                        break;
+                    case TelephonyManager.DATA_ACTIVITY_DORMANT:
+                    default:
+                        iconId = mDataIconList[0];
+                        break;
+                }
+            } else {
+                iconId = 0;
+                visible = false;
+            }
+        }
+
+
+        mMSimDataDirectionIconId[subscription] = iconId;
+        mMSimDataConnected[subscription] = visible;
+        Slog.d(TAG,"updateDataIcon when mMSimDataConnected =" + mMSimDataConnected[subscription]);
+    }
+
+    void updateNetworkName(boolean showSpn, String spn, boolean showPlmn, String plmn,
+            int subscription) {
+        if (DEBUG) {
+            Slog.d(TAG, "updateNetworkName showSpn=" + showSpn + " spn=" + spn
+                    + " showPlmn=" + showPlmn + " plmn=" + plmn);
+        }
+        StringBuilder str = new StringBuilder();
+        boolean something = false;
+        if (showPlmn && plmn != null) {
+            str.append(plmn);
+            something = true;
+        }
+        if (showSpn && spn != null) {
+            if (something) {
+                str.append(mNetworkNameSeparator);
+            }
+            str.append(spn);
+            something = true;
+        }
+        if (something) {
+            mMSimNetworkName[subscription] = str.toString();
+        } else {
+            mMSimNetworkName[subscription] = mNetworkNameDefault;
+        }
+        Slog.d(TAG, "mMSimNetworkName[subscription] " + mMSimNetworkName[subscription]
+                                                      + "subscription " + subscription);
+    }
+
+    // ===== Full or limited Internet connectivity ==================================
+    @Override
+    protected void updateConnectivity(Intent intent) {
+        if (CHATTY) {
+            Slog.d(TAG, "updateConnectivity: intent=" + intent);
+        }
+
+        final ConnectivityManager connManager = (ConnectivityManager) mContext
+                .getSystemService(Context.CONNECTIVITY_SERVICE);
+        final NetworkInfo info = connManager.getActiveNetworkInfo();
+
+        // Are we connected at all, by any interface?
+        mConnected = info != null && info.isConnected();
+        if (mConnected) {
+            mConnectedNetworkType = info.getType();
+            mConnectedNetworkTypeName = info.getTypeName();
+        } else {
+            mConnectedNetworkType = ConnectivityManager.TYPE_NONE;
+            mConnectedNetworkTypeName = null;
+        }
+
+        int connectionStatus = intent.getIntExtra(ConnectivityManager.EXTRA_INET_CONDITION, 0);
+
+        if (CHATTY) {
+            Slog.d(TAG, "updateConnectivity: networkInfo=" + info);
+            Slog.d(TAG, "updateConnectivity: connectionStatus=" + connectionStatus);
+        }
+
+        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);
+        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {
+            mBluetoothTethered = info.isConnected();
+        } else {
+            mBluetoothTethered = false;
+        }
+
+        // We want to update all the icons, all at once, for any condition change
+        updateWimaxIcons();
+        for (int sub = 0; sub < MSimTelephonyManager.getDefault().getPhoneCount(); sub++) {
+            updateDataNetType(sub);
+            updateDataIcon(sub);
+            updateTelephonySignalStrength(sub);
+        }
+        updateWifiIcons();
+    }
+
+    // ===== Update the views =======================================================
+
+    protected void refreshViews(int subscription) {
+        Context context = mContext;
+
+        String combinedLabel = "";
+        String mobileLabel = "";
+        String wifiLabel = "";
+        int N;
+        Slog.d(TAG,"refreshViews subscription =" + subscription + "mMSimDataConnected ="
+                + mMSimDataConnected[subscription]);
+        Slog.d(TAG,"refreshViews mMSimDataActivity =" + mMSimDataActivity[subscription]);
+        if (!mHasMobileDataFeature) {
+            mMSimDataSignalIconId[subscription] = mMSimPhoneSignalIconId[subscription] = 0;
+            mobileLabel = "";
+        } else {
+            // We want to show the carrier name if in service and either:
+            //   - We are connected to mobile data, or
+            //   - We are not connected to mobile data, as long as the *reason* packets are not
+            //     being routed over that link is that we have better connectivity via wifi.
+            // If data is disconnected for some other reason but wifi (or ethernet/bluetooth)
+            // is connected, we show nothing.
+            // Otherwise (nothing connected) we show "No internet connection".
+
+            if (mMSimDataConnected[subscription]) {
+                mobileLabel = mMSimNetworkName[subscription];
+            } else if (mConnected) {
+                if (hasService(subscription)) {
+                    mobileLabel = mMSimNetworkName[subscription];
+                } else {
+                    mobileLabel = "";
+                }
+            } else {
+                mobileLabel
+                    = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
+            }
+
+            // Now for things that should only be shown when actually using mobile data.
+            if (mMSimDataConnected[subscription]) {
+                mMSimcombinedSignalIconId[subscription] = mMSimDataSignalIconId[subscription];
+
+                combinedLabel = mobileLabel;
+                mMSimcombinedActivityIconId[subscription] = mMSimMobileActivityIconId[subscription];
+                // set by updateDataIcon()
+                mMSimcombinedSignalIconId[subscription] = mMSimDataSignalIconId[subscription];
+                mMSimContentDescriptionCombinedSignal[subscription] =
+                        mMSimContentDescriptionDataType[subscription];
+            } else {
+                mMSimMobileActivityIconId[subscription] = 0;
+            }
+        }
+
+        if (mWifiConnected) {
+            if (mWifiSsid == null) {
+                wifiLabel = context.getString(
+                        R.string.status_bar_settings_signal_meter_wifi_nossid);
+            } else {
+                wifiLabel = mWifiSsid;
+                if (DEBUG) {
+                    wifiLabel += "xxxxXXXXxxxxXXXX";
+                }
+            }
+            combinedLabel = wifiLabel;
+            mMSimcombinedSignalIconId[subscription] = mWifiIconId; // set by updateWifiIcons()
+            mMSimContentDescriptionCombinedSignal[subscription] = mContentDescriptionWifi;
+        } else {
+            if (mHasMobileDataFeature) {
+                wifiLabel = "";
+            } else {
+                wifiLabel = context.getString(
+                        R.string.status_bar_settings_signal_meter_disconnected);
+            }
+        }
+
+        if (mBluetoothTethered) {
+            combinedLabel = mContext.getString(R.string.bluetooth_tethered);
+            mMSimcombinedSignalIconId[subscription] = mBluetoothTetherIconId;
+            mMSimContentDescriptionCombinedSignal[subscription] = mContext.getString(
+                    R.string.accessibility_bluetooth_tether);
+        }
+
+        final boolean ethernetConnected = (mConnectedNetworkType ==
+                ConnectivityManager.TYPE_ETHERNET);
+        if (ethernetConnected) {
+            // TODO: icons and strings for Ethernet connectivity
+            combinedLabel = mConnectedNetworkTypeName;
+        }
+
+        if (mAirplaneMode &&
+                (mMSimServiceState[subscription] == null || (!hasService(subscription)
+                    && !mMSimServiceState[subscription].isEmergencyOnly()))) {
+            // Only display the flight-mode icon if not in "emergency calls only" mode.
+
+            // look again; your radios are now airplanes
+            mMSimContentDescriptionPhoneSignal[subscription] = mContext.getString(
+                    R.string.accessibility_airplane_mode);
+            mAirplaneIconId = R.drawable.stat_sys_signal_flightmode;
+            mMSimPhoneSignalIconId[subscription] = mMSimDataSignalIconId[subscription]
+                    = mMSimDataTypeIconId[subscription] = 0;
+            mNoMSimIconId[subscription] = 0;
+
+            // combined values from connected wifi take precedence over airplane mode
+            if (mWifiConnected) {
+                // Suppress "No internet connection." from mobile if wifi connected.
+                mobileLabel = "";
+            } else {
+                if (mHasMobileDataFeature) {
+                    // let the mobile icon show "No internet connection."
+                    wifiLabel = "";
+                } else {
+                    wifiLabel = context.getString(
+                            R.string.status_bar_settings_signal_meter_disconnected);
+                    combinedLabel = wifiLabel;
+                }
+                mMSimContentDescriptionCombinedSignal[subscription] =
+                        mContentDescriptionPhoneSignal;
+                mMSimcombinedSignalIconId[subscription] = mMSimDataSignalIconId[subscription];
+            }
+            mMSimDataTypeIconId[subscription] = 0;
+            mNoMSimIconId[subscription] = 0;
+
+            mMSimcombinedSignalIconId[subscription] = mMSimDataSignalIconId[subscription];
+        }
+        else if (!mMSimDataConnected[subscription] && !mWifiConnected && !mBluetoothTethered &&
+                !mWimaxConnected && !ethernetConnected) {
+            // pretty much totally disconnected
+
+            combinedLabel = context.getString(
+                    R.string.status_bar_settings_signal_meter_disconnected);
+            // On devices without mobile radios, we want to show the wifi icon
+            mMSimcombinedSignalIconId[subscription] =
+                    mHasMobileDataFeature ? mMSimDataSignalIconId[subscription] : mWifiIconId;
+            mMSimContentDescriptionCombinedSignal[subscription] = mHasMobileDataFeature
+                    ? mMSimContentDescriptionDataType[subscription] : mContentDescriptionWifi;
+
+            mMSimDataTypeIconId[subscription] = 0;
+            if (isCdma(subscription)) {
+                if (isCdmaEri(subscription)) {
+                    mMSimDataTypeIconId[subscription] =
+                            R.drawable.stat_sys_data_fully_connected_roam;
+                }
+            } else if (mPhone.isNetworkRoaming(subscription)) {
+                mMSimDataTypeIconId[subscription] = R.drawable.stat_sys_data_fully_connected_roam;
+            }
+        }
+        if (DEBUG) {
+            Slog.d(TAG, "refreshViews connected={"
+                    + (mWifiConnected?" wifi":"")
+                    + (mMSimDataConnected[subscription]?" data":"")
+                    + " } level="
+                    + ((mMSimSignalStrength[subscription] == null)?"??":Integer.toString
+                            (mMSimSignalStrength[subscription].getLevel()))
+                    + " mMSimcombinedSignalIconId=0x"
+                    + Integer.toHexString(mMSimcombinedSignalIconId[subscription])
+                    + "/" + getResourceName(mMSimcombinedSignalIconId[subscription])
+                    + " mMSimcombinedActivityIconId=0x" + Integer.toHexString
+                            (mMSimcombinedActivityIconId[subscription])
+                    + " mAirplaneMode=" + mAirplaneMode
+                    + " mMSimDataActivity=" + mMSimDataActivity[subscription]
+                    + " mMSimPhoneSignalIconId=0x" + Integer.toHexString
+                            (mMSimPhoneSignalIconId[subscription])
+                    + " mMSimDataDirectionIconId=0x" + Integer.toHexString
+                            (mMSimDataDirectionIconId[subscription])
+                    + " mMSimDataSignalIconId=0x" + Integer.toHexString
+                            (mMSimDataSignalIconId[subscription])
+                    + " mMSimDataTypeIconId=0x" + Integer.toHexString
+                            (mMSimDataTypeIconId[subscription])
+                    + " mNoMSimIconId=0x" + Integer.toHexString(mNoMSimIconId[subscription])
+                    + " mWifiIconId=0x" + Integer.toHexString(mWifiIconId)
+                    + " mBluetoothTetherIconId=0x" + Integer.toHexString(mBluetoothTetherIconId));
+        }
+
+        if (mMSimLastPhoneSignalIconId[subscription] != mMSimPhoneSignalIconId[subscription]
+         || mLastWifiIconId                 != mWifiIconId
+         || mLastWimaxIconId                != mWimaxIconId
+         || mMSimLastDataTypeIconId[subscription] != mMSimDataTypeIconId[subscription]
+         || mLastAirplaneMode               != mAirplaneMode
+         || mMSimLastSimIconId[subscription] != mNoMSimIconId[subscription])
+        {
+            // NB: the mLast*s will be updated later
+            for (MSimSignalCluster cluster : mSimSignalClusters) {
+                refreshSignalCluster(cluster, subscription);
+            }
+            for (NetworkSignalChangedCallback cb : mSignalsChangedCallbacks) {
+                notifySignalsChangedCallbacks(cb);
+            }
+        }
+
+        if (mLastAirplaneMode != mAirplaneMode) {
+            mLastAirplaneMode = mAirplaneMode;
+        }
+
+        // the phone icon on phones
+        if (mMSimLastPhoneSignalIconId[subscription] != mMSimPhoneSignalIconId[subscription]) {
+            mMSimLastPhoneSignalIconId[subscription] = mMSimPhoneSignalIconId[subscription];
+        }
+
+        // the data icon on phones
+        if (mMSimLastDataDirectionIconId[subscription] != mMSimDataDirectionIconId[subscription]) {
+            mMSimLastDataDirectionIconId[subscription] = mMSimDataDirectionIconId[subscription];
+        }
+
+        if (mMSimLastSimIconId[subscription] != mNoMSimIconId[subscription]) {
+            mMSimLastSimIconId[subscription] = mNoMSimIconId[subscription];
+        }
+
+        // the wifi icon on phones
+        if (mLastWifiIconId != mWifiIconId) {
+            mLastWifiIconId = mWifiIconId;
+        }
+
+        // the wimax icon on phones
+        if (mLastWimaxIconId != mWimaxIconId) {
+            mLastWimaxIconId = mWimaxIconId;
+        }
+        // the combined data signal icon
+        if (mMSimLastCombinedSignalIconId[subscription] !=
+                mMSimcombinedSignalIconId[subscription]) {
+            mMSimLastCombinedSignalIconId[subscription] = mMSimcombinedSignalIconId[subscription];
+        }
+
+        // the data network type overlay
+        if (mMSimLastDataTypeIconId[subscription] != mMSimDataTypeIconId[subscription]) {
+            mMSimLastDataTypeIconId[subscription] = mMSimDataTypeIconId[subscription];
+        }
+
+      // the combinedLabel in the notification panel
+        if (!mLastCombinedLabel.equals(combinedLabel)) {
+            mLastCombinedLabel = combinedLabel;
+            N = mCombinedLabelViews.size();
+            for (int i=0; i<N; i++) {
+                TextView v = mCombinedLabelViews.get(i);
+                v.setText(combinedLabel);
+            }
+        }
+
+        // wifi label
+        N = mWifiLabelViews.size();
+        for (int i=0; i<N; i++) {
+            TextView v = mWifiLabelViews.get(i);
+            v.setText(wifiLabel);
+            if ("".equals(wifiLabel)) {
+                v.setVisibility(View.GONE);
+            } else {
+                v.setVisibility(View.VISIBLE);
+            }
+        }
+
+        // mobile label
+        setCarrierText();
+        N = mMobileLabelViews.size();
+        for (int i=0; i<N; i++) {
+            TextView v = mMobileLabelViews.get(i);
+            v.setText(mobileLabel);
+            if ("".equals(mobileLabel)) {
+                v.setVisibility(View.GONE);
+            } else {
+                v.setVisibility(View.VISIBLE);
+            }
+        }
+    }
+
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args, int subscription) {
+        pw.println("NetworkController for SUB : " + subscription + " state:");
+        pw.println(String.format("  %s network type %d (%s)",
+                mConnected?"CONNECTED":"DISCONNECTED",
+                mConnectedNetworkType, mConnectedNetworkTypeName));
+        pw.println("  - telephony ------");
+        pw.print("  hasService()=");
+        pw.println(hasService(subscription));
+        pw.print("  mHspaDataDistinguishable=");
+        pw.println(mHspaDataDistinguishable);
+        pw.print("  mMSimDataConnected=");
+        pw.println(mMSimDataConnected[subscription]);
+        pw.print("  mMSimState=");
+        pw.println(mMSimState[subscription]);
+        pw.print("  mPhoneState=");
+        pw.println(mPhoneState);
+        pw.print("  mDataState=");
+        pw.println(mDataState);
+        pw.print("  mMSimDataActivity=");
+        pw.println(mMSimDataActivity[subscription]);
+        pw.print("  mDataNetType=");
+        pw.print(mDataNetType);
+        pw.print("/");
+        pw.println(TelephonyManager.getNetworkTypeName(mDataNetType));
+        pw.print("  mMSimServiceState=");
+        pw.println(mMSimServiceState[subscription]);
+        pw.print("  mMSimSignalStrength=");
+        pw.println(mMSimSignalStrength[subscription]);
+        pw.print("  mLastSignalLevel");
+        pw.println(mLastSignalLevel);
+        pw.print("  mMSimNetworkName=");
+        pw.println(mMSimNetworkName[subscription]);
+        pw.print("  mNetworkNameDefault=");
+        pw.println(mNetworkNameDefault);
+        pw.print("  mNetworkNameSeparator=");
+        pw.println(mNetworkNameSeparator.replace("\n","\\n"));
+        pw.print("  mMSimPhoneSignalIconId=0x");
+        pw.print(Integer.toHexString(mMSimPhoneSignalIconId[subscription]));
+        pw.print("/");
+        pw.println(getResourceName(mMSimPhoneSignalIconId[subscription]));
+        pw.print("  mMSimDataDirectionIconId=");
+        pw.print(Integer.toHexString(mMSimDataDirectionIconId[subscription]));
+        pw.print("/");
+        pw.println(getResourceName(mMSimDataDirectionIconId[subscription]));
+        pw.print("  mMSimDataSignalIconId=");
+        pw.print(Integer.toHexString(mMSimDataSignalIconId[subscription]));
+        pw.print("/");
+        pw.println(getResourceName(mMSimDataSignalIconId[subscription]));
+        pw.print("  mMSimDataTypeIconId=");
+        pw.print(Integer.toHexString(mMSimDataTypeIconId[subscription]));
+        pw.print("/");
+        pw.println(getResourceName(mMSimDataTypeIconId[subscription]));
+
+        pw.println("  - wifi ------");
+        pw.print("  mWifiEnabled=");
+        pw.println(mWifiEnabled);
+        pw.print("  mWifiConnected=");
+        pw.println(mWifiConnected);
+        pw.print("  mWifiRssi=");
+        pw.println(mWifiRssi);
+        pw.print("  mWifiLevel=");
+        pw.println(mWifiLevel);
+        pw.print("  mWifiSsid=");
+        pw.println(mWifiSsid);
+        pw.println(String.format("  mWifiIconId=0x%08x/%s",
+                    mWifiIconId, getResourceName(mWifiIconId)));
+        pw.print("  mWifiActivity=");
+        pw.println(mWifiActivity);
+
+        if (mWimaxSupported) {
+            pw.println("  - wimax ------");
+            pw.print("  mIsWimaxEnabled="); pw.println(mIsWimaxEnabled);
+            pw.print("  mWimaxConnected="); pw.println(mWimaxConnected);
+            pw.print("  mWimaxIdle="); pw.println(mWimaxIdle);
+            pw.println(String.format("  mWimaxIconId=0x%08x/%s",
+                        mWimaxIconId, getResourceName(mWimaxIconId)));
+            pw.println(String.format("  mWimaxSignal=%d", mWimaxSignal));
+            pw.println(String.format("  mWimaxState=%d", mWimaxState));
+            pw.println(String.format("  mWimaxExtraState=%d", mWimaxExtraState));
+        }
+
+        pw.println("  - Bluetooth ----");
+        pw.print("  mBtReverseTethered=");
+        pw.println(mBluetoothTethered);
+
+        pw.println("  - connectivity ------");
+        pw.print("  mInetCondition=");
+        pw.println(mInetCondition);
+
+        pw.println("  - icons ------");
+        pw.print("  mMSimLastPhoneSignalIconId=0x");
+        pw.print(Integer.toHexString(mMSimLastPhoneSignalIconId[subscription]));
+        pw.print("/");
+        pw.println(getResourceName(mMSimLastPhoneSignalIconId[subscription]));
+        pw.print("  mMSimLastDataDirectionIconId=0x");
+        pw.print(Integer.toHexString(mMSimLastDataDirectionIconId[subscription]));
+        pw.print("/");
+        pw.println(getResourceName(mMSimLastDataDirectionIconId[subscription]));
+        pw.print("  mLastWifiIconId=0x");
+        pw.print(Integer.toHexString(mLastWifiIconId));
+        pw.print("/");
+        pw.println(getResourceName(mLastWifiIconId));
+        pw.print("  mMSimLastCombinedSignalIconId=0x");
+        pw.print(Integer.toHexString(mMSimLastCombinedSignalIconId[subscription]));
+        pw.print("/");
+        pw.println(getResourceName(mMSimLastCombinedSignalIconId[subscription]));
+        pw.print("  mMSimLastDataTypeIconId=0x");
+        pw.print(Integer.toHexString(mMSimLastDataTypeIconId[subscription]));
+        pw.print("/");
+        pw.println(getResourceName(mMSimLastDataTypeIconId[subscription]));
+        pw.print("  mMSimLastCombinedLabel=");
+        pw.print(mLastCombinedLabel);
+        pw.println("");
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
index a734f49..bd724ff 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2010 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -58,13 +60,13 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
     // debug
     static final String TAG = "StatusBar.NetworkController";
     static final boolean DEBUG = false;
-    static final boolean CHATTY = false; // additional diagnostics, but not logspew
+    static final boolean CHATTY = true; // additional diagnostics, but not logspew
 
     private static final int FLIGHT_MODE_ICON = R.drawable.stat_sys_signal_flightmode;
 
     // telephony
     boolean mHspaDataDistinguishable;
-    final TelephonyManager mPhone;
+    private TelephonyManager mPhone;
     boolean mDataConnected;
     IccCardConstants.State mSimState = IccCardConstants.State.READY;
     int mPhoneState = TelephonyManager.CALL_STATE_IDLE;
@@ -84,6 +86,8 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
     int mDataTypeIconId;
     int mQSDataTypeIconId;
     int mAirplaneIconId;
+    int mNoSimIconId;
+    int mLastSimIconId;
     boolean mDataActive;
     int mMobileActivityIconId; // overlay arrows for data direction
     int mLastSignalLevel;
@@ -98,8 +102,8 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
     String mContentDescriptionDataType;
 
     // wifi
-    final WifiManager mWifiManager;
-    AsyncChannel mWifiChannel;
+    protected WifiManager mWifiManager;
+    protected AsyncChannel mWifiChannel;
     boolean mWifiEnabled, mWifiConnected;
     int mWifiRssi, mWifiLevel;
     String mWifiSsid;
@@ -109,36 +113,37 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
     int mWifiActivity = WifiManager.DATA_ACTIVITY_NONE;
 
     // bluetooth
-    private boolean mBluetoothTethered = false;
-    private int mBluetoothTetherIconId =
+    protected boolean mBluetoothTethered = false;
+    protected int mBluetoothTetherIconId =
         com.android.internal.R.drawable.stat_sys_tether_bluetooth;
 
     //wimax
-    private boolean mWimaxSupported = false;
-    private boolean mIsWimaxEnabled = false;
-    private boolean mWimaxConnected = false;
-    private boolean mWimaxIdle = false;
-    private int mWimaxIconId = 0;
-    private int mWimaxSignal = 0;
-    private int mWimaxState = 0;
-    private int mWimaxExtraState = 0;
+    protected boolean mWimaxSupported = false;
+    protected boolean mIsWimaxEnabled = false;
+    protected boolean mWimaxConnected = false;
+    protected boolean mWimaxIdle = false;
+    protected int mWimaxIconId = 0;
+    protected int mWimaxSignal = 0;
+    protected int mWimaxState = 0;
+    protected int mWimaxExtraState = 0;
+    protected int mDataServiceState = ServiceState.STATE_OUT_OF_SERVICE;
 
     // data connectivity (regardless of state, can we access the internet?)
     // state of inet connection - 0 not connected, 100 connected
-    private boolean mConnected = false;
-    private int mConnectedNetworkType = ConnectivityManager.TYPE_NONE;
-    private String mConnectedNetworkTypeName;
-    private int mInetCondition = 0;
-    private static final int INET_CONDITION_THRESHOLD = 50;
+    protected boolean mConnected = false;
+    protected int mConnectedNetworkType = ConnectivityManager.TYPE_NONE;
+    protected String mConnectedNetworkTypeName;
+    protected int mInetCondition = 0;
+    protected static final int INET_CONDITION_THRESHOLD = 50;
 
-    private boolean mAirplaneMode = false;
-    private boolean mLastAirplaneMode = true;
+    protected boolean mAirplaneMode = false;
+    protected boolean mLastAirplaneMode = true;
 
     private Locale mLocale = null;
     private Locale mLastLocale = null;
 
     // our ui
-    Context mContext;
+    protected Context mContext;
     ArrayList<ImageView> mPhoneSignalIconViews = new ArrayList<ImageView>();
     ArrayList<ImageView> mDataDirectionIconViews = new ArrayList<ImageView>();
     ArrayList<ImageView> mDataDirectionOverlayIconViews = new ArrayList<ImageView>();
@@ -164,7 +169,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
     int mLastDataTypeIconId = -1;
     String mLastCombinedLabel = "";
 
-    private boolean mHasMobileDataFeature;
+    protected boolean mHasMobileDataFeature;
 
     boolean mDataAndWifiStacked = false;
 
@@ -174,7 +179,8 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         void setWifiIndicators(boolean visible, int strengthIcon, int activityIcon,
                 String contentDescription);
         void setMobileDataIndicators(boolean visible, int strengthIcon, int activityIcon,
-                int typeIcon, String contentDescription, String typeContentDescription);
+                int typeIcon, String contentDescription, String typeContentDescription,
+                int noSimIcon);
         void setIsAirplaneMode(boolean is, int airplaneIcon);
     }
 
@@ -214,13 +220,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         updateWimaxIcons();
 
         // telephony
-        mPhone = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
-        mPhone.listen(mPhoneStateListener,
-                          PhoneStateListener.LISTEN_SERVICE_STATE
-                        | PhoneStateListener.LISTEN_SIGNAL_STRENGTHS
-                        | PhoneStateListener.LISTEN_CALL_STATE
-                        | PhoneStateListener.LISTEN_DATA_CONNECTION_STATE
-                        | PhoneStateListener.LISTEN_DATA_ACTIVITY);
+        registerPhoneStateListener(context);
         mHspaDataDistinguishable = mContext.getResources().getBoolean(
                 R.bool.config_hspa_data_distinguishable);
         mNetworkNameSeparator = mContext.getString(R.string.status_bar_network_name_separator);
@@ -228,15 +228,6 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                 com.android.internal.R.string.lockscreen_carrier_default);
         mNetworkName = mNetworkNameDefault;
 
-        // wifi
-        mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
-        Handler handler = new WifiHandler();
-        mWifiChannel = new AsyncChannel();
-        Messenger wifiMessenger = mWifiManager.getWifiServiceMessenger();
-        if (wifiMessenger != null) {
-            mWifiChannel.connect(mContext, handler, wifiMessenger);
-        }
-
         // broadcasts
         IntentFilter filter = new IntentFilter();
         filter.addAction(WifiManager.RSSI_CHANGED_ACTION);
@@ -302,6 +293,17 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         mDataTypeIconViews.add(v);
     }
 
+    protected void registerPhoneStateListener(Context context) {
+        // telephony
+        mPhone = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
+        mPhone.listen(mPhoneStateListener,
+                          PhoneStateListener.LISTEN_SERVICE_STATE
+                        | PhoneStateListener.LISTEN_SIGNAL_STRENGTHS
+                        | PhoneStateListener.LISTEN_CALL_STATE
+                        | PhoneStateListener.LISTEN_DATA_CONNECTION_STATE
+                        | PhoneStateListener.LISTEN_DATA_ACTIVITY);
+    }
+
     public void addCombinedLabelView(TextView v) {
         mCombinedLabelViews.add(v);
     }
@@ -358,7 +360,8 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                     mMobileActivityIconId,
                     mDataTypeIconId,
                     mContentDescriptionWimax,
-                    mContentDescriptionDataType);
+                    mContentDescriptionDataType,
+                    mNoSimIconId);
         } else {
             // normal mobile data
             cluster.setMobileDataIndicators(
@@ -367,7 +370,8 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                     mMobileActivityIconId,
                     mDataTypeIconId,
                     mContentDescriptionPhoneSignal,
-                    mContentDescriptionDataType);
+                    mContentDescriptionDataType,
+                    mNoSimIconId);
         }
         cluster.setIsAirplaneMode(mAirplaneMode, mAirplaneIconId);
     }
@@ -447,6 +451,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
             refreshLocale();
             updateAirplaneMode();
+            updateSimIcon();
             refreshViews();
         } else if (action.equals(WimaxManagerConstants.NET_4G_STATE_CHANGED_ACTION) ||
                 action.equals(WimaxManagerConstants.SIGNAL_LEVEL_CHANGED_ACTION) ||
@@ -478,6 +483,17 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                         + " dataState=" + state.getDataRegState());
             }
             mServiceState = state;
+            if (mContext.getResources().getBoolean(
+                    com.android.internal.R.bool.config_combined_signal)) {
+                /*
+                 * if combined_signal is set to true only then consider data
+                 * service state for signal display
+                 */
+                mDataServiceState = mServiceState.getDataRegState();
+                if (DEBUG) {
+                    Log.d(TAG, "Combining data service state " + mDataServiceState + " for signal");
+                }
+            }
             updateTelephonySignalStrength();
             updateDataNetType();
             updateDataIcon();
@@ -520,11 +536,14 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         }
     };
 
-    private final void updateSimState(Intent intent) {
+    protected void updateSimState(Intent intent) {
         String stateExtra = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
         if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(stateExtra)) {
             mSimState = IccCardConstants.State.ABSENT;
         }
+        else if (IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR.equals(stateExtra)) {
+            mSimState = IccCardConstants.State.CARD_IO_ERROR;
+        }
         else if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(stateExtra)) {
             mSimState = IccCardConstants.State.READY;
         }
@@ -538,11 +557,12 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                 mSimState = IccCardConstants.State.PUK_REQUIRED;
             }
             else {
-                mSimState = IccCardConstants.State.NETWORK_LOCKED;
+                mSimState = IccCardConstants.State.PERSO_LOCKED;
             }
         } else {
             mSimState = IccCardConstants.State.UNKNOWN;
         }
+        updateSimIcon();
     }
 
     private boolean isCdma() {
@@ -569,7 +589,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         }
     }
 
-    private void updateAirplaneMode() {
+    protected void updateAirplaneMode() {
         mAirplaneMode = (Settings.Global.getInt(mContext.getContentResolver(),
             Settings.Global.AIRPLANE_MODE_ON, 0) == 1);
     }
@@ -579,14 +599,18 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
     }
 
     private final void updateTelephonySignalStrength() {
-        if (!hasService()) {
-            if (CHATTY) Log.d(TAG, "updateTelephonySignalStrength: !hasService()");
+        if (!hasService() &&
+                (mDataServiceState != ServiceState.STATE_IN_SERVICE)) {
+            if (DEBUG) Log.d(TAG, " No service");
             mPhoneSignalIconId = R.drawable.stat_sys_signal_null;
             mQSPhoneSignalIconId = R.drawable.ic_qs_signal_no_signal;
             mDataSignalIconId = R.drawable.stat_sys_signal_null;
         } else {
-            if (mSignalStrength == null) {
-                if (CHATTY) Log.d(TAG, "updateTelephonySignalStrength: mSignalStrength == null");
+            if ((mSignalStrength == null) || (mServiceState == null)) {
+                if (DEBUG) {
+                    Log.d(TAG, " Null object, mSignalStrength= " + mSignalStrength
+                            + " mServiceState " + mServiceState);
+                }
                 mPhoneSignalIconId = R.drawable.stat_sys_signal_null;
                 mQSPhoneSignalIconId = R.drawable.ic_qs_signal_no_signal;
                 mDataSignalIconId = R.drawable.stat_sys_signal_null;
@@ -604,20 +628,13 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                     mLastSignalLevel = iconLevel = mSignalStrength.getLevel();
                 }
 
-                if (isCdma()) {
-                    if (isCdmaEri()) {
-                        iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
-                    } else {
-                        iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
-                    }
+                // Though mPhone is a Manager, this call is not an IPC
+                if ((isCdma() && isCdmaEri()) || mPhone.isNetworkRoaming()) {
+                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
                 } else {
-                    // Though mPhone is a Manager, this call is not an IPC
-                    if (mPhone.isNetworkRoaming()) {
-                        iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
-                    } else {
-                        iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
-                    }
+                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
                 }
+
                 mPhoneSignalIconId = iconList[iconLevel];
                 mQSPhoneSignalIconId =
                         TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH[mInetCondition][iconLevel];
@@ -639,6 +656,9 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         } else {
             switch (mDataNetType) {
                 case TelephonyManager.NETWORK_TYPE_UNKNOWN:
+                    if (DEBUG) {
+                        Log.e(TAG, "updateDataNetType NETWORK_TYPE_UNKNOWN");
+                    }
                     if (!mShowAtLeastThreeGees) {
                         mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
                         mDataTypeIconId = 0;
@@ -661,6 +681,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                         // fall through
                     }
                 case TelephonyManager.NETWORK_TYPE_UMTS:
+                case TelephonyManager.NETWORK_TYPE_TD_SCDMA:
                     mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                     mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_3g;
                     mQSDataTypeIconId = TelephonyIcons.QS_DATA_3G[mInetCondition];
@@ -740,7 +761,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                                 R.string.accessibility_data_connection_lte);
                     }
                     break;
-                default:
+                case TelephonyManager.NETWORK_TYPE_GPRS:
                     if (!mShowAtLeastThreeGees) {
                         mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
                         mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_g;
@@ -755,6 +776,13 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                                 R.string.accessibility_data_connection_3g);
                     }
                     break;
+                default:
+                    if (DEBUG) {
+                        Log.e(TAG, "updateDataNetType unknown radio:" + mDataNetType);
+                    }
+                    mDataNetType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
+                    mDataTypeIconId = 0;
+                    break;
             }
         }
 
@@ -770,7 +798,8 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
     }
 
     boolean isCdmaEri() {
-        if (mServiceState != null) {
+        if ((mServiceState != null)
+                && (hasService() || (mDataServiceState == ServiceState.STATE_IN_SERVICE))) {
             final int iconIndex = mServiceState.getCdmaEriIconIndex();
             if (iconIndex != EriInfo.ROAMING_INDICATOR_OFF) {
                 final int iconMode = mServiceState.getCdmaEriIconMode();
@@ -783,15 +812,27 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         return false;
     }
 
+    private final void updateSimIcon() {
+        Log.d(TAG,"In updateSimIcon simState= " + mSimState);
+        if (mSimState ==  IccCardConstants.State.ABSENT) {
+            mNoSimIconId = R.drawable.stat_sys_no_sim;
+        } else {
+            mNoSimIconId = 0;
+        }
+        refreshViews();
+    }
+
     private final void updateDataIcon() {
-        int iconId;
+        int iconId = 0;
         boolean visible = true;
-
-        if (!isCdma()) {
+        if (mDataNetType == TelephonyManager.NETWORK_TYPE_UNKNOWN) {
+            // If data network type is unknown do not display data icon
+            visible = false;
+        } else if (!isCdma()) {
             // GSM case, we have to check also the sim state
             if (mSimState == IccCardConstants.State.READY ||
                     mSimState == IccCardConstants.State.UNKNOWN) {
-                if (hasService() && mDataState == TelephonyManager.DATA_CONNECTED) {
+                if (mDataState == TelephonyManager.DATA_CONNECTED) {
                     switch (mDataActivity) {
                         case TelephonyManager.DATA_ACTIVITY_IN:
                             iconId = mDataIconList[1];
@@ -817,7 +858,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
             }
         } else {
             // CDMA case, mDataActivity can be also DATA_ACTIVITY_DORMANT
-            if (hasService() && mDataState == TelephonyManager.DATA_CONNECTED) {
+            if (mDataState == TelephonyManager.DATA_CONNECTED) {
                 switch (mDataActivity) {
                     case TelephonyManager.DATA_ACTIVITY_IN:
                         iconId = mDataIconList[1];
@@ -895,7 +936,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         }
     }
 
-    private void updateWifiState(Intent intent) {
+    protected void updateWifiState(Intent intent) {
         final String action = intent.getAction();
         if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
             mWifiEnabled = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
@@ -930,7 +971,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         updateWifiIcons();
     }
 
-    private void updateWifiIcons() {
+    protected void updateWifiIcons() {
         if (mWifiConnected) {
             mWifiIconId = WifiIcons.WIFI_SIGNAL_STRENGTH[mInetCondition][mWifiLevel];
             mQSWifiIconId = WifiIcons.QS_WIFI_SIGNAL_STRENGTH[mInetCondition][mWifiLevel];
@@ -965,7 +1006,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
 
 
     // ===== Wimax ===================================================================
-    private final void updateWimaxState(Intent intent) {
+    protected final void updateWimaxState(Intent intent) {
         final String action = intent.getAction();
         boolean wasConnected = mWimaxConnected;
         if (action.equals(WimaxManagerConstants.NET_4G_STATE_CHANGED_ACTION)) {
@@ -989,7 +1030,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         updateWimaxIcons();
     }
 
-    private void updateWimaxIcons() {
+    protected void updateWimaxIcons() {
         if (mIsWimaxEnabled) {
             if (mWimaxConnected) {
                 if (mWimaxIdle)
@@ -1009,7 +1050,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
 
     // ===== Full or limited Internet connectivity ==================================
 
-    private void updateConnectivity(Intent intent) {
+    protected void updateConnectivity(Intent intent) {
         if (CHATTY) {
             Log.d(TAG, "updateConnectivity: intent=" + intent);
         }
@@ -1179,6 +1220,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
             mAirplaneIconId = FLIGHT_MODE_ICON;
             mPhoneSignalIconId = mDataSignalIconId = mDataTypeIconId = mQSDataTypeIconId = 0;
             mQSPhoneSignalIconId = 0;
+            mNoSimIconId = 0;
 
             // combined values from connected wifi take precedence over airplane mode
             if (mWifiConnected) {
@@ -1205,7 +1247,9 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                 mHasMobileDataFeature ? mDataSignalIconId : mWifiIconId;
             mContentDescriptionCombinedSignal = mHasMobileDataFeature
                 ? mContentDescriptionDataType : mContentDescriptionWifi;
+        }
 
+        if (!mDataConnected) {
             mDataTypeIconId = 0;
             mQSDataTypeIconId = 0;
             if (isCdma()) {
@@ -1241,6 +1285,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                     + " mDataSignalIconId=0x" + Integer.toHexString(mDataSignalIconId)
                     + " mDataTypeIconId=0x" + Integer.toHexString(mDataTypeIconId)
                     + " mQSDataTypeIconId=0x" + Integer.toHexString(mQSDataTypeIconId)
+                    + " mNoSimIconId=0x" + Integer.toHexString(mNoSimIconId)
                     + " mWifiIconId=0x" + Integer.toHexString(mWifiIconId)
                     + " mQSWifiIconId=0x" + Integer.toHexString(mQSWifiIconId)
                     + " mBluetoothTetherIconId=0x" + Integer.toHexString(mBluetoothTetherIconId));
@@ -1261,7 +1306,8 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
          || mLastWimaxIconId                != mWimaxIconId
          || mLastDataTypeIconId             != mDataTypeIconId
          || mLastAirplaneMode               != mAirplaneMode
-         || mLastLocale                     != mLocale)
+         || mLastLocale                     != mLocale
+         || mLastSimIconId                  != mNoSimIconId)
         {
             // NB: the mLast*s will be updated later
             for (SignalCluster cluster : mSignalClusters) {
@@ -1304,6 +1350,10 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
             }
         }
 
+        if (mLastSimIconId != mNoSimIconId) {
+            mLastSimIconId = mNoSimIconId;
+        }
+
         // the wifi icon on phones
         if (mLastWifiIconId != mWifiIconId) {
             mLastWifiIconId = mWifiIconId;
@@ -1563,7 +1613,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
         pw.println("");
     }
 
-    private String getResourceName(int resId) {
+    protected String getResourceName(int resId) {
         if (resId != 0) {
             final Resources res = mContext.getResources();
             try {
@@ -1657,7 +1707,8 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                             mMobileActivityIconId,
                             mDemoDataTypeIconId,
                             "Demo",
-                            "Demo");
+                            "Demo",
+                            mNoSimIconId);
                 }
             }
         }
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index 30463c2..c77cff1 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -5827,7 +5827,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
         final boolean hapticsDisabled = Settings.System.getIntForUser(mContext.getContentResolver(),
                 Settings.System.HAPTIC_FEEDBACK_ENABLED, 0, UserHandle.USER_CURRENT) == 0;
-        if (!always && (hapticsDisabled || mKeyguardDelegate.isShowingAndNotHidden())) {
+        if (!always && (hapticsDisabled || (mKeyguardDelegate != null
+                && mKeyguardDelegate.isShowingAndNotHidden()))) {
             return false;
         }
         long[] pattern = null;
diff --git a/services/java/com/android/server/MSimTelephonyRegistry.java b/services/java/com/android/server/MSimTelephonyRegistry.java
new file mode 100644
index 0000000..adbee34
--- /dev/null
+++ b/services/java/com/android/server/MSimTelephonyRegistry.java
@@ -0,0 +1,863 @@
+/*
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import android.app.ActivityManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.net.LinkCapabilities;
+import android.net.LinkProperties;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.telephony.CellInfo;
+import android.telephony.CellLocation;
+import android.telephony.MSimTelephonyManager;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Slog;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.net.NetworkInterface;
+
+import com.android.internal.app.IBatteryStats;
+import com.android.internal.telephony.ITelephonyRegistryMSim;
+import com.android.internal.telephony.IPhoneStateListener;
+import com.android.internal.telephony.DefaultPhoneNotifier;
+import com.android.internal.telephony.MSimConstants;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.ServiceStateTracker;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.server.am.BatteryStatsService;
+
+/**
+ * Since phone process can be restarted, this class provides a centralized place
+ * that applications can register and be called back from.
+ */
+class MSimTelephonyRegistry extends ITelephonyRegistryMSim.Stub {
+    private static final String TAG = "MSimTelephonyRegistry";
+    private static final boolean DBG = false;
+    private static final boolean DBG_LOC = false;
+
+    private static class Record {
+        String pkgForDebug;
+
+        IBinder binder;
+
+        IPhoneStateListener callback;
+
+        int callerUid;
+
+        int events;
+
+        int subscription;
+
+        @Override
+        public String toString() {
+            return "{pkgForDebug=" + pkgForDebug + " callerUid=" + callerUid +
+                    " events=" + Integer.toHexString(events) + "}";
+        }
+    }
+
+    private final Context mContext;
+
+    // access should be inside synchronized (mRecords) for these two fields
+    private final ArrayList<IBinder> mRemoveList = new ArrayList<IBinder>();
+    private final ArrayList<Record> mRecords = new ArrayList<Record>();
+
+    private final IBatteryStats mBatteryStats;
+
+    private int[] mCallState;
+
+    private String[] mCallIncomingNumber;
+
+    private ServiceState[] mServiceState;
+
+    private SignalStrength[] mSignalStrength;
+
+    private boolean[] mMessageWaiting;
+
+    private boolean[] mCallForwarding;
+
+    private int mDataActivity = TelephonyManager.DATA_ACTIVITY_NONE;
+
+    private int mDataConnectionState = TelephonyManager.DATA_UNKNOWN;
+
+    private boolean mDataConnectionPossible = false;
+
+    private String mDataConnectionReason = "";
+
+    private String mDataConnectionApn = "";
+
+    private ArrayList<String> mConnectedApns;
+
+    private LinkProperties mDataConnectionLinkProperties;
+
+    private LinkCapabilities mDataConnectionLinkCapabilities;
+
+    private Bundle[] mCellLocation;
+
+    private int mDataConnectionNetworkType;
+
+    private int mOtaspMode = ServiceStateTracker.OTASP_UNKNOWN;
+
+    private ArrayList<List<CellInfo>> mCellInfo = null;
+
+    private int mDefaultSubscription = 0;
+
+    static final int PHONE_STATE_PERMISSION_MASK =
+                PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR |
+                PhoneStateListener.LISTEN_CALL_STATE |
+                PhoneStateListener.LISTEN_DATA_ACTIVITY |
+                PhoneStateListener.LISTEN_DATA_CONNECTION_STATE |
+                PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR;
+
+    private static final int MSG_USER_SWITCHED = 1;
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_USER_SWITCHED: {
+                    Slog.d(TAG, "MSG_USER_SWITCHED userId=" + msg.arg1);
+                    int numPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+                    for (int sub = 0; sub < numPhones; sub++) {
+                        MSimTelephonyRegistry.this.notifyCellLocation(mCellLocation[sub], sub);
+                    }
+                    break;
+                }
+            }
+        }
+    };
+
+    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (Intent.ACTION_USER_SWITCHED.equals(action)) {
+                mHandler.sendMessage(mHandler.obtainMessage(MSG_USER_SWITCHED,
+                        intent.getIntExtra(Intent.EXTRA_USER_HANDLE, 0), 0));
+            }
+        }
+    };
+
+    // we keep a copy of all of the state so we can send it out when folks
+    // register for it
+    //
+    // In these calls we call with the lock held. This is safe becasuse remote
+    // calls go through a oneway interface and local calls going through a
+    // handler before they get to app code.
+
+    MSimTelephonyRegistry(Context context) {
+        CellLocation  location = CellLocation.getEmpty();
+
+        mContext = context;
+        mBatteryStats = BatteryStatsService.getService();
+        mConnectedApns = new ArrayList<String>();
+
+        // Initialize default subscription to be used for single standby.
+        mDefaultSubscription = MSimTelephonyManager.getDefault().getDefaultSubscription();
+
+        int numPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+        mCallState = new int[numPhones];
+        mCallIncomingNumber = new String[numPhones];
+        mServiceState = new ServiceState[numPhones];
+        mSignalStrength = new SignalStrength[numPhones];
+        mMessageWaiting = new boolean[numPhones];
+        mCallForwarding = new boolean[numPhones];
+        mCellLocation = new Bundle[numPhones];
+        mCellInfo = new ArrayList<List<CellInfo>>();
+        for (int i = 0; i < numPhones; i++) {
+            mCallState[i] =  TelephonyManager.CALL_STATE_IDLE;
+            mCallIncomingNumber[i] =  "";
+            mServiceState[i] =  new ServiceState();
+            mSignalStrength[i] =  new SignalStrength();
+            mMessageWaiting[i] =  false;
+            mCallForwarding[i] =  false;
+            mCellLocation[i] = new Bundle();
+            mCellInfo.add(i, null);
+        }
+
+        // Note that location can be null for non-phone builds like
+        // like the generic one.
+        if (location != null) {
+            for (int i = 0; i < MSimTelephonyManager.getDefault().getPhoneCount(); i++) {
+                location.fillInNotifierBundle(mCellLocation[i]);
+            }
+        }
+    }
+
+    public void systemRunning() {
+        // Watch for interesting updates
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_USER_SWITCHED);
+        filter.addAction(Intent.ACTION_USER_REMOVED);
+        mContext.registerReceiver(mBroadcastReceiver, filter);
+    }
+
+    @Override
+    public void listen(String pkgForDebug, IPhoneStateListener callback, int events,
+            boolean notifyNow, int subscription) {
+        int callerUid = UserHandle.getCallingUserId();
+        int myUid = UserHandle.myUserId();
+        if (DBG) {
+            Slog.d(TAG, "listen: E pkg=" + pkgForDebug + " events=0x" + Integer.toHexString(events)
+                + " myUid=" + myUid
+                + " callerUid=" + callerUid);
+        }
+        if (events != 0) {
+            /* Checks permission and throws Security exception */
+            checkListenerPermission(events);
+
+            synchronized (mRecords) {
+                // register
+                Record r = null;
+                find_and_add: {
+                    IBinder b = callback.asBinder();
+                    final int N = mRecords.size();
+                    for (int i = 0; i < N; i++) {
+                        r = mRecords.get(i);
+                        if (b == r.binder) {
+                            break find_and_add;
+                        }
+                    }
+                    r = new Record();
+                    r.binder = b;
+                    r.callback = callback;
+                    r.pkgForDebug = pkgForDebug;
+                    r.callerUid = callerUid;
+                    r.subscription = subscription;
+                    mRecords.add(r);
+                    if (DBG) Slog.i(TAG, "listen: add new record=" + r);
+                }
+                int send = events & (events ^ r.events);
+                r.events = events;
+                if (notifyNow) {
+                    if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
+                        try {
+                            r.callback.onServiceStateChanged(
+                                    new ServiceState(mServiceState[subscription]));
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
+                        try {
+                            int gsmSignalStrength = mSignalStrength[subscription]
+                                    .getGsmSignalStrength();
+                            r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1
+                                    : gsmSignalStrength));
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
+                        try {
+                            r.callback.onMessageWaitingIndicatorChanged(
+                                    mMessageWaiting[subscription]);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
+                        try {
+                            r.callback.onCallForwardingIndicatorChanged(
+                                    mCallForwarding[subscription]);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)) {
+                        try {
+                            if (DBG_LOC) Slog.d(TAG, "listen: mCellLocation="
+                                    + mCellLocation[subscription]);
+                            r.callback.onCellLocationChanged(
+                                    new Bundle(mCellLocation[subscription]));
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
+                        try {
+                            r.callback.onCallStateChanged(mCallState[subscription],
+                                     mCallIncomingNumber[subscription]);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
+                        try {
+                            if (r.subscription == subscription) {
+                                r.callback.onDataConnectionStateChanged(mDataConnectionState,
+                                        mDataConnectionNetworkType);
+                            }
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_DATA_ACTIVITY) != 0) {
+                        try {
+                            r.callback.onDataActivity(mDataActivity);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
+                        try {
+                            r.callback.onSignalStrengthsChanged(mSignalStrength[subscription]);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_OTASP_CHANGED) != 0) {
+                        try {
+                            r.callback.onOtaspChanged(mOtaspMode);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_INFO)) {
+                        try {
+                            if (DBG_LOC) Slog.d(TAG, "listen: mCellInfo[" + subscription + "]="
+                                    + mCellInfo.get(subscription));
+                            r.callback.onCellInfoChanged(mCellInfo.get(subscription));
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                }
+            }
+        } else {
+            remove(callback.asBinder());
+        }
+    }
+
+    private void remove(IBinder binder) {
+        synchronized (mRecords) {
+            final int recordCount = mRecords.size();
+            for (int i = 0; i < recordCount; i++) {
+                if (mRecords.get(i).binder == binder) {
+                    mRecords.remove(i);
+                    return;
+                }
+            }
+        }
+    }
+
+    public void notifyCallState(int state, String incomingNumber, int subscription) {
+        if (!checkNotifyPermission("notifyCallState()")) {
+            return;
+        }
+        synchronized (mRecords) {
+            mCallState[subscription] = state;
+            mCallIncomingNumber[subscription] = incomingNumber;
+            for (Record r : mRecords) {
+                if (((r.events & PhoneStateListener.LISTEN_CALL_STATE) != 0) &&
+                    (r.subscription == subscription)) {
+                    try {
+                        r.callback.onCallStateChanged(state, incomingNumber);
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+        broadcastCallStateChanged(state, incomingNumber, subscription);
+    }
+
+    public void notifyServiceState(ServiceState state, int subscription) {
+        if (!checkNotifyPermission("notifyServiceState()")){
+            return;
+        }
+        Slog.i(TAG, "notifyServiceState: " + state);
+        synchronized (mRecords) {
+            mServiceState[subscription] = state;
+            for (Record r : mRecords) {
+                if (((r.events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) &&
+                    (r.subscription == subscription)) {
+                    try {
+                        r.callback.onServiceStateChanged(new ServiceState(state));
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+        broadcastServiceStateChanged(state, subscription);
+    }
+
+    public void notifySignalStrength(SignalStrength signalStrength, int subscription) {
+        if (!checkNotifyPermission("notifySignalStrength()")) {
+            return;
+        }
+        synchronized (mRecords) {
+            mSignalStrength[subscription] = signalStrength;
+            for (Record r : mRecords) {
+                if (((r.events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) &&
+                    (r.subscription == subscription)){
+                    try {
+                        r.callback.onSignalStrengthsChanged(new SignalStrength(signalStrength));
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+                if (((r.events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) &&
+                    (r.subscription == subscription)) {
+                    try {
+                        int gsmSignalStrength = signalStrength.getGsmSignalStrength();
+                        r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1
+                                : gsmSignalStrength));
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+        broadcastSignalStrengthChanged(signalStrength, subscription);
+    }
+
+    public void notifyCellInfo(List<CellInfo> cellInfo, int subscription) {
+        if (!checkNotifyPermission("notifyCellInfo()")) {
+            return;
+        }
+
+        synchronized (mRecords) {
+            mCellInfo.set(subscription, cellInfo);
+            for (Record r : mRecords) {
+                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_INFO)
+                        && r.subscription == subscription) {
+                    try {
+                        if (DBG_LOC) {
+                            Slog.d(TAG, "notifyCellInfo: mCellInfo=" + cellInfo + " r=" + r);
+                        }
+                        r.callback.onCellInfoChanged(cellInfo);
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+    }
+
+    public void notifyMessageWaitingChanged(boolean mwi, int subscription) {
+        if (!checkNotifyPermission("notifyMessageWaitingChanged()")) {
+            return;
+        }
+        synchronized (mRecords) {
+            mMessageWaiting[subscription] = mwi;
+            for (Record r : mRecords) {
+                if (((r.events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) &&
+                    (r.subscription == subscription)) {
+                    try {
+                        r.callback.onMessageWaitingIndicatorChanged(mwi);
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+    }
+
+    public void notifyCallForwardingChanged(boolean cfi, int subscription) {
+        if (!checkNotifyPermission("notifyCallForwardingChanged()")) {
+            return;
+        }
+        synchronized (mRecords) {
+            mCallForwarding[subscription] = cfi;
+            for (Record r : mRecords) {
+                if (((r.events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) &&
+                    (r.subscription == subscription)) {
+                    try {
+                        r.callback.onCallForwardingIndicatorChanged(cfi);
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+    }
+
+    public void notifyDataActivity(int state) {
+        if (!checkNotifyPermission("notifyDataActivity()" )) {
+            return;
+        }
+        synchronized (mRecords) {
+            mDataActivity = state;
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_DATA_ACTIVITY) != 0) {
+                    try {
+                        r.callback.onDataActivity(state);
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+    }
+
+    public void notifyDataConnection(int state, boolean isDataConnectivityPossible,
+            String reason, String apn, String apnType, LinkProperties linkProperties,
+            LinkCapabilities linkCapabilities, int networkType, boolean roaming,
+            int subscription) {
+        if (!checkNotifyPermission("notifyDataConnection()" )) {
+            return;
+        }
+        if (DBG) {
+            Slog.i(TAG, "notifyDataConnection: state=" + state + " isDataConnectivityPossible="
+                + isDataConnectivityPossible + " reason='" + reason
+                + "' apn='" + apn + "' apnType=" + apnType + " networkType=" + networkType
+                + " mRecords.size()=" + mRecords.size() + " mRecords=" + mRecords);
+        }
+        synchronized (mRecords) {
+            boolean modified = false;
+            if (state == TelephonyManager.DATA_CONNECTED) {
+                if (!mConnectedApns.contains(apnType)) {
+                    mConnectedApns.add(apnType);
+                    if (mDataConnectionState != state) {
+                        mDataConnectionState = state;
+                        modified = true;
+                    }
+                }
+            } else {
+                if (mConnectedApns.remove(apnType)) {
+                    if (mConnectedApns.isEmpty()) {
+                        mDataConnectionState = state;
+                        modified = true;
+                    } else {
+                        // leave mDataConnectionState as is and
+                        // send out the new status for the APN in question.
+                    }
+                }
+            }
+            mDataConnectionPossible = isDataConnectivityPossible;
+            mDataConnectionReason = reason;
+            mDataConnectionLinkProperties = linkProperties;
+            mDataConnectionLinkCapabilities = linkCapabilities;
+            if (mDataConnectionNetworkType != networkType) {
+                mDataConnectionNetworkType = networkType;
+                // need to tell registered listeners about the new network type
+                modified = true;
+            }
+            if (modified) {
+                if (DBG) {
+                    Slog.d(TAG, "onDataConnectionStateChanged(" + mDataConnectionState
+                        + ", " + mDataConnectionNetworkType + ")");
+                }
+                for (Record r : mRecords) {
+                    if (((r.events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) &&
+                            (r.subscription == subscription)) {
+                        try {
+                            Slog.d(TAG,"Notify data connection state changed on sub: " +
+                                    subscription);
+                            r.callback.onDataConnectionStateChanged(mDataConnectionState,
+                                    mDataConnectionNetworkType);
+                        } catch (RemoteException ex) {
+                            mRemoveList.add(r.binder);
+                        }
+                    }
+                }
+                handleRemoveListLocked();
+            }
+        }
+        broadcastDataConnectionStateChanged(state, isDataConnectivityPossible, reason, apn,
+                apnType, linkProperties, linkCapabilities, roaming, subscription);
+    }
+
+    public void notifyDataConnectionFailed(String reason, String apnType,
+            int subscription) {
+        if (!checkNotifyPermission("notifyDataConnectionFailed()")) {
+            return;
+        }
+        /*
+         * This is commented out because there is no onDataConnectionFailed callback
+         * in PhoneStateListener. There should be.
+        synchronized (mRecords) {
+            mDataConnectionFailedReason = reason;
+            final int N = mRecords.size();
+            for (int i=N-1; i>=0; i--) {
+                Record r = mRecords.get(i);
+                if ((r.events & PhoneStateListener.LISTEN_DATA_CONNECTION_FAILED) != 0) {
+                    // XXX
+                }
+            }
+        }
+        */
+        broadcastDataConnectionFailed(reason, apnType, subscription);
+    }
+
+    public void notifyCellLocation(Bundle cellLocation, int subscription) {
+        if (!checkNotifyPermission("notifyCellLocation()")) {
+            return;
+        }
+        synchronized (mRecords) {
+            mCellLocation[subscription] = cellLocation;
+            for (Record r : mRecords) {
+                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)
+                        && r.subscription == subscription) {
+                    try {
+                        if (DBG_LOC) {
+                            Slog.d(TAG, "notifyCellLocation: mCellLocation=" + mCellLocation
+                                    + " r=" + r);
+                        }
+                        r.callback.onCellLocationChanged(new Bundle(cellLocation));
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+
+                }
+            }
+            handleRemoveListLocked();
+        }
+    }
+
+    public void notifyOtaspChanged(int otaspMode) {
+        if (!checkNotifyPermission("notifyOtaspChanged()" )) {
+            return;
+        }
+        synchronized (mRecords) {
+            mOtaspMode = otaspMode;
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_OTASP_CHANGED) != 0) {
+                    try {
+                        r.callback.onOtaspChanged(otaspMode);
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
+                != PackageManager.PERMISSION_GRANTED) {
+            pw.println("Permission Denial: can't dump telephony.registry from from pid="
+                    + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
+            return;
+        }
+        synchronized (mRecords) {
+            final int recordCount = mRecords.size();
+            pw.println("last known state:");
+            for (int i = 0; i < MSimTelephonyManager.getDefault().getPhoneCount(); i++) {
+                pw.println("  mCallState[" + i + "]=" + mCallState[i]);
+                pw.println("  mCallIncomingNumber[" + i + "]=" + mCallIncomingNumber[i]);
+                pw.println("  mServiceState[" + i + "]=" + mServiceState[i]);
+                pw.println("  mSignalStrength[" + i + "]=" + mSignalStrength[i]);
+                pw.println("  mMessageWaiting[" + i + "]=" + mMessageWaiting[i]);
+                pw.println("  mCallForwarding[" + i + "]=" + mCallForwarding[i]);
+                pw.println("  mCellLocation[" + i + "]=" + mCellLocation[i]);
+                pw.println("  mCellInfo[" + i + "]=" + mCellInfo.get(i));
+            }
+            pw.println("  mDataActivity=" + mDataActivity);
+            pw.println("  mDataConnectionState=" + mDataConnectionState);
+            pw.println("  mDataConnectionPossible=" + mDataConnectionPossible);
+            pw.println("  mDataConnectionReason=" + mDataConnectionReason);
+            pw.println("  mDataConnectionApn=" + mDataConnectionApn);
+            pw.println("  mDataConnectionLinkProperties=" + mDataConnectionLinkProperties);
+            pw.println("  mDataConnectionLinkCapabilities=" + mDataConnectionLinkCapabilities);
+            pw.println("  mDataConnectionNetworkType=" + mDataConnectionNetworkType);
+            pw.println("registrations: count=" + recordCount);
+            for (Record r : mRecords) {
+                pw.println("  " + r.pkgForDebug + " 0x" + Integer.toHexString(r.events));
+            }
+        }
+    }
+
+    //
+    // the legacy intent broadcasting
+    //
+
+    private void broadcastServiceStateChanged(ServiceState state, int subscription) {
+        long ident = Binder.clearCallingIdentity();
+        try {
+            mBatteryStats.notePhoneState(state.getState());
+        } catch (RemoteException re) {
+            // Can't do much
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+
+        Intent intent = new Intent(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED);
+        Bundle data = new Bundle();
+        state.fillInNotifierBundle(data);
+        intent.putExtras(data);
+        // Pass the subscription along with the intent.
+        intent.putExtra(MSimConstants.SUBSCRIPTION_KEY, subscription);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void broadcastSignalStrengthChanged(SignalStrength signalStrength, int subscription) {
+        long ident = Binder.clearCallingIdentity();
+        try {
+            mBatteryStats.notePhoneSignalStrength(signalStrength);
+        } catch (RemoteException e) {
+            /* The remote entity disappeared, we can safely ignore the exception. */
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+
+        Intent intent = new Intent(TelephonyIntents.ACTION_SIGNAL_STRENGTH_CHANGED);
+        intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        Bundle data = new Bundle();
+        signalStrength.fillInNotifierBundle(data);
+        intent.putExtras(data);
+        intent.putExtra(MSimConstants.SUBSCRIPTION_KEY, subscription);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void broadcastCallStateChanged(int state, String incomingNumber, int subscription) {
+        long ident = Binder.clearCallingIdentity();
+        try {
+            if (state == TelephonyManager.CALL_STATE_IDLE) {
+                mBatteryStats.notePhoneOff();
+            } else {
+                mBatteryStats.notePhoneOn();
+            }
+        } catch (RemoteException e) {
+            /* The remote entity disappeared, we can safely ignore the exception. */
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    private void broadcastDataConnectionStateChanged(int state,
+            boolean isDataConnectivityPossible,
+            String reason, String apn, String apnType, LinkProperties linkProperties,
+            LinkCapabilities linkCapabilities, boolean roaming, int subscription) {
+        // Note: not reporting to the battery stats service here, because the
+        // status bar takes care of that after taking into account all of the
+        // required info.
+        Intent intent = new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
+        intent.putExtra(PhoneConstants.STATE_KEY,
+                DefaultPhoneNotifier.convertDataState(state).toString());
+        if (!isDataConnectivityPossible) {
+            intent.putExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, true);
+        }
+        if (reason != null) {
+            intent.putExtra(PhoneConstants.STATE_CHANGE_REASON_KEY, reason);
+        }
+        if (linkProperties != null) {
+            intent.putExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY, linkProperties);
+            String iface = linkProperties.getInterfaceName();
+            if (iface != null) {
+                intent.putExtra(PhoneConstants.DATA_IFACE_NAME_KEY, iface);
+            }
+        }
+        if (linkCapabilities != null) {
+            intent.putExtra(PhoneConstants.DATA_LINK_CAPABILITIES_KEY, linkCapabilities);
+        }
+        if (roaming) intent.putExtra(PhoneConstants.DATA_NETWORK_ROAMING_KEY, true);
+
+        intent.putExtra(PhoneConstants.DATA_APN_KEY, apn);
+        intent.putExtra(PhoneConstants.DATA_APN_TYPE_KEY, apnType);
+        intent.putExtra(MSimConstants.SUBSCRIPTION_KEY, subscription);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void broadcastDataConnectionFailed(String reason, String apnType,
+            int subscription) {
+        Intent intent = new Intent(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED);
+        intent.putExtra(PhoneConstants.FAILURE_REASON_KEY, reason);
+        intent.putExtra(PhoneConstants.DATA_APN_TYPE_KEY, apnType);
+        intent.putExtra(MSimConstants.SUBSCRIPTION_KEY,
+                MSimTelephonyManager.getDefault().getPreferredDataSubscription());
+        intent.putExtra(MSimConstants.SUBSCRIPTION_KEY, subscription);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private boolean checkNotifyPermission(String method) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
+                == PackageManager.PERMISSION_GRANTED) {
+            return true;
+        }
+        String msg = "Modify Phone State Permission Denial: " + method + " from pid="
+                + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid();
+        if (DBG) Slog.w(TAG, msg);
+        return false;
+    }
+
+    private void checkListenerPermission(int events) {
+        if ((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) {
+            mContext.enforceCallingOrSelfPermission(
+                    android.Manifest.permission.ACCESS_COARSE_LOCATION, null);
+
+        }
+
+        if ((events & PhoneStateListener.LISTEN_CELL_INFO) != 0) {
+            mContext.enforceCallingOrSelfPermission(
+                    android.Manifest.permission.ACCESS_COARSE_LOCATION, null);
+
+        }
+
+        if ((events & PHONE_STATE_PERMISSION_MASK) != 0) {
+            mContext.enforceCallingOrSelfPermission(
+                    android.Manifest.permission.READ_PHONE_STATE, null);
+        }
+    }
+
+    private void handleRemoveListLocked() {
+        if (mRemoveList.size() > 0) {
+            for (IBinder b: mRemoveList) {
+                remove(b);
+            }
+            mRemoveList.clear();
+        }
+    }
+
+    private boolean validateEventsAndUserLocked(Record r, int events) {
+        int foregroundUser;
+        long callingIdentity = Binder.clearCallingIdentity();
+        boolean valid = false;
+        try {
+            foregroundUser = ActivityManager.getCurrentUser();
+            valid = r.callerUid ==  foregroundUser && (r.events & events) != 0;
+            if (DBG | DBG_LOC) {
+                Slog.d(TAG, "validateEventsAndUserLocked: valid=" + valid
+                        + " r.callerUid=" + r.callerUid + " foregroundUser=" + foregroundUser
+                        + " r.events=" + r.events + " events=" + events);
+            }
+        } finally {
+            Binder.restoreCallingIdentity(callingIdentity);
+        }
+        return valid;
+    }
+}
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 1af0376..8ee9eef 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -1,6 +1,8 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
  * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
+ * Copyright (c) 2012, 2013. The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -202,6 +204,7 @@ class ServerThread {
         CommonTimeManagementService commonTimeMgmtService = null;
         InputManagerService inputManager = null;
         TelephonyRegistry telephonyRegistry = null;
+        MSimTelephonyRegistry msimTelephonyRegistry = null;
         ConsumerIrService consumerIr = null;
 
         // Create a handler thread just for the window manager to enjoy.
@@ -264,6 +267,12 @@ class ServerThread {
             telephonyRegistry = new TelephonyRegistry(context);
             ServiceManager.addService("telephony.registry", telephonyRegistry);
 
+            if (android.telephony.MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+                Slog.i(TAG, "MSimTelephony Registry");
+                msimTelephonyRegistry = new MSimTelephonyRegistry(context);
+                ServiceManager.addService("telephony.msim.registry", msimTelephonyRegistry);
+            }
+
             Slog.i(TAG, "Scheduling Policy");
             ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
 
@@ -1069,6 +1078,7 @@ class ServerThread {
         final AssetAtlasService atlasF = atlas;
         final InputManagerService inputManagerF = inputManager;
         final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
+        final MSimTelephonyRegistry msimTelephonyRegistryF = msimTelephonyRegistry;
         final PrintManagerService printManagerF = printManager;
         final MediaRouterService mediaRouterF = mediaRouter;
 
@@ -1219,6 +1229,12 @@ class ServerThread {
                 }
 
                 try {
+                    if (msimTelephonyRegistryF != null) msimTelephonyRegistryF.systemRunning();
+                } catch (Throwable e) {
+                    reportWtf("Notifying TelephonyRegistry running", e);
+                }
+
+                try {
                     if (printManagerF != null) printManagerF.systemRuning();
                 } catch (Throwable e) {
                     reportWtf("Notifying PrintManagerService running", e);
diff --git a/services/java/com/android/server/TelephonyRegistry.java b/services/java/com/android/server/TelephonyRegistry.java
index 699d79e..1845486 100644
--- a/services/java/com/android/server/TelephonyRegistry.java
+++ b/services/java/com/android/server/TelephonyRegistry.java
@@ -32,6 +32,7 @@ import android.os.Message;
 import android.os.RemoteException;
 import android.os.UserHandle;
 import android.telephony.CellLocation;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.PhoneStateListener;
 import android.telephony.ServiceState;
 import android.telephony.SignalStrength;
@@ -640,6 +641,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     //
 
     private void broadcastServiceStateChanged(ServiceState state) {
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+        // Return from here as this intent will be sent anyway from MSimTelephonyRegistry
+            return;
+        }
         long ident = Binder.clearCallingIdentity();
         try {
             mBatteryStats.notePhoneState(state.getState());
@@ -657,6 +662,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     }
 
     private void broadcastSignalStrengthChanged(SignalStrength signalStrength) {
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+        // Return from here as this intent will be sent anyway from MSimTelephonyRegistry
+            return;
+        }
         long ident = Binder.clearCallingIdentity();
         try {
             mBatteryStats.notePhoneSignalStrength(signalStrength);
@@ -675,6 +684,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     }
 
     private void broadcastCallStateChanged(int state, String incomingNumber) {
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+        // Return from here as this intent will be sent anyway from MSimDefaultPhoneNotifier
+            return;
+        }
         long ident = Binder.clearCallingIdentity();
         try {
             if (state == TelephonyManager.CALL_STATE_IDLE) {
@@ -702,6 +715,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
             boolean isDataConnectivityPossible,
             String reason, String apn, String apnType, LinkProperties linkProperties,
             LinkCapabilities linkCapabilities, boolean roaming) {
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+        // Return from here as this intent will be sent anyway from MSimTelephonyRegistry
+            return;
+        }
         // Note: not reporting to the battery stats service here, because the
         // status bar takes care of that after taking into account all of the
         // required info.
@@ -732,6 +749,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     }
 
     private void broadcastDataConnectionFailed(String reason, String apnType) {
+        if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+        // Return from here as this intent will be sent anyway from MSimTelephonyRegistry
+            return;
+        }
         Intent intent = new Intent(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED);
         intent.putExtra(PhoneConstants.FAILURE_REASON_KEY, reason);
         intent.putExtra(PhoneConstants.DATA_APN_TYPE_KEY, apnType);
diff --git a/services/java/com/android/server/connectivity/DataConnectionStats.java b/services/java/com/android/server/connectivity/DataConnectionStats.java
index 227ab23..5b247d1 100644
--- a/services/java/com/android/server/connectivity/DataConnectionStats.java
+++ b/services/java/com/android/server/connectivity/DataConnectionStats.java
@@ -111,7 +111,7 @@ public class DataConnectionStats extends BroadcastReceiver {
             } else if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK.equals(lockedReason)) {
                 mSimState = IccCardConstants.State.PUK_REQUIRED;
             } else {
-                mSimState = IccCardConstants.State.NETWORK_LOCKED;
+                mSimState = IccCardConstants.State.PERSO_LOCKED;
             }
         } else {
             mSimState = IccCardConstants.State.UNKNOWN;
diff --git a/services/java/com/android/server/net/NetworkPolicyManagerService.java b/services/java/com/android/server/net/NetworkPolicyManagerService.java
index 1e95410..bd25e6a 100644
--- a/services/java/com/android/server/net/NetworkPolicyManagerService.java
+++ b/services/java/com/android/server/net/NetworkPolicyManagerService.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2011 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -59,7 +61,6 @@ import static android.net.wifi.WifiManager.EXTRA_CHANGE_REASON;
 import static android.net.wifi.WifiManager.EXTRA_NETWORK_INFO;
 import static android.net.wifi.WifiManager.EXTRA_WIFI_CONFIGURATION;
 import static android.net.wifi.WifiManager.EXTRA_WIFI_INFO;
-import static android.telephony.TelephonyManager.SIM_STATE_READY;
 import static android.text.format.DateUtils.DAY_IN_MILLIS;
 import static com.android.internal.util.ArrayUtils.appendInt;
 import static com.android.internal.util.Preconditions.checkNotNull;
@@ -116,6 +117,7 @@ import android.os.RemoteException;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.Settings;
+import android.provider.Settings.SettingNotFoundException;
 import android.telephony.TelephonyManager;
 import android.text.format.Formatter;
 import android.text.format.Time;
@@ -679,16 +681,16 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
      * data connection status.
      */
     private boolean isTemplateRelevant(NetworkTemplate template) {
-        final TelephonyManager tele = TelephonyManager.from(mContext);
-
         switch (template.getMatchRule()) {
             case MATCH_MOBILE_3G_LOWER:
             case MATCH_MOBILE_4G:
             case MATCH_MOBILE_ALL:
                 // mobile templates are relevant when SIM is ready and
                 // subscriberId matches.
-                if (tele.getSimState() == SIM_STATE_READY) {
-                    return Objects.equal(tele.getSubscriberId(), template.getSubscriberId());
+                if (NetworkIdentity.isDdsReady()) {
+                    // multi sim data traffic statistics
+                    return Objects.equal(NetworkIdentity.getDdsSubscriberId(),
+                            template.getSubscriberId());
                 } else {
                     return false;
                 }
@@ -937,16 +939,15 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
      * for the given {@link NetworkTemplate}.
      */
     private void setNetworkTemplateEnabled(NetworkTemplate template, boolean enabled) {
-        final TelephonyManager tele = TelephonyManager.from(mContext);
-
         switch (template.getMatchRule()) {
             case MATCH_MOBILE_3G_LOWER:
             case MATCH_MOBILE_4G:
             case MATCH_MOBILE_ALL:
                 // TODO: offer more granular control over radio states once
                 // 4965893 is available.
-                if (tele.getSimState() == SIM_STATE_READY
-                        && Objects.equal(tele.getSubscriberId(), template.getSubscriberId())) {
+                if (NetworkIdentity.isDdsReady()
+                        && Objects.equal(NetworkIdentity.getDdsSubscriberId(),
+                                template.getSubscriberId())) {
                     setPolicyDataEnable(TYPE_MOBILE, enabled);
                     setPolicyDataEnable(TYPE_WIMAX, enabled);
                 }
@@ -1097,12 +1098,10 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         if (LOGV) Slog.v(TAG, "ensureActiveMobilePolicyLocked()");
         if (mSuppressDefaultPolicy) return;
 
-        final TelephonyManager tele = TelephonyManager.from(mContext);
-
         // avoid creating policy when SIM isn't ready
-        if (tele.getSimState() != SIM_STATE_READY) return;
+        if (!NetworkIdentity.isDdsReady()) return;
 
-        final String subscriberId = tele.getSubscriberId();
+        final String subscriberId = NetworkIdentity.getDdsSubscriberId();
         final NetworkIdentity probeIdent = new NetworkIdentity(
                 TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN, subscriberId, null, false);
 
diff --git a/services/java/com/android/server/power/ShutdownThread.java b/services/java/com/android/server/power/ShutdownThread.java
index 4f9195f..cf00ba1 100644
--- a/services/java/com/android/server/power/ShutdownThread.java
+++ b/services/java/com/android/server/power/ShutdownThread.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2008 The Android Open Source Project
  * Copyright (C) 2013 The CyanogenMod Project
  *
@@ -44,8 +46,10 @@ import android.os.SystemVibrator;
 import android.os.storage.IMountService;
 import android.os.storage.IMountShutdownObserver;
 import android.provider.Settings;
+import android.telephony.MSimTelephonyManager;
 
 import com.android.internal.telephony.ITelephony;
+import com.android.internal.telephony.msim.ITelephonyMSim;
 
 import android.util.Log;
 import android.view.WindowManager;
@@ -495,10 +499,28 @@ public final class ShutdownThread extends Thread {
                 }
 
                 try {
-                    radioOff = phone == null || !phone.isRadioOn();
-                    if (!radioOff) {
-                        Log.w(TAG, "Turning off radio...");
-                        phone.setRadio(false);
+                    radioOff = true;
+                    if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+                        final ITelephonyMSim mphone = ITelephonyMSim.Stub.asInterface(
+                                ServiceManager.checkService("phone_msim"));
+                        if (mphone != null) {
+                            //radio off indication should be sent for both subscriptions
+                            //in case of DSDS.
+                            for (int i = 0; i < MSimTelephonyManager.getDefault().
+                                    getPhoneCount(); i++) {
+                                radioOff = radioOff && !mphone.isRadioOn(i);
+                                if (mphone.isRadioOn(i)) {
+                                    Log.w(TAG, "Turning off radio on Subscription :" + i);
+                                    mphone.setRadio(false, i);
+                                }
+                            }
+                        }
+                    } else {
+                        radioOff = phone == null || !phone.isRadioOn();
+                        if (!radioOff) {
+                            Log.w(TAG, "Turning off radio...");
+                            phone.setRadio(false);
+                        }
                     }
                 } catch (RemoteException ex) {
                     Log.e(TAG, "RemoteException during radio shutdown", ex);
@@ -521,7 +543,18 @@ public final class ShutdownThread extends Thread {
                     }
                     if (!radioOff) {
                         try {
-                            radioOff = !phone.isRadioOn();
+                            boolean subRadioOff = true;
+                            if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+                                final ITelephonyMSim mphone = ITelephonyMSim.Stub.asInterface(
+                                        ServiceManager.checkService("phone_msim"));
+                                for (int i = 0; i < MSimTelephonyManager.getDefault().
+                                        getPhoneCount(); i++) {
+                                    subRadioOff = subRadioOff && !mphone.isRadioOn(i);
+                                }
+                                radioOff = subRadioOff;
+                            } else {
+                                radioOff = !phone.isRadioOn();
+                            }
                         } catch (RemoteException ex) {
                             Log.e(TAG, "RemoteException during radio shutdown", ex);
                             radioOff = true;
diff --git a/telephony/java/android/telephony/MSimTelephonyManager.java b/telephony/java/android/telephony/MSimTelephonyManager.java
new file mode 100644
index 0000000..cb4f884
--- /dev/null
+++ b/telephony/java/android/telephony/MSimTelephonyManager.java
@@ -0,0 +1,1135 @@
+/*
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.telephony;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.Context;
+import android.os.Bundle;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+
+import com.android.internal.telephony.msim.ITelephonyMSim;
+import com.android.internal.telephony.ITelephonyRegistryMSim;
+import com.android.internal.telephony.msim.IPhoneSubInfoMSim;
+import com.android.internal.telephony.MSimConstants;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyProperties;
+
+import java.util.List;
+
+/**
+ * Provides access to information about the telephony services on
+ * the device. Applications can use the methods in this class to
+ * determine telephony services and states, as well as to access some
+ * types of subscriber information. Applications can also register
+ * a listener to receive notification of telephony state changes.
+ * <p>
+ * You do not instantiate this class directly; instead, you retrieve
+ * a reference to an instance through
+ * {@link android.content.Context#getSystemService
+ * Context.getSystemService(Context.MSIM_TELEPHONY_SERVICE)}.
+ * <p>
+ * Note that access to some telephony information is
+ * permission-protected. Your application cannot access the protected
+ * information unless it has the appropriate permissions declared in
+ * its manifest file. Where permissions apply, they are noted in the
+ * the methods through which you access the protected information.
+ * @hide
+ */
+public class MSimTelephonyManager {
+    /** @hide */
+    private static Context sContext;
+    /** @hide */
+    protected static ITelephonyRegistryMSim sRegistryMsim;
+
+    protected static String multiSimConfig =
+            SystemProperties.get(TelephonyProperties.PROPERTY_MULTI_SIM_CONFIG);
+
+    /** Enum indicating multisim variants
+     *  DSDS - Dual SIM Dual Standby
+     *  DSDA - Dual SIM Dual Active
+     *  TSTS - Triple SIM Triple Standby
+     **/
+    public enum MultiSimVariants {
+        DSDS,
+        DSDA,
+        TSTS,
+        UNKNOWN
+    };
+
+    /** @hide */
+    public MSimTelephonyManager(Context context) {
+        if (sContext == null) {
+            Context appContext = context.getApplicationContext();
+            if (appContext != null) {
+                sContext = appContext;
+            } else {
+                sContext = context;
+            }
+
+            sRegistryMsim = ITelephonyRegistryMSim.Stub.asInterface(ServiceManager.getService(
+                    "telephony.msim.registry"));
+        }
+    }
+
+    /** @hide */
+    private MSimTelephonyManager() {
+    }
+
+    private static MSimTelephonyManager sInstance = new MSimTelephonyManager();
+
+    /** @hide
+    /* @deprecated - use getSystemService as described above */
+    public static MSimTelephonyManager getDefault() {
+        return sInstance;
+    }
+
+    /** {@hide} */
+    public static MSimTelephonyManager from(Context context) {
+        return (MSimTelephonyManager) context.getSystemService(Context.MSIM_TELEPHONY_SERVICE);
+    }
+
+    public boolean isMultiSimEnabled() {
+        return (multiSimConfig.equals("dsds") || multiSimConfig.equals("dsda") ||
+            multiSimConfig.equals("tsts"));
+    }
+
+    /**
+     * Returns the multi SIM variant
+     * Returns DSDS for Dual SIM Dual Standby
+     * Returns DSDA for Dual SIM Dual Active
+     * Returns TSTS for Triple SIM Triple Standby
+     * Returns UNKNOWN for others
+     */
+    public MultiSimVariants getMultiSimConfiguration() {
+        String mSimConfig =
+            SystemProperties.get(TelephonyProperties.PROPERTY_MULTI_SIM_CONFIG);
+        if (mSimConfig.equals("dsds")) {
+            return MultiSimVariants.DSDS;
+        } else if (mSimConfig.equals("dsda")) {
+            return MultiSimVariants.DSDA;
+        } else if (mSimConfig.equals("tsts")) {
+            return MultiSimVariants.TSTS;
+        } else {
+            return MultiSimVariants.UNKNOWN;
+        }
+    }
+
+
+    /**
+     * Returns the number of phones available.
+     * Returns 1 for Single standby mode (Single SIM functionality)
+     * Returns 2 for Dual standby mode.(Dual SIM functionality)
+     */
+    public int getPhoneCount() {
+        int phoneCount = 1;
+        switch (getMultiSimConfiguration()) {
+            case DSDS:
+            case DSDA:
+                phoneCount = MSimConstants.MAX_PHONE_COUNT_DUAL_SIM;
+                break;
+            case TSTS:
+                phoneCount = MSimConstants.MAX_PHONE_COUNT_TRI_SIM;
+                break;
+        }
+        return phoneCount;
+    }
+
+    /**
+     * Returns the software version number for the device, for example,
+     * the IMEI/SV for GSM phones. Return null if the software version is
+     * not available.
+     *
+     * <p>Requires Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     */
+    public String getDeviceSoftwareVersion(int subscription) {
+        try {
+            return getMSimSubscriberInfo().getDeviceSvn(subscription);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the unique device ID of a subscription, for example, the IMEI for
+     * GSM and the MEID for CDMA phones. Return null if device ID is not available.
+     *
+     * <p>Requires Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     *
+     * @param subscription of which deviceID is returned
+     */
+    public String getDeviceId(int subscription) {
+
+        try {
+            return getMSimSubscriberInfo().getDeviceId(subscription);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns a constant indicating the device phone type for a subscription.
+     *
+     * @see #PHONE_TYPE_NONE
+     * @see #PHONE_TYPE_GSM
+     * @see #PHONE_TYPE_CDMA
+     *
+     * @param subscription for which phone type is returned
+     * @hide
+     */
+    public int getCurrentPhoneType(int subscription) {
+
+        try{
+            ITelephonyMSim telephony = getITelephonyMSim();
+            if (telephony != null) {
+                return telephony.getActivePhoneType(subscription);
+            } else {
+                // This can happen when the ITelephonyMSim interface is not up yet.
+                return getPhoneTypeFromProperty(subscription);
+            }
+        } catch (RemoteException ex) {
+            // This shouldn't happen in the normal case, as a backup we
+            // read from the system property.
+            return getPhoneTypeFromProperty(subscription);
+        } catch (NullPointerException ex) {
+            // This shouldn't happen in the normal case, as a backup we
+            // read from the system property.
+            return getPhoneTypeFromProperty(subscription);
+        }
+    }
+
+    /**
+     * Returns a constant indicating the device phone type.  This
+     * indicates the type of radio used to transmit voice calls.
+     *
+     * @see #PHONE_TYPE_NONE
+     * @see #PHONE_TYPE_GSM
+     * @see #PHONE_TYPE_CDMA
+     * @see #PHONE_TYPE_SIP
+     *
+     * @param subscription for which phone type is returned
+     * @hide
+     */
+    public int getPhoneType(int subscription) {
+        if (!TelephonyManager.getDefault().isVoiceCapable()) {
+            return TelephonyManager.PHONE_TYPE_NONE;
+        }
+        return getCurrentPhoneType(subscription);
+    }
+
+    private int getPhoneTypeFromProperty(int subscription) {
+        String type =
+            getTelephonyProperty
+                (TelephonyProperties.CURRENT_ACTIVE_PHONE, subscription, null);
+        if (type != null) {
+            return (Integer.parseInt(type));
+        } else {
+            return getPhoneTypeFromNetworkType(subscription);
+        }
+    }
+
+    private int getPhoneTypeFromNetworkType(int subscription) {
+        // When the system property CURRENT_ACTIVE_PHONE, has not been set,
+        // use the system property for default network type.
+        // This is a fail safe, and can only happen at first boot.
+        String mode = getTelephonyProperty("ro.telephony.default_network", subscription, null);
+        if (mode != null) {
+            return TelephonyManager.getPhoneType(Integer.parseInt(mode));
+        }
+        return TelephonyManager.PHONE_TYPE_NONE;
+    }
+
+    //
+    //
+    // Current Network
+    //
+    //
+
+    /**
+     * Returns the alphabetic name of current registered operator
+     * for a particular subscription.
+     * <p>
+     * Availability: Only when user is registered to a network. Result may be
+     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if
+     * on a CDMA network).
+     * @param subscription
+     */
+    public String getNetworkOperatorName(int subscription) {
+
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_ALPHA,
+                subscription, "");
+    }
+
+    /**
+     * Returns the numeric name (MCC+MNC) of current registered operator
+     * for a particular subscription.
+     * <p>
+     * Availability: Only when user is registered to a network. Result may be
+     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if
+     * on a CDMA network).
+     *
+     * @param subscription
+     */
+    public String getNetworkOperator(int subscription) {
+
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC,
+                subscription, "");
+     }
+
+    /**
+     * Returns true if the device is considered roaming on the current
+     * network for a subscription.
+     * <p>
+     * Availability: Only when user registered to a network.
+     *
+     * @param subscription
+     */
+    public boolean isNetworkRoaming(int subscription) {
+        return "true".equals(getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_ISROAMING,
+                subscription, null));
+    }
+
+    /**
+     * Returns the ISO country code equivalent of the current registered
+     * operator's MCC (Mobile Country Code).
+     * <p>
+     * Availability: Only when user is registered to a network. Result may be
+     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if
+     * on a CDMA network).
+     *
+     * @param subscription for which Network CountryIso is returned
+     * @hide
+     */
+    public String getNetworkCountryIso(int subscription) {
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY,
+                subscription, "");
+    }
+
+    /**
+     * Returns a constant indicating the radio technology (network type)
+     * currently in use on the device for data transmission for a subscription
+     * @return the network type
+     *
+     * @param subscription for which network type is returned
+     *
+     * @see #NETWORK_TYPE_UNKNOWN
+     * @see #NETWORK_TYPE_GPRS
+     * @see #NETWORK_TYPE_EDGE
+     * @see #NETWORK_TYPE_UMTS
+     * @see #NETWORK_TYPE_HSDPA
+     * @see #NETWORK_TYPE_HSUPA
+     * @see #NETWORK_TYPE_HSPA
+     * @see #NETWORK_TYPE_CDMA
+     * @see #NETWORK_TYPE_EVDO_0
+     * @see #NETWORK_TYPE_EVDO_A
+     * @see #NETWORK_TYPE_EVDO_B
+     * @see #NETWORK_TYPE_1xRTT
+     * @see #NETWORK_TYPE_IDEN
+     * @see #NETWORK_TYPE_LTE
+     * @see #NETWORK_TYPE_EHRPD
+     * @see #NETWORK_TYPE_HSPAP
+     */
+    public int getNetworkType(int subscription) {
+        try {
+            ITelephonyMSim iTelephony = getITelephonyMSim();
+            if (iTelephony != null) {
+                return iTelephony.getNetworkType(subscription);
+            } else {
+                // This can happen when the ITelephony interface is not up yet.
+                return TelephonyManager.NETWORK_TYPE_UNKNOWN;
+            }
+        } catch(RemoteException ex) {
+            // This shouldn't happen in the normal case
+            return TelephonyManager.NETWORK_TYPE_UNKNOWN;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return TelephonyManager.NETWORK_TYPE_UNKNOWN;
+        }
+    }
+
+    /**
+     * Returns a constant indicating the radio technology (network type)
+     * currently in use on the device for data transmission.
+     * @return the network type
+     *
+     * @see #NETWORK_TYPE_UNKNOWN
+     * @see #NETWORK_TYPE_GPRS
+     * @see #NETWORK_TYPE_EDGE
+     * @see #NETWORK_TYPE_UMTS
+     * @see #NETWORK_TYPE_HSDPA
+     * @see #NETWORK_TYPE_HSUPA
+     * @see #NETWORK_TYPE_HSPA
+     * @see #NETWORK_TYPE_CDMA
+     * @see #NETWORK_TYPE_EVDO_0
+     * @see #NETWORK_TYPE_EVDO_A
+     * @see #NETWORK_TYPE_EVDO_B
+     * @see #NETWORK_TYPE_1xRTT
+     * @see #NETWORK_TYPE_IDEN
+     * @see #NETWORK_TYPE_LTE
+     * @see #NETWORK_TYPE_EHRPD
+     * @see #NETWORK_TYPE_HSPAP
+     * @see #NETWORK_TYPE_TD_SCDMA
+     *
+     * @hide
+     */
+    public int getDataNetworkType(int subscription) {
+        try{
+            ITelephonyMSim telephony = getITelephonyMSim();
+            if (telephony != null) {
+                return telephony.getDataNetworkType(subscription);
+            } else {
+                // This can happen when the ITelephonyMSim interface is not up yet.
+                return TelephonyManager.NETWORK_TYPE_UNKNOWN;
+            }
+        } catch(RemoteException ex) {
+            // This shouldn't happen in the normal case
+            return TelephonyManager.NETWORK_TYPE_UNKNOWN;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return TelephonyManager.NETWORK_TYPE_UNKNOWN;
+        }
+    }
+
+    /**
+     * Returns the NETWORK_TYPE_xxxx for voice
+     *
+     * @hide
+     */
+    public int getVoiceNetworkType(int subscription) {
+        try{
+            ITelephonyMSim telephony = getITelephonyMSim();
+            if (telephony != null) {
+                return telephony.getVoiceNetworkType(subscription);
+            } else {
+                // This can happen when the ITelephonyMSim interface is not up yet.
+                return TelephonyManager.NETWORK_TYPE_UNKNOWN;
+            }
+        } catch(RemoteException ex) {
+            // This shouldn't happen in the normal case
+            return TelephonyManager.NETWORK_TYPE_UNKNOWN;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return TelephonyManager.NETWORK_TYPE_UNKNOWN;
+        }
+    }
+
+    /**
+     * Returns a string representation of the radio technology (network type)
+     * currently in use on the device.
+     * @param subscription for which network type is returned
+     * @return the name of the radio technology
+     *
+     * @hide pending API council review
+     */
+    public String getNetworkTypeName(int subscription) {
+        return TelephonyManager.getNetworkTypeName(getNetworkType(subscription));
+    }
+
+    //
+    //
+    // SIM Card
+    //
+    //
+
+    /**
+     * @return true if a ICC card is present for a subscription
+     *
+     * @param subscription for which icc card presence is checked
+     */
+    public boolean hasIccCard(int subscription) {
+
+        try {
+            return getITelephonyMSim().hasIccCard(subscription);
+        } catch (RemoteException ex) {
+            // Assume no ICC card if remote exception which shouldn't happen
+            return false;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return false;
+        }
+    }
+
+    /**
+     * Returns a constant indicating the state of the
+     * device SIM card in a slot.
+     *
+     * @param slotId
+     *
+     * @see #SIM_STATE_UNKNOWN
+     * @see #SIM_STATE_ABSENT
+     * @see #SIM_STATE_PIN_REQUIRED
+     * @see #SIM_STATE_PUK_REQUIRED
+     * @see #SIM_STATE_NETWORK_LOCKED
+     * @see #SIM_STATE_READY
+     */
+    public int getSimState(int slotId) {
+        String prop =
+            getTelephonyProperty(TelephonyProperties.PROPERTY_SIM_STATE, slotId, "");
+        if ("ABSENT".equals(prop)) {
+            return TelephonyManager.SIM_STATE_ABSENT;
+        }
+        else if ("PIN_REQUIRED".equals(prop)) {
+            return TelephonyManager.SIM_STATE_PIN_REQUIRED;
+        }
+        else if ("PUK_REQUIRED".equals(prop)) {
+            return TelephonyManager.SIM_STATE_PUK_REQUIRED;
+        }
+        else if ("NETWORK_LOCKED".equals(prop)) {
+            return TelephonyManager.SIM_STATE_NETWORK_LOCKED;
+        }
+        else if ("READY".equals(prop)) {
+            return TelephonyManager.SIM_STATE_READY;
+        }
+        else {
+            return TelephonyManager.SIM_STATE_UNKNOWN;
+        }
+    }
+
+    /**
+     * Returns the MCC+MNC (mobile country code + mobile network code) of the
+     * provider of the SIM. 5 or 6 decimal digits.
+     * <p>
+     * Availability: SIM state must be {@link #SIM_STATE_READY}
+     *
+     * @see #getSimState
+     *
+     * @param subscription for which SimOperator is returned
+     * @hide
+     */
+    public String getSimOperator(int subscription) {
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC,
+                subscription, "");
+    }
+
+    /**
+     * Returns the Service Provider Name (SPN).
+     * <p>
+     * Availability: SIM state must be {@link #SIM_STATE_READY}
+     *
+     * @see #getSimState
+     *
+     * @param subscription for which SimOperatorName is returned
+     * @hide
+     */
+    public String getSimOperatorName(int subscription) {
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_ICC_OPERATOR_ALPHA,
+                subscription, "");
+    }
+
+    /**
+     * Returns the ISO country code equivalent for the SIM provider's country code.
+     *
+     * @param subscription for which SimCountryIso is returned
+     * @hide
+     */
+    public String getSimCountryIso(int subscription) {
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY,
+                subscription, "");
+    }
+
+    /**
+     * Returns the serial number for the given subscription, if applicable. Return null if it is
+     * unavailable.
+     * <p>
+     * Requires Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     */
+    public String getSimSerialNumber(int subscription) {
+        try {
+            return getMSimSubscriberInfo().getIccSerialNumber(subscription);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Return if the current radio is LTE on CDMA. This
+     * is a tri-state return value as for a period of time
+     * the mode may be unknown.
+     *
+     * @return {@link Phone#LTE_ON_CDMA_UNKNOWN}, {@link Phone#LTE_ON_CDMA_FALSE}
+     * or {@link Phone#LTE_ON_CDMA_TRUE}
+     *
+     * @hide
+     */
+    public int getLteOnCdmaMode(int subscription) {
+        try {
+            return getITelephonyMSim().getLteOnCdmaMode(subscription);
+        } catch (RemoteException ex) {
+            // Assume no ICC card if remote exception which shouldn't happen
+            return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
+        }
+    }
+
+    //
+    //
+    // Subscriber Info
+    //
+    //
+
+    /**
+     * Returns the unique subscriber ID, for example, the IMSI for a GSM phone
+     * for a subscription.
+     * Return null if it is unavailable.
+     * <p>
+     * Requires Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     *
+     * @param subscription whose subscriber id is returned
+     */
+    public String getSubscriberId(int subscription) {
+        try {
+            return getMSimSubscriberInfo().getSubscriberId(subscription);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the phone number string for line 1, for example, the MSISDN
+     * for a GSM phone for a particular subscription. Return null if it is unavailable.
+     * <p>
+     * Requires Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     *
+     * @param subscription whose phone number for line 1 is returned
+     */
+    public String getLine1Number(int subscription) {
+        try {
+            return getMSimSubscriberInfo().getLine1Number(subscription);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the alphabetic identifier associated with the line 1 number
+     * for a subscription.
+     * Return null if it is unavailable.
+     * <p>
+     * Requires Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     * @param subscription whose alphabetic identifier associated with line 1 is returned
+     * @hide
+     * nobody seems to call this.
+     */
+    public String getLine1AlphaTag(int subscription) {
+        try {
+            return getMSimSubscriberInfo().getLine1AlphaTag(subscription);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the MSISDN string.
+     * for a GSM phone. Return null if it is unavailable.
+     * <p>
+     * Requires Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     *
+     * @param subscription for which msisdn is returned
+     * @hide
+     */
+    public String getMsisdn(int subscription) {
+        try {
+            return getMSimSubscriberInfo().getMsisdn(subscription);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the voice mail number for a subscription.
+     * Return null if it is unavailable.
+     * <p>
+     * Requires Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     * @param subscription whose voice mail number is returned
+     */
+    public String getVoiceMailNumber(int subscription) {
+        try {
+            return getMSimSubscriberInfo().getVoiceMailNumber(subscription);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the complete voice mail number. Return null if it is unavailable.
+     * <p>
+     * Requires Permission:
+     *   {@link android.Manifest.permission#CALL_PRIVILEGED CALL_PRIVILEGED}
+     *
+     * @param subscription
+     * @hide
+     */
+    public String getCompleteVoiceMailNumber(int subscription) {
+        try {
+            return getMSimSubscriberInfo().getCompleteVoiceMailNumber(subscription);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+
+    /**
+     * Returns the voice mail count for a subscription. Return 0 if unavailable.
+     * <p>
+     * Requires Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     * @param subscription whose voice message count is returned
+     * @hide
+     */
+    public int getVoiceMessageCount(int subscription) {
+        try {
+            return getITelephonyMSim().getVoiceMessageCount(subscription);
+        } catch (RemoteException ex) {
+            return 0;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return 0;
+        }
+    }
+
+    /**
+     * Retrieves the alphabetic identifier associated with the voice
+     * mail number for a subscription.
+     * <p>
+     * Requires Permission:
+     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     * @param subscription whose alphabetic identifier associated with the
+     * voice mail number is returned
+     */
+    public String getVoiceMailAlphaTag(int subscription) {
+        try {
+            return getMSimSubscriberInfo().getVoiceMailAlphaTag(subscription);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * @hide
+     */
+    protected IPhoneSubInfoMSim getMSimSubscriberInfo() {
+        // get it each time because that process crashes a lot
+        return IPhoneSubInfoMSim.Stub.asInterface(ServiceManager.getService("iphonesubinfo_msim"));
+    }
+
+    /**
+     * Returns a constant indicating the call state (cellular) on the device
+     * for a subscription.
+     *
+     * @param subscription whose call state is returned
+     */
+    public int getCallState(int subscription) {
+        try {
+            return getITelephonyMSim().getCallState(subscription);
+        } catch (RemoteException ex) {
+            // the phone process is restarting.
+            return TelephonyManager.CALL_STATE_IDLE;
+        } catch (NullPointerException ex) {
+          // the phone process is restarting.
+          return TelephonyManager.CALL_STATE_IDLE;
+      }
+    }
+
+    /**
+     * Returns a constant indicating the type of activity on a data connection
+     * (cellular).
+     *
+     * @see #DATA_ACTIVITY_NONE
+     * @see #DATA_ACTIVITY_IN
+     * @see #DATA_ACTIVITY_OUT
+     * @see #DATA_ACTIVITY_INOUT
+     * @see #DATA_ACTIVITY_DORMANT
+     */
+    public int getDataActivity() {
+        try {
+            return getITelephonyMSim().getDataActivity();
+        } catch (RemoteException ex) {
+            // the phone process is restarting.
+            return TelephonyManager.DATA_ACTIVITY_NONE;
+        } catch (NullPointerException ex) {
+          // the phone process is restarting.
+          return TelephonyManager.DATA_ACTIVITY_NONE;
+      }
+    }
+
+    /**
+     * Returns a constant indicating the current data connection state
+     * (cellular).
+     *
+     * @see #DATA_DISCONNECTED
+     * @see #DATA_CONNECTING
+     * @see #DATA_CONNECTED
+     * @see #DATA_SUSPENDED
+     */
+    public int getDataState() {
+        try {
+            return getITelephonyMSim().getDataState();
+        } catch (RemoteException ex) {
+            // the phone process is restarting.
+            return TelephonyManager.DATA_DISCONNECTED;
+        } catch (NullPointerException ex) {
+            return TelephonyManager.DATA_DISCONNECTED;
+        }
+    }
+
+    private ITelephonyMSim getITelephonyMSim() {
+        return ITelephonyMSim.Stub.asInterface(ServiceManager.getService(
+                Context.MSIM_TELEPHONY_SERVICE));
+    }
+
+    //
+    //
+    // PhoneStateListener
+    //
+    //
+
+    /**
+     * Registers a listener object to receive notification of changes
+     * in specified telephony states.
+     * <p>
+     * To register a listener, pass a {@link PhoneStateListener}
+     * and specify at least one telephony state of interest in
+     * the events argument.
+     *
+     * At registration, and when a specified telephony state
+     * changes, the telephony manager invokes the appropriate
+     * callback method on the listener object and passes the
+     * current (udpated) values.
+     * <p>
+     * To unregister a listener, pass the listener object and set the
+     * events argument to
+     * {@link PhoneStateListener#LISTEN_NONE LISTEN_NONE} (0).
+     *
+     * @param listener The {@link PhoneStateListener} object to register
+     *                 (or unregister)
+     * @param events The telephony state(s) of interest to the listener,
+     *               as a bitwise-OR combination of {@link PhoneStateListener}
+     *               LISTEN_ flags.
+     */
+    public void listen(PhoneStateListener listener, int events) {
+        String pkgForDebug = sContext != null ? sContext.getPackageName() : "<unknown>";
+        try {
+            Boolean notifyNow = (getITelephonyMSim() != null);
+            sRegistryMsim.listen(pkgForDebug, listener.callback, events, notifyNow,
+                                           listener.mSubscription);
+        } catch (RemoteException ex) {
+            // system process dead
+        } catch (NullPointerException ex) {
+            // system process dead
+        }
+    }
+
+    /**
+     * Returns the CDMA ERI icon index to display for a subscription
+     *
+     * @hide
+     */
+    public int getCdmaEriIconIndex(int subscription) {
+        try {
+            return getITelephonyMSim().getCdmaEriIconIndex(subscription);
+        } catch (RemoteException ex) {
+            // the phone process is restarting.
+            return -1;
+        } catch (NullPointerException ex) {
+            return -1;
+        }
+    }
+
+    /**
+     * Returns the CDMA ERI icon mode for a subscription.
+     * 0 - ON
+     * 1 - FLASHING
+     *
+     * @hide
+     */
+    public int getCdmaEriIconMode(int subscription) {
+        try {
+            return getITelephonyMSim().getCdmaEriIconMode(subscription);
+        } catch (RemoteException ex) {
+            // the phone process is restarting.
+            return -1;
+        } catch (NullPointerException ex) {
+            return -1;
+        }
+    }
+
+    /**
+     * Returns the CDMA ERI text, of a subscription
+     *
+     * @hide
+     */
+    public String getCdmaEriText(int subscription) {
+        try {
+            return getITelephonyMSim().getCdmaEriText(subscription);
+        } catch (RemoteException ex) {
+            // the phone process is restarting.
+            return null;
+        } catch (NullPointerException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns all observed cell information of the device.
+     *
+     * @return List of CellInfo or null if info unavailable
+     * for subscription.
+     *
+     * <p>Requires Permission:
+     * (@link android.Manifest.permission#ACCESS_COARSE_UPDATES}
+     *
+     * @hide pending API review
+     */
+    public List<CellInfo> getAllCellInfo() {
+        try {
+            return getITelephonyMSim().getAllCellInfo();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Sets the telephony property with the value specified.
+     *
+     * @hide
+     */
+    public static void setTelephonyProperty(String property, int index, String value) {
+        String propVal = "";
+        String p[] = null;
+        String prop = SystemProperties.get(property);
+
+        if (prop != null) {
+            p = prop.split(",");
+        }
+
+        if (index < 0) return;
+
+        for (int i = 0; i < index; i++) {
+            String str = "";
+            if ((p != null) && (i < p.length)) {
+                str = p[i];
+            }
+            propVal = propVal + str + ",";
+        }
+
+        propVal = propVal + value;
+        if (p != null) {
+            for (int i = index+1; i < p.length; i++) {
+                propVal = propVal + "," + p[i];
+            }
+        }
+        SystemProperties.set(property, propVal);
+    }
+
+    /**
+     * Gets the telephony property.
+     *
+     * @hide
+     */
+    public static String getTelephonyProperty(String property, int index, String defaultVal) {
+        String propVal = null;
+        String prop = SystemProperties.get(property);
+
+        if ((prop != null) && (prop.length() > 0)) {
+            String values[] = prop.split(",");
+            if ((index >= 0) && (index < values.length) && (values[index] != null)) {
+                propVal = values[index];
+            }
+        }
+        return propVal == null ? defaultVal : propVal;
+    }
+
+    /**
+     * Returns Default subscription.
+     * Returns default value 0, if default subscription is not available
+     */
+    public int getDefaultSubscription() {
+        try {
+            return getITelephonyMSim().getDefaultSubscription();
+        } catch (RemoteException ex) {
+            return MSimConstants.DEFAULT_SUBSCRIPTION;
+        } catch (NullPointerException ex) {
+            return MSimConstants.DEFAULT_SUBSCRIPTION;
+        }
+    }
+
+    /**
+     * Returns the designated data subscription.
+     */
+    public int getPreferredDataSubscription() {
+        try {
+            return getITelephonyMSim().getPreferredDataSubscription();
+        } catch (RemoteException ex) {
+            return MSimConstants.DEFAULT_SUBSCRIPTION;
+        } catch (NullPointerException ex) {
+            return MSimConstants.DEFAULT_SUBSCRIPTION;
+        }
+    }
+
+    /**
+     * Sets the designated data subscription.
+     */
+    public boolean setPreferredDataSubscription(int subscription) {
+        try {
+            return getITelephonyMSim().setPreferredDataSubscription(subscription);
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+    }
+
+    /**
+     * Returns the preferred voice subscription.
+     */
+    public int getPreferredVoiceSubscription() {
+        try {
+            return getITelephonyMSim().getPreferredVoiceSubscription();
+        } catch (RemoteException ex) {
+            return MSimConstants.DEFAULT_SUBSCRIPTION;
+        } catch (NullPointerException ex) {
+            return MSimConstants.DEFAULT_SUBSCRIPTION;
+        }
+    }
+
+    /**
+     * Convenience function for retrieving a value from the secure settings
+     * value list as an integer.  Note that internally setting values are
+     * always stored as strings; this function converts the string to an
+     * integer for you.
+     * <p>
+     * This version does not take a default value.  If the setting has not
+     * been set, or the string value is not a number,
+     * it throws {@link SettingNotFoundException}.
+     *
+     * @param cr The ContentResolver to access.
+     * @param name The name of the setting to retrieve.
+     * @param index The index of the list
+     *
+     * @throws SettingNotFoundException Thrown if a setting by the given
+     * name can't be found or the setting value is not an integer.
+     *
+     * @return The value at the given index of settings.
+     * @hide
+     */
+    public static int getIntAtIndex(android.content.ContentResolver cr,
+            String name, int index)
+            throws android.provider.Settings.SettingNotFoundException {
+        String v = android.provider.Settings.Global.getString(cr, name);
+        if (v != null) {
+            String valArray[] = v.split(",");
+            if ((index >= 0) && (index < valArray.length) && (valArray[index] != null)) {
+                try {
+                    return Integer.parseInt(valArray[index]);
+                } catch (NumberFormatException e) {
+                    //Log.e(TAG, "Exception while parsing Integer: ", e);
+                }
+            }
+        }
+        throw new android.provider.Settings.SettingNotFoundException(name);
+    }
+
+    /**
+     * Convenience function for updating settings value as coma separated
+     * integer values. This will either create a new entry in the table if the
+     * given name does not exist, or modify the value of the existing row
+     * with that name.  Note that internally setting values are always
+     * stored as strings, so this function converts the given value to a
+     * string before storing it.
+     *
+     * @param cr The ContentResolver to access.
+     * @param name The name of the setting to modify.
+     * @param index The index of the list
+     * @param value The new value for the setting to be added to the list.
+     * @return true if the value was set, false on database errors
+     * @hide
+     */
+    public static boolean putIntAtIndex(android.content.ContentResolver cr,
+            String name, int index, int value) {
+        String data = "";
+        String valArray[] = null;
+        String v = android.provider.Settings.Global.getString(cr, name);
+
+        if (v != null) {
+            valArray = v.split(",");
+        }
+
+        // Copy the elements from valArray till index
+        for (int i = 0; i < index; i++) {
+            String str = "";
+            if ((valArray != null) && (i < valArray.length)) {
+                str = valArray[i];
+            }
+            data = data + str + ",";
+        }
+
+        data = data + value;
+
+        // Copy the remaining elements from valArray if any.
+        if (valArray != null) {
+            for (int i = index+1; i < valArray.length; i++) {
+                data = data + "," + valArray[i];
+            }
+        }
+        return android.provider.Settings.Global.putString(cr, name, data);
+    }
+}
diff --git a/telephony/java/android/telephony/PhoneNumberUtils.java b/telephony/java/android/telephony/PhoneNumberUtils.java
index e3a1aa6..7de4c6e 100644
--- a/telephony/java/android/telephony/PhoneNumberUtils.java
+++ b/telephony/java/android/telephony/PhoneNumberUtils.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2006 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -36,6 +38,7 @@ import android.text.TextUtils;
 import android.telephony.Rlog;
 import android.util.SparseIntArray;
 
+import static com.android.internal.telephony.MSimConstants.SUBSCRIPTION_KEY;
 import static com.android.internal.telephony.TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY;
 import static com.android.internal.telephony.TelephonyProperties.PROPERTY_IDP_STRING;
 import static com.android.internal.telephony.TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY;
@@ -166,6 +169,12 @@ public class PhoneNumberUtils
         // TODO: We don't check for SecurityException here (requires
         // CALL_PRIVILEGED permission).
         if (scheme.equals("voicemail")) {
+            if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+                int subscription = intent.getIntExtra(SUBSCRIPTION_KEY,
+                        MSimTelephonyManager.getDefault().getPreferredVoiceSubscription());
+                return MSimTelephonyManager.getDefault()
+                        .getCompleteVoiceMailNumber(subscription);
+            }
             return TelephonyManager.getDefault().getCompleteVoiceMailNumber();
         }
 
@@ -1688,9 +1697,18 @@ public class PhoneNumberUtils
         // to the list.
         number = extractNetworkPortionAlt(number);
 
-        // retrieve the list of emergency numbers
-        // check read-write ecclist property first
-        String numbers = SystemProperties.get("ril.ecclist");
+        String numbers = "";
+        for (int i = 0; i < MSimTelephonyManager.getDefault().getPhoneCount(); i++) {
+            // retrieve the list of emergency numbers
+            // check read-write ecclist property first
+            String ecclist = (i == 0) ? "ril.ecclist" : ("ril.ecclist" + i);
+
+            if (!TextUtils.isEmpty(numbers)) {
+                numbers = numbers + ",";
+            }
+            numbers = numbers + SystemProperties.get(ecclist);
+        }
+
         if (TextUtils.isEmpty(numbers)) {
             // then read-only ecclist property since old RIL only uses this
             numbers = SystemProperties.get("ro.ril.ecclist");
@@ -1831,7 +1849,13 @@ public class PhoneNumberUtils
         String vmNumber;
 
         try {
-            vmNumber = TelephonyManager.getDefault().getVoiceMailNumber();
+            if (MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+                int subscription = MSimTelephonyManager.getDefault()
+                        .getPreferredVoiceSubscription();
+                vmNumber = MSimTelephonyManager.getDefault().getVoiceMailNumber(subscription);
+            } else {
+                vmNumber = TelephonyManager.getDefault().getVoiceMailNumber();
+            }
         } catch (SecurityException ex) {
             return false;
         }
diff --git a/telephony/java/android/telephony/PhoneStateListener.java b/telephony/java/android/telephony/PhoneStateListener.java
index 267c0d9..ad37f87 100644
--- a/telephony/java/android/telephony/PhoneStateListener.java
+++ b/telephony/java/android/telephony/PhoneStateListener.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -25,6 +27,8 @@ import android.telephony.CellLocation;
 import android.telephony.CellInfo;
 import android.telephony.Rlog;
 import android.os.Looper;
+import android.telephony.MSimTelephonyManager;
+
 import com.android.internal.telephony.IPhoneStateListener;
 
 import java.util.List;
@@ -165,7 +169,22 @@ public class PhoneStateListener {
      */
     public static final int LISTEN_CELL_INFO = 0x00000400;
 
+    /**
+     * Subscription used to listen to the phone state changes
+     * @hide
+     */
+    protected int mSubscription = 0;
+
     public PhoneStateListener() {
+        // If subscription is not passed set the default subscription.
+        mSubscription = MSimTelephonyManager.getDefault().getDefaultSubscription();
+    }
+
+    /**
+     * @hide
+     */
+    public PhoneStateListener(int subscription) {
+        mSubscription = subscription;
     }
 
     /**
diff --git a/telephony/java/android/telephony/ServiceState.java b/telephony/java/android/telephony/ServiceState.java
index adf058c..3250543 100644
--- a/telephony/java/android/telephony/ServiceState.java
+++ b/telephony/java/android/telephony/ServiceState.java
@@ -148,6 +148,11 @@ public class ServiceState implements Parcelable {
      * @hide
      */
     public static final int RIL_RADIO_TECHNOLOGY_GSM = 16;
+    /**
+     * TD-SCDMA
+     * @hide
+     */
+    public static final int RIL_RADIO_TECHNOLOGY_TD_SCDMA = 17;
 
     /**
      * Available registration states for GSM, UMTS and CDMA.
@@ -183,7 +188,7 @@ public class ServiceState implements Parcelable {
     private int mSystemId;
     private int mCdmaRoamingIndicator;
     private int mCdmaDefaultRoamingIndicator;
-    private int mCdmaEriIconIndex;
+    private int mCdmaEriIconIndex = 1; //EriInfo.ROAMING_INDICATOR_OFF;
     private int mCdmaEriIconMode;
 
     /**
@@ -536,6 +541,9 @@ public class ServiceState implements Parcelable {
             case RIL_RADIO_TECHNOLOGY_GSM:
                 rtString = "GSM";
                 break;
+            case RIL_RADIO_TECHNOLOGY_TD_SCDMA:
+                rtString = "TD-SCDMA";
+                break;
             default:
                 rtString = "Unexpected";
                 Rlog.w(LOG_TAG, "Unexpected radioTechnology=" + rt);
@@ -801,6 +809,10 @@ public class ServiceState implements Parcelable {
         case ServiceState.RIL_RADIO_TECHNOLOGY_HSPAP:
         case ServiceState.RIL_RADIO_TECHNOLOGY_DCHSPAP:
             return TelephonyManager.NETWORK_TYPE_HSPAP;
+        case ServiceState.RIL_RADIO_TECHNOLOGY_GSM:
+            return TelephonyManager.NETWORK_TYPE_GSM;
+        case ServiceState.RIL_RADIO_TECHNOLOGY_TD_SCDMA:
+            return TelephonyManager.NETWORK_TYPE_TD_SCDMA;
         default:
             return TelephonyManager.NETWORK_TYPE_UNKNOWN;
         }
@@ -851,7 +863,8 @@ public class ServiceState implements Parcelable {
                 || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE
                 || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP
                 || radioTechnology == RIL_RADIO_TECHNOLOGY_DCHSPAP
-                || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM;
+                || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM
+                || radioTechnology == RIL_RADIO_TECHNOLOGY_TD_SCDMA;
     }
 
     /** @hide */
diff --git a/telephony/java/android/telephony/SignalStrength.java b/telephony/java/android/telephony/SignalStrength.java
index 9958f52..7171efa 100644
--- a/telephony/java/android/telephony/SignalStrength.java
+++ b/telephony/java/android/telephony/SignalStrength.java
@@ -63,6 +63,7 @@ public class SignalStrength implements Parcelable {
     private int mLteRsrq;
     private int mLteRssnr;
     private int mLteCqi;
+    private int mTdScdmaRscp;
 
     private boolean isGsm; // This value is set by the ServiceStateTracker onSignalStrengthResult
 
@@ -102,6 +103,7 @@ public class SignalStrength implements Parcelable {
         mLteRsrq = INVALID;
         mLteRssnr = INVALID;
         mLteCqi = INVALID;
+        mTdScdmaRscp = INVALID;
         isGsm = true;
     }
 
@@ -126,6 +128,7 @@ public class SignalStrength implements Parcelable {
         mLteRsrq = INVALID;
         mLteRssnr = INVALID;
         mLteCqi = INVALID;
+        mTdScdmaRscp = INVALID;
         isGsm = gsmFlag;
     }
 
@@ -152,6 +155,22 @@ public class SignalStrength implements Parcelable {
     public SignalStrength(int gsmSignalStrength, int gsmBitErrorRate,
             int cdmaDbm, int cdmaEcio,
             int evdoDbm, int evdoEcio, int evdoSnr,
+            int lteSignalStrength, int lteRsrp, int lteRsrq, int lteRssnr, int lteCqi,
+            int tdScdmaRscp, boolean gsmFlag) {
+        initialize(gsmSignalStrength, gsmBitErrorRate, cdmaDbm, cdmaEcio,
+                evdoDbm, evdoEcio, evdoSnr, lteSignalStrength, lteRsrp,
+                lteRsrq, lteRssnr, lteCqi, gsmFlag);
+        mTdScdmaRscp = tdScdmaRscp;
+    }
+
+    /**
+     * Constructor
+     *
+     * @hide
+     */
+    public SignalStrength(int gsmSignalStrength, int gsmBitErrorRate,
+            int cdmaDbm, int cdmaEcio,
+            int evdoDbm, int evdoEcio, int evdoSnr,
             boolean gsmFlag) {
         initialize(gsmSignalStrength, gsmBitErrorRate, cdmaDbm, cdmaEcio,
                 evdoDbm, evdoEcio, evdoSnr, 99, INVALID,
@@ -228,6 +247,7 @@ public class SignalStrength implements Parcelable {
         mLteRsrq = lteRsrq;
         mLteRssnr = lteRssnr;
         mLteCqi = lteCqi;
+        mTdScdmaRscp = INVALID;
         isGsm = gsm;
         if (DBG) log("initialize: " + toString());
     }
@@ -248,6 +268,7 @@ public class SignalStrength implements Parcelable {
         mLteRsrq = s.mLteRsrq;
         mLteRssnr = s.mLteRssnr;
         mLteCqi = s.mLteCqi;
+        mTdScdmaRscp = s.mTdScdmaRscp;
         isGsm = s.isGsm;
     }
 
@@ -271,6 +292,7 @@ public class SignalStrength implements Parcelable {
         mLteRsrq = in.readInt();
         mLteRssnr = in.readInt();
         mLteCqi = in.readInt();
+        mTdScdmaRscp = in.readInt();
         isGsm = (in.readInt() != 0);
     }
 
@@ -297,7 +319,10 @@ public class SignalStrength implements Parcelable {
         ss.mLteRsrq = in.readInt();
         ss.mLteRssnr = in.readInt();
         ss.mLteCqi = in.readInt();
-
+        // ignore the timingAdvance field since
+        // the frameworks is not utilizing this field
+        in.readInt();
+        ss.mTdScdmaRscp = in.readInt();
         return ss;
     }
 
@@ -317,6 +342,7 @@ public class SignalStrength implements Parcelable {
         out.writeInt(mLteRsrq);
         out.writeInt(mLteRssnr);
         out.writeInt(mLteCqi);
+        out.writeInt(mTdScdmaRscp);
         out.writeInt(isGsm ? 1 : 0);
     }
 
@@ -372,6 +398,10 @@ public class SignalStrength implements Parcelable {
         mLteRsrq = ((mLteRsrq >= 3) && (mLteRsrq <= 20)) ? -mLteRsrq : SignalStrength.INVALID;
         mLteRssnr = ((mLteRssnr >= -200) && (mLteRssnr <= 300) && !(mLteRsrq == SignalStrength.INVALID && mLteRssnr == -1)) ? mLteRssnr
                 : SignalStrength.INVALID;
+
+        mTdScdmaRscp = ((mTdScdmaRscp >= 25) && (mTdScdmaRscp <= 120))
+                ? -mTdScdmaRscp : SignalStrength.INVALID;
+
         // Cqi no change
         if (DBG) log("Signal after validate=" + this);
     }
@@ -479,14 +509,17 @@ public class SignalStrength implements Parcelable {
      * @hide
      */
     public int getLevel() {
-        int level;
+        int level = 0;
 
         if (isGsm) {
             boolean lteChecks = (getLteRsrp() == INVALID && getLteRsrq() == INVALID && getLteRssnr() == INVALID && getLteSignalStrength() == 99);
             boolean oldRil = needsOldRilFeature("signalstrength");
             level = getLteLevel();
             if ((level == SIGNAL_STRENGTH_NONE_OR_UNKNOWN && getGsmAsuLevel() != 99 && lteChecks) || oldRil) {
-                level = getGsmLevel();
+                level = getTdScdmaLevel();
+                if (level == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
+                    level = getGsmLevel();
+                }
             }
         } else {
             int cdmaLevel = getCdmaLevel();
@@ -512,12 +545,16 @@ public class SignalStrength implements Parcelable {
      * @hide
      */
     public int getAsuLevel() {
-        int asuLevel;
+        int asuLevel = 0;
         if (isGsm) {
             boolean oldRil = needsOldRilFeature("signalstrength");
             boolean lteChecks = (getLteRsrp() == INVALID && getLteRsrq() == INVALID && getLteRssnr() == INVALID && getLteSignalStrength() == 99);
             if ((getLteLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN && getGsmAsuLevel() != 99 && lteChecks) || oldRil) {
-                asuLevel = getGsmAsuLevel();
+                if (getTdScdmaLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
+                    asuLevel = getGsmAsuLevel();
+                } else {
+                    asuLevel = getTdScdmaAsuLevel();
+                }
             } else {
                 asuLevel = getLteAsuLevel();
             }
@@ -545,13 +582,17 @@ public class SignalStrength implements Parcelable {
      * @hide
      */
     public int getDbm() {
-        int dBm;
+        int dBm = INVALID;
 
         if(isGsm()) {
             boolean oldRil = needsOldRilFeature("signalstrength");
             boolean lteChecks = (getLteRsrp() == INVALID && getLteRsrq() == INVALID && getLteRssnr() == INVALID && getLteSignalStrength() == 99);
             if ((getLteLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN && getGsmAsuLevel() != 99 && lteChecks) || oldRil) {
-                dBm = getGsmDbm();
+                if (getTdScdmaLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
+                    dBm = getGsmDbm();
+                } else {
+                    dBm = getTdScdmaDbm();
+                }
             } else {
                 dBm = getLteDbm();
             }
@@ -848,6 +889,54 @@ public class SignalStrength implements Parcelable {
     }
 
     /**
+     * @return get TD_SCDMA dbm
+     *
+     * @hide
+     */
+    public int getTdScdmaDbm() {
+        return this.mTdScdmaRscp;
+    }
+
+    /**
+     * Get TD-SCDMA as level 0..4
+     * Range : 25 to 120
+     * INT_MAX: 0x7FFFFFFF denotes invalid value
+     * Reference: 3GPP TS 25.123, section 9.1.1.1
+     *
+     * @hide
+     */
+    public int getTdScdmaLevel() {
+        final int tdScdmaDbm = getTdScdmaDbm();
+        int level;
+
+        if ((tdScdmaDbm > -25) || (tdScdmaDbm == SignalStrength.INVALID))
+                level = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
+        else if (tdScdmaDbm >= -49) level = SIGNAL_STRENGTH_GREAT;
+        else if (tdScdmaDbm >= -73) level = SIGNAL_STRENGTH_GOOD;
+        else if (tdScdmaDbm >= -97) level = SIGNAL_STRENGTH_MODERATE;
+        else if (tdScdmaDbm >= -120) level = SIGNAL_STRENGTH_POOR;
+        else level = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
+
+        if (DBG) log("getTdScdmaLevel = " + level);
+        return level;
+     }
+
+    /**
+     * Get the TD-SCDMA signal level as an asu value.
+     *
+     * @hide
+     */
+    public int getTdScdmaAsuLevel() {
+        final int tdScdmaDbm = getTdScdmaDbm();
+        int tdScdmaAsuLevel;
+
+        if (tdScdmaDbm == INVALID) tdScdmaAsuLevel = 255;
+        else tdScdmaAsuLevel = tdScdmaDbm + 120;
+        if (DBG) log("TD-SCDMA Asu level: " + tdScdmaAsuLevel);
+        return tdScdmaAsuLevel;
+    }
+
+    /**
      * @return hash code
      */
     @Override
@@ -859,7 +948,7 @@ public class SignalStrength implements Parcelable {
                 + (mEvdoDbm * primeNum) + (mEvdoEcio * primeNum) + (mEvdoSnr * primeNum)
                 + (mLteSignalStrength * primeNum) + (mLteRsrp * primeNum)
                 + (mLteRsrq * primeNum) + (mLteRssnr * primeNum) + (mLteCqi * primeNum)
-                + (isGsm ? 1 : 0));
+                + (mTdScdmaRscp * primeNum) + (isGsm ? 1 : 0));
     }
 
     /**
@@ -891,6 +980,7 @@ public class SignalStrength implements Parcelable {
                 && mLteRsrq == s.mLteRsrq
                 && mLteRssnr == s.mLteRssnr
                 && mLteCqi == s.mLteCqi
+                && mTdScdmaRscp == s.mTdScdmaRscp
                 && isGsm == s.isGsm);
     }
 
@@ -912,6 +1002,7 @@ public class SignalStrength implements Parcelable {
                 + " " + mLteRsrq
                 + " " + mLteRssnr
                 + " " + mLteCqi
+                + " " + mTdScdmaRscp
                 + " " + (isGsm ? "gsm|lte" : "cdma"));
     }
 
@@ -934,6 +1025,7 @@ public class SignalStrength implements Parcelable {
         mLteRsrq = m.getInt("LteRsrq");
         mLteRssnr = m.getInt("LteRssnr");
         mLteCqi = m.getInt("LteCqi");
+        mTdScdmaRscp = m.getInt("TdScdma");
         isGsm = m.getBoolean("isGsm");
     }
 
@@ -956,6 +1048,7 @@ public class SignalStrength implements Parcelable {
         m.putInt("LteRsrq", mLteRsrq);
         m.putInt("LteRssnr", mLteRssnr);
         m.putInt("LteCqi", mLteCqi);
+        m.putInt("TdScdma", mTdScdmaRscp);
         m.putBoolean("isGsm", Boolean.valueOf(isGsm));
     }
 
diff --git a/telephony/java/android/telephony/TelephonyManager.java b/telephony/java/android/telephony/TelephonyManager.java
index 0dbd24d..10d7b28 100644
--- a/telephony/java/android/telephony/TelephonyManager.java
+++ b/telephony/java/android/telephony/TelephonyManager.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -24,6 +26,8 @@ import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.SystemProperties;
 import android.telephony.Rlog;
+import android.provider.Settings;
+import android.provider.Settings.SettingNotFoundException;
 
 import com.android.internal.telephony.IPhoneSubInfo;
 import com.android.internal.telephony.ITelephony;
@@ -433,12 +437,22 @@ public class TelephonyManager {
         case RILConstants.NETWORK_MODE_GSM_UMTS:
         case RILConstants.NETWORK_MODE_LTE_GSM_WCDMA:
         case RILConstants.NETWORK_MODE_LTE_WCDMA:
-        case RILConstants.NETWORK_MODE_LTE_CMDA_EVDO_GSM_WCDMA:
+        case RILConstants.NETWORK_MODE_TD_SCDMA_ONLY:
+        case RILConstants.NETWORK_MODE_TD_SCDMA_WCDMA:
+        case RILConstants.NETWORK_MODE_TD_SCDMA_LTE:
+        case RILConstants.NETWORK_MODE_TD_SCDMA_GSM:
+        case RILConstants.NETWORK_MODE_TD_SCDMA_GSM_LTE:
+        case RILConstants.NETWORK_MODE_TD_SCDMA_GSM_WCDMA:
+        case RILConstants.NETWORK_MODE_TD_SCDMA_WCDMA_LTE:
+        case RILConstants.NETWORK_MODE_TD_SCDMA_GSM_WCDMA_LTE:
             return PhoneConstants.PHONE_TYPE_GSM;
 
         // Use CDMA Phone for the global mode including CDMA
         case RILConstants.NETWORK_MODE_GLOBAL:
         case RILConstants.NETWORK_MODE_LTE_CDMA_EVDO:
+        case RILConstants.NETWORK_MODE_LTE_CMDA_EVDO_GSM_WCDMA:
+        case RILConstants.NETWORK_MODE_TD_SCDMA_CDMA_EVDO_GSM_WCDMA:
+        case RILConstants.NETWORK_MODE_TD_SCDMA_LTE_CDMA_EVDO_GSM_WCDMA:
             return PhoneConstants.PHONE_TYPE_CDMA;
 
         case RILConstants.NETWORK_MODE_LTE_ONLY:
@@ -552,7 +566,8 @@ public class TelephonyManager {
      * on a CDMA network).
      */
     public String getNetworkOperatorName() {
-        return SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_ALPHA,
+                getDefaultSubscription(), "");
     }
 
     /**
@@ -563,7 +578,8 @@ public class TelephonyManager {
      * on a CDMA network).
      */
     public String getNetworkOperator() {
-        return SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC);
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC,
+                getDefaultSubscription(), "");
     }
 
     /**
@@ -573,7 +589,8 @@ public class TelephonyManager {
      * Availability: Only when user registered to a network.
      */
     public boolean isNetworkRoaming() {
-        return "true".equals(SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ISROAMING));
+        return "true".equals(getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_ISROAMING,
+                getDefaultSubscription(), "false"));
     }
 
     /**
@@ -585,7 +602,35 @@ public class TelephonyManager {
      * on a CDMA network).
      */
     public String getNetworkCountryIso() {
-        return SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY);
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY,
+                getDefaultSubscription(), "");
+    }
+
+    /**
+     * Gets the telephony Default Subscription.
+     *
+     * @hide
+     */
+    public static int getDefaultSubscription() {
+        return  SystemProperties.getInt(TelephonyProperties.PROPERTY_DEFAULT_SUBSCRIPTION, 0);
+    }
+
+
+    /**
+     * Gets the telephony property.
+     *
+     * @hide
+     */
+    public static String getTelephonyProperty(String property, int index, String defaultVal) {
+        String propVal = null;
+        String prop = SystemProperties.get(property);
+         if ((prop != null) && (prop.length() > 0)) {
+            String values[] = prop.split(",");
+            if ((index >= 0) && (index < values.length) && (values[index] != null)) {
+                propVal = values[index];
+            }
+        }
+        return propVal == null ? defaultVal : propVal;
     }
 
     /** Network type is unknown */
@@ -620,6 +665,11 @@ public class TelephonyManager {
     public static final int NETWORK_TYPE_EHRPD = 14;
     /** Current network is HSPA+ */
     public static final int NETWORK_TYPE_HSPAP = 15;
+    /** Current network is GSM {@hide} */
+    public static final int NETWORK_TYPE_GSM = 16;
+    /** Current network is TD_SCDMA {@hide} */
+    public static final int NETWORK_TYPE_TD_SCDMA = 17;
+
 
     /**
      * @return the NETWORK_TYPE_xxxx for current data connection.
@@ -649,6 +699,7 @@ public class TelephonyManager {
      * @see #NETWORK_TYPE_LTE
      * @see #NETWORK_TYPE_EHRPD
      * @see #NETWORK_TYPE_HSPAP
+     * @see #NETWORK_TYPE_TD_SCDMA
      *
      * @hide
      */
@@ -722,6 +773,7 @@ public class TelephonyManager {
     public static int getNetworkClass(int networkType) {
         switch (networkType) {
             case NETWORK_TYPE_GPRS:
+            case NETWORK_TYPE_GSM:
             case NETWORK_TYPE_EDGE:
             case NETWORK_TYPE_CDMA:
             case NETWORK_TYPE_1xRTT:
@@ -736,6 +788,7 @@ public class TelephonyManager {
             case NETWORK_TYPE_EVDO_B:
             case NETWORK_TYPE_EHRPD:
             case NETWORK_TYPE_HSPAP:
+            case NETWORK_TYPE_TD_SCDMA:
                 return NETWORK_CLASS_3_G;
             case NETWORK_TYPE_LTE:
                 return NETWORK_CLASS_4_G;
@@ -788,6 +841,10 @@ public class TelephonyManager {
                 return "iDEN";
             case NETWORK_TYPE_HSPAP:
                 return "HSPA+";
+            case NETWORK_TYPE_GSM:
+                return "GSM";
+            case NETWORK_TYPE_TD_SCDMA:
+                return "TD-SCDMA";
             default:
                 return "UNKNOWN";
         }
@@ -814,6 +871,10 @@ public class TelephonyManager {
     public static final int SIM_STATE_NETWORK_LOCKED = 4;
     /** SIM card state: Ready */
     public static final int SIM_STATE_READY = 5;
+    /** SIM card state: SIM Card Error, Sim Card is present but faulty
+     *@hide
+     */
+    public static final int SIM_STATE_CARD_IO_ERROR = 6;
 
     /**
      * @return true if a ICC card is present
@@ -840,9 +901,11 @@ public class TelephonyManager {
      * @see #SIM_STATE_PUK_REQUIRED
      * @see #SIM_STATE_NETWORK_LOCKED
      * @see #SIM_STATE_READY
+     * @see #SIM_STATE_CARD_IO_ERROR
      */
     public int getSimState() {
-        String prop = SystemProperties.get(TelephonyProperties.PROPERTY_SIM_STATE);
+        String prop = getTelephonyProperty(TelephonyProperties.PROPERTY_SIM_STATE,
+                getDefaultSubscription(), "");
         if ("ABSENT".equals(prop)) {
             return SIM_STATE_ABSENT;
         }
@@ -852,12 +915,15 @@ public class TelephonyManager {
         else if ("PUK_REQUIRED".equals(prop)) {
             return SIM_STATE_PUK_REQUIRED;
         }
-        else if ("NETWORK_LOCKED".equals(prop)) {
+        else if ("PERSO_LOCKED".equals(prop)) {
             return SIM_STATE_NETWORK_LOCKED;
         }
         else if ("READY".equals(prop)) {
             return SIM_STATE_READY;
         }
+        else if ("CARD_IO_ERROR".equals(prop)) {
+            return SIM_STATE_CARD_IO_ERROR;
+        }
         else {
             return SIM_STATE_UNKNOWN;
         }
@@ -872,7 +938,8 @@ public class TelephonyManager {
      * @see #getSimState
      */
     public String getSimOperator() {
-        return SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC);
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC,
+                getDefaultSubscription(), "");
     }
 
     /**
@@ -883,14 +950,16 @@ public class TelephonyManager {
      * @see #getSimState
      */
     public String getSimOperatorName() {
-        return SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_ALPHA);
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_ICC_OPERATOR_ALPHA,
+                getDefaultSubscription(), "");
     }
 
     /**
      * Returns the ISO country code equivalent for the SIM provider's country code.
      */
     public String getSimCountryIso() {
-        return SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY);
+        return getTelephonyProperty(TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY,
+                getDefaultSubscription(), "");
     }
 
     /**
diff --git a/telephony/java/android/telephony/gsm/GsmCellLocation.java b/telephony/java/android/telephony/gsm/GsmCellLocation.java
index 313bc82..28360da 100644
--- a/telephony/java/android/telephony/gsm/GsmCellLocation.java
+++ b/telephony/java/android/telephony/gsm/GsmCellLocation.java
@@ -23,17 +23,14 @@ import android.telephony.CellLocation;
  * Represents the cell location on a GSM phone.
  */
 public class GsmCellLocation extends CellLocation {
-    private int mLac;
-    private int mCid;
-    private int mPsc;
+    private int mLac = -1;
+    private int mCid = -1;
+    private int mPsc = -1;
 
     /**
-     * Empty constructor.  Initializes the LAC and CID to -1.
+     * Empty constructor.
      */
     public GsmCellLocation() {
-        mLac = -1;
-        mCid = -1;
-        mPsc = -1;
     }
 
     /**
diff --git a/telephony/java/com/android/internal/telephony/DctConstants.java b/telephony/java/com/android/internal/telephony/DctConstants.java
index 4be11b8..2925d3f 100644
--- a/telephony/java/com/android/internal/telephony/DctConstants.java
+++ b/telephony/java/com/android/internal/telephony/DctConstants.java
@@ -1,5 +1,8 @@
 /*
  * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -97,6 +100,9 @@ public class DctConstants {
     public static final int CMD_ENABLE_MOBILE_PROVISIONING = BASE + 37;
     public static final int CMD_IS_PROVISIONING_APN = BASE + 38;
     public static final int EVENT_PROVISIONING_APN_ALARM = BASE + 39;
+    public static final int EVENT_DATA_RAT_CHANGED = BASE + 40;
+    public static final int EVENT_MODEM_DATA_PROFILE_READY= BASE + 41;
+    public static final int CMD_NET_STAT_POLL = BASE + 42;
 
     /***** Constants *****/
 
diff --git a/telephony/java/com/android/internal/telephony/ISms.aidl b/telephony/java/com/android/internal/telephony/ISms.aidl
index 2e2c510..ab0115b 100644
--- a/telephony/java/com/android/internal/telephony/ISms.aidl
+++ b/telephony/java/com/android/internal/telephony/ISms.aidl
@@ -1,4 +1,6 @@
 /*
+** Copyright (c) 2012, The Linux Foundation. All rights reserved.
+** Not a Contribution.
 ** Copyright 2007, The Android Open Source Project
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
@@ -120,6 +122,35 @@ interface ISms {
             in PendingIntent sentIntent, in PendingIntent deliveryIntent);
 
     /**
+     * Send an SMS with priority.
+     *
+     * @param destAddr the address to send the message to
+     * @param smsc the SMSC to send the message through, or NULL for the
+     *  default SMSC
+     * @param text the body of the message to send
+     * @param sentIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is sucessfully sent, or failed.
+     *  The result code will be <code>Activity.RESULT_OK<code> for success,
+     *  or one of these errors:<br>
+     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
+     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
+     *  <code>RESULT_ERROR_NULL_PDU</code><br>
+     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
+     *  the extra "errorCode" containing a radio technology specific value,
+     *  generally only useful for troubleshooting.<br>
+     *  The per-application based SMS control checks sentIntent. If sentIntent
+     *  is NULL the caller will be checked against all unknown applications,
+     *  which cause smaller number of SMS to be sent in checking period.
+     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
+     *  broadcast when the message is delivered to the recipient.  The
+     *  raw pdu of the status report is in the extended data ("pdu").
+     * @param priority Priority level of the message
+     */
+    void sendTextWithPriority(String callingPkg, in String destAddr, in String scAddr,
+            in String text, in PendingIntent sentIntent, in PendingIntent deliveryIntent,
+            in int priority);
+
+    /**
      * Send a multi-part text based SMS.
      *
      * @param destinationAddress the address to send the message to
diff --git a/telephony/java/com/android/internal/telephony/ITelephony.aidl b/telephony/java/com/android/internal/telephony/ITelephony.aidl
index be0d709..9167c5a 100644
--- a/telephony/java/com/android/internal/telephony/ITelephony.aidl
+++ b/telephony/java/com/android/internal/telephony/ITelephony.aidl
@@ -152,6 +152,11 @@ interface ITelephony {
     boolean supplyPin(String pin);
 
     /**
+     * Gets the number of attempts remaining for PIN1/PUK1 unlock.
+     */
+    int getIccPin1RetryCount();
+
+    /**
      * Supply puk to unlock the SIM and set SIM pin to new pin.
      *  Blocks until a result is determined.
      * @param puk The puk to check.
diff --git a/telephony/java/com/android/internal/telephony/ITelephonyRegistryMSim.aidl b/telephony/java/com/android/internal/telephony/ITelephonyRegistryMSim.aidl
new file mode 100644
index 0000000..361aa19
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/ITelephonyRegistryMSim.aidl
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import android.content.Intent;
+import android.net.LinkProperties;
+import android.net.LinkCapabilities;
+import android.os.Bundle;
+import android.telephony.CellInfo;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import com.android.internal.telephony.IPhoneStateListener;
+
+interface ITelephonyRegistryMSim {
+    void listen(String pkg, IPhoneStateListener callback, int events, boolean notifyNow,
+            int subscription);
+
+    void notifyCallState(int state, String incomingNumber, in int subscription);
+    void notifyServiceState(in ServiceState state, in int subscription);
+    void notifySignalStrength(in SignalStrength signalStrength, in int subscription);
+    void notifyMessageWaitingChanged(boolean mwi, in int subscription);
+    void notifyCallForwardingChanged(boolean cfi, in int subscription);
+    void notifyDataActivity(int state);
+    void notifyDataConnection(int state, boolean isDataConnectivityPossible,
+            String reason, String apn, String apnType, in LinkProperties linkProperties,
+            in LinkCapabilities linkCapabilities, int networkType, boolean roaming,
+            int subscription);
+    void notifyDataConnectionFailed(String reason, String apnType, int subscription);
+    void notifyCellLocation(in Bundle cellLocation, in int subscription);
+    void notifyOtaspChanged(in int otaspMode);
+    void notifyCellInfo(in List<CellInfo> cellInfo, in int subscription);
+}
diff --git a/telephony/java/com/android/internal/telephony/IccCardConstants.java b/telephony/java/com/android/internal/telephony/IccCardConstants.java
index 236bb2f..a5d54bb 100644
--- a/telephony/java/com/android/internal/telephony/IccCardConstants.java
+++ b/telephony/java/com/android/internal/telephony/IccCardConstants.java
@@ -28,6 +28,8 @@ public class IccCardConstants {
     public static final String INTENT_VALUE_ICC_NOT_READY = "NOT_READY";
     /* ABSENT means ICC is missing */
     public static final String INTENT_VALUE_ICC_ABSENT = "ABSENT";
+    /* CARD_IO_ERROR means for three consecutive times there was SIM IO error */
+    public static final String INTENT_VALUE_ICC_CARD_IO_ERROR = "CARD_IO_ERROR";
     /* LOCKED means ICC is locked by pin or by network */
     public static final String INTENT_VALUE_ICC_LOCKED = "LOCKED";
     /* READY means ICC is ready to access */
@@ -42,8 +44,8 @@ public class IccCardConstants {
     public static final String INTENT_VALUE_LOCKED_ON_PIN = "PIN";
     /* PUK means ICC is locked on PUK1 */
     public static final String INTENT_VALUE_LOCKED_ON_PUK = "PUK";
-    /* NETWORK means ICC is locked on NETWORK PERSONALIZATION */
-    public static final String INTENT_VALUE_LOCKED_NETWORK = "NETWORK";
+    /* PERSO means ICC is locked on PERSONALIZATION */
+    public static final String INTENT_VALUE_LOCKED_PERSO = "PERSO";
     /* PERM_DISABLED means ICC is permanently disabled due to puk fails */
     public static final String INTENT_VALUE_ABSENT_ON_PERM_DISABLED = "PERM_DISABLED";
 
@@ -60,10 +62,12 @@ public class IccCardConstants {
         ABSENT,
         PIN_REQUIRED,
         PUK_REQUIRED,
-        NETWORK_LOCKED,
+        PERSO_LOCKED,
         READY,
         NOT_READY,
-        PERM_DISABLED;
+        PERM_DISABLED,
+        CARD_IO_ERROR,
+        DETECTED;
 
         public boolean isPinLocked() {
             return ((this == PIN_REQUIRED) || (this == PUK_REQUIRED));
@@ -71,8 +75,9 @@ public class IccCardConstants {
 
         public boolean iccCardExist() {
             return ((this == PIN_REQUIRED) || (this == PUK_REQUIRED)
-                    || (this == NETWORK_LOCKED) || (this == READY)
-                    || (this == PERM_DISABLED));
+                    || (this == PERSO_LOCKED) || (this == READY)
+                    || (this == PERM_DISABLED) || (this == CARD_IO_ERROR)
+                    || (this == DETECTED));
         }
     }
 }
diff --git a/telephony/java/com/android/internal/telephony/MSimConstants.java b/telephony/java/com/android/internal/telephony/MSimConstants.java
new file mode 100644
index 0000000..9d35fd3
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/MSimConstants.java
@@ -0,0 +1,62 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.android.internal.telephony;
+
+public class MSimConstants {
+
+    public static final int DEFAULT_SUBSCRIPTION = 0;
+
+    public static final int INVALID_SUBSCRIPTION = -1;
+
+    public static final int RIL_CARD_MAX_APPS    = 8;
+
+    public static final int DEFAULT_CARD_INDEX   = 0;
+
+    public static final int MAX_PHONE_COUNT_SINGLE_SIM = 1;
+
+    public static final int MAX_PHONE_COUNT_DUAL_SIM = 2;
+
+    public static final int MAX_PHONE_COUNT_TRI_SIM = 3;
+
+    public static final String SUBSCRIPTION_KEY  = "subscription";
+
+    public static final int SUB1 = 0;
+    public static final int SUB2 = 1;
+    public static final int SUB3 = 2;
+
+    public static final int EVENT_SUBSCRIPTION_ACTIVATED   = 500;
+    public static final int EVENT_SUBSCRIPTION_DEACTIVATED = 501;
+
+    public enum CardUnavailableReason {
+        REASON_CARD_REMOVED,
+        REASON_RADIO_UNAVAILABLE,
+        REASON_SIM_REFRESH_RESET
+    };
+}
diff --git a/telephony/java/com/android/internal/telephony/PhoneConstants.java b/telephony/java/com/android/internal/telephony/PhoneConstants.java
index 4163255..30ce0c4 100644
--- a/telephony/java/com/android/internal/telephony/PhoneConstants.java
+++ b/telephony/java/com/android/internal/telephony/PhoneConstants.java
@@ -57,6 +57,7 @@ public class PhoneConstants {
     public static final int PHONE_TYPE_GSM = RILConstants.GSM_PHONE;
     public static final int PHONE_TYPE_CDMA = RILConstants.CDMA_PHONE;
     public static final int PHONE_TYPE_SIP = RILConstants.SIP_PHONE;
+    public static final int PHONE_TYPE_IMS = RILConstants.IMS_PHONE;
 
     // Modes for LTE_ON_CDMA
     public static final int LTE_ON_CDMA_UNKNOWN = RILConstants.LTE_ON_CDMA_UNKNOWN;
diff --git a/telephony/java/com/android/internal/telephony/RILConstants.java b/telephony/java/com/android/internal/telephony/RILConstants.java
index 068be85..a6378c8 100644
--- a/telephony/java/com/android/internal/telephony/RILConstants.java
+++ b/telephony/java/com/android/internal/telephony/RILConstants.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2006 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -55,6 +57,16 @@ public interface RILConstants {
     int ILLEGAL_SIM_OR_ME = 15;               /* network selection failure due
                                                  to wrong SIM/ME and no
                                                  retries needed */
+    int DIAL_MODIFIED_TO_USSD = 17;           /* DIAL request modified to USSD */
+    int DIAL_MODIFIED_TO_SS = 18;             /* DIAL request modified to SS */
+    int DIAL_MODIFIED_TO_DIAL = 19;           /* DIAL request modified to DIAL with different data*/
+    int USSD_MODIFIED_TO_DIAL = 20;           /* USSD request modified to DIAL */
+    int USSD_MODIFIED_TO_SS = 21;             /* USSD request modified to SS */
+    int USSD_MODIFIED_TO_USSD = 22;           /* USSD request modified to different USSD request */
+    int SS_MODIFIED_TO_DIAL = 23;             /* SS request modified to DIAL */
+    int SS_MODIFIED_TO_USSD = 24;             /* SS request modified to USSD */
+    int SS_MODIFIED_TO_SS = 25;               /* SS request modified to different SS request */
+    int SUBSCRIPTION_NOT_SUPPORTED = 26;      /* Subscription not supported */
 
     /* NETWORK_MODE_* See ril.h RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE */
     int NETWORK_MODE_WCDMA_PREF     = 0; /* GSM/WCDMA (WCDMA preferred) */
@@ -73,6 +85,17 @@ public interface RILConstants {
     int NETWORK_MODE_LTE_CMDA_EVDO_GSM_WCDMA = 10; /* LTE, CDMA, EvDo, GSM/WCDMA */
     int NETWORK_MODE_LTE_ONLY       = 11; /* LTE Only mode. */
     int NETWORK_MODE_LTE_WCDMA      = 12; /* LTE/WCDMA */
+    int NETWORK_MODE_TD_SCDMA_ONLY            = 13; /* TD-SCDMA only */
+    int NETWORK_MODE_TD_SCDMA_WCDMA           = 14; /* TD-SCDMA and WCDMA */
+    int NETWORK_MODE_TD_SCDMA_LTE             = 15; /* TD-SCDMA and LTE */
+    int NETWORK_MODE_TD_SCDMA_GSM             = 16; /* TD-SCDMA and GSM */
+    int NETWORK_MODE_TD_SCDMA_GSM_LTE         = 17; /* TD-SCDMA,GSM and LTE */
+    int NETWORK_MODE_TD_SCDMA_GSM_WCDMA       = 18; /* TD-SCDMA, GSM/WCDMA */
+    int NETWORK_MODE_TD_SCDMA_WCDMA_LTE       = 19; /* TD-SCDMA, WCDMA and LTE */
+    int NETWORK_MODE_TD_SCDMA_GSM_WCDMA_LTE   = 20; /* TD-SCDMA, GSM/WCDMA and LTE */
+    int NETWORK_MODE_TD_SCDMA_CDMA_EVDO_GSM_WCDMA  = 21; /*TD-SCDMA,EvDo,CDMA,GSM/WCDMA*/
+    int NETWORK_MODE_TD_SCDMA_LTE_CDMA_EVDO_GSM_WCDMA = 22; /* TD-SCDMA/LTE/GSM/WCDMA, CDMA, and
+                                                               EvDo */
     int PREFERRED_NETWORK_MODE      = NETWORK_MODE_WCDMA_PREF;
 
     int CDMA_CELL_BROADCAST_SMS_DISABLED = 1;
@@ -82,6 +105,7 @@ public interface RILConstants {
     int GSM_PHONE = 1;
     int CDMA_PHONE = 2;
     int SIP_PHONE  = 3;
+    int IMS_PHONE = 4;
 
     int LTE_ON_CDMA_UNKNOWN = -1;
     int LTE_ON_CDMA_FALSE = 0;
@@ -159,7 +183,7 @@ cat include/telephony/ril.h | \
     int RIL_REQUEST_ENTER_SIM_PUK2 = 5;
     int RIL_REQUEST_CHANGE_SIM_PIN = 6;
     int RIL_REQUEST_CHANGE_SIM_PIN2 = 7;
-    int RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION = 8;
+    int RIL_REQUEST_ENTER_DEPERSONALIZATION_CODE = 8;
     int RIL_REQUEST_GET_CURRENT_CALLS = 9;
     int RIL_REQUEST_DIAL = 10;
     int RIL_REQUEST_GET_IMSI = 11;
@@ -265,6 +289,10 @@ cat include/telephony/ril.h | \
     int RIL_REQUEST_SET_INITIAL_ATTACH_APN = 111;
     int RIL_REQUEST_IMS_REGISTRATION_STATE = 112;
     int RIL_REQUEST_IMS_SEND_SMS = 113;
+    int RIL_REQUEST_GET_DATA_CALL_PROFILE = 114;
+    int RIL_REQUEST_SET_UICC_SUBSCRIPTION = 115;
+    int RIL_REQUEST_SET_DATA_SUBSCRIPTION = 116;
+
     int RIL_UNSOL_RESPONSE_BASE = 1000;
     int RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED = 1000;
     int RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED = 1001;
@@ -304,5 +332,9 @@ cat include/telephony/ril.h | \
     int RIL_UNSOL_VOICE_RADIO_TECH_CHANGED = 1035;
     int RIL_UNSOL_CELL_INFO_LIST = 1036;
     int RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED = 1037;
+    int RIL_UNSOL_ON_SS = 1038;
+    int RIL_UNSOL_STK_CC_ALPHA_NOTIFY = 1039;
+    int RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED = 1040;
+
     int RIL_UNSOL_STK_SEND_SMS_RESULT = 11002; /* Samsung STK */
 }
diff --git a/telephony/java/com/android/internal/telephony/SmsConstants.java b/telephony/java/com/android/internal/telephony/SmsConstants.java
index 2449108..a36697a 100644
--- a/telephony/java/com/android/internal/telephony/SmsConstants.java
+++ b/telephony/java/com/android/internal/telephony/SmsConstants.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/telephony/java/com/android/internal/telephony/TelephonyIntents.java b/telephony/java/com/android/internal/telephony/TelephonyIntents.java
index a7baf1c..1048d1e 100644
--- a/telephony/java/com/android/internal/telephony/TelephonyIntents.java
+++ b/telephony/java/com/android/internal/telephony/TelephonyIntents.java
@@ -315,4 +315,16 @@ public class TelephonyIntents {
     public static final String EXTRA_PLMN       = "plmn";
     public static final String EXTRA_SHOW_SPN   = "showSpn";
     public static final String EXTRA_SPN        = "spn";
+
+     /**
+     * Managed Roaming Intent. Used by Phone App to show popup to the end user that location update
+     * request rejected with status as "Persistent location update reject", so user can try to do
+     * location update on other Network:</p>
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     * @hide
+     */
+    public static final String ACTION_MANAGED_ROAMING_IND
+            = "codeaurora.intent.action.ACTION_MANAGED_ROAMING_IND";
 }
diff --git a/telephony/java/com/android/internal/telephony/TelephonyProperties.java b/telephony/java/com/android/internal/telephony/TelephonyProperties.java
index 3427bf6..05a8372 100644
--- a/telephony/java/com/android/internal/telephony/TelephonyProperties.java
+++ b/telephony/java/com/android/internal/telephony/TelephonyProperties.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  * Copyright (C) 2006 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -98,7 +100,7 @@ public interface TelephonyProperties
     //****** SIM Card
     /**
      * One of <code>"UNKNOWN"</code> <code>"ABSENT"</code> <code>"PIN_REQUIRED"</code>
-     * <code>"PUK_REQUIRED"</code> <code>"NETWORK_LOCKED"</code> or <code>"READY"</code>
+     * <code>"PUK_REQUIRED"</code> <code>"PERSO_LOCKED"</code> or <code>"READY"</code>
      */
     static String PROPERTY_SIM_STATE = "gsm.sim.state";
 
@@ -108,6 +110,12 @@ public interface TelephonyProperties
      */
     static String PROPERTY_ICC_OPERATOR_NUMERIC = "gsm.sim.operator.numeric";
 
+    /** The MCC+MNC (mobile country code+mobile network code) of the
+     *  provider of the SIM to be used for APNs lookup. 5 or 6 decimal digits.
+     *  Availability: SIM state must be "READY"
+     */
+    static String PROPERTY_APN_SIM_OPERATOR_NUMERIC = "gsm.apn.sim.operator.numeric";
+
     /** PROPERTY_ICC_OPERATOR_ALPHA is also known as the SPN, or Service Provider Name.
      *  Availability: SIM state must be "READY"
      */
@@ -189,6 +197,16 @@ public interface TelephonyProperties
     static final String PROPERTY_TEST_CSIM = "persist.radio.test-csim";
 
     /**
+     * Specify if Android supports VoLTE/VT calls on IMS
+     */
+    static final String CALLS_ON_IMS_ENABLED_PROPERTY = "persist.radio.calls.on.ims";
+
+    /**
+     * Specify if Android supports CSVT calls.
+     */
+    static final String PROPERTY_CSVT_ENABLED = "persist.radio.csvt.enabled";
+
+    /**
      * Ignore RIL_UNSOL_NITZ_TIME_RECEIVED completely, used for debugging/testing.
      */
     static final String PROPERTY_IGNORE_NITZ = "telephony.test.ignore.nitz";
@@ -203,4 +221,21 @@ public interface TelephonyProperties
      * Type: boolean ( true = alpha display enabled, false = alpha display disabled)
      */
     static final String PROPERTY_ALPHA_USRCNF = "persist.atel.noalpha.usrcnf";
+
+     /**
+     * Property to set multi sim feature.
+     * Type:  String(dsds, dsda)
+     */
+    static final String PROPERTY_MULTI_SIM_CONFIG = "persist.multisim.config";
+
+    /**
+     * Property to store default subscription.
+     */
+    static final String PROPERTY_DEFAULT_SUBSCRIPTION = "persist.radio.default.sub";
+
+    /**
+     * Property to enable MMS Mode.
+     * Type: string ( default = silent, enable to = prompt )
+     */
+    static final String PROPERTY_MMS_TRANSACTION = "mms.transaction";
 }
diff --git a/telephony/java/com/android/internal/telephony/msim/IPhoneSubInfoMSim.aidl b/telephony/java/com/android/internal/telephony/msim/IPhoneSubInfoMSim.aidl
new file mode 100644
index 0000000..a0ed2e3
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/msim/IPhoneSubInfoMSim.aidl
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2011-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package com.android.internal.telephony.msim;
+
+/**
+ * Interface used to retrieve various phone-related subscriber information.
+ * {@hide}
+ */
+interface IPhoneSubInfoMSim {
+
+    /**
+     * Retrieves the unique device ID of a subscription for the device, e.g., IMEI
+     * for GSM phones.
+     */
+    String getDeviceId(int subscription);
+
+    /**
+     * Retrieves the software version number of a subscription for the device, e.g., IMEI/SV
+     * for GSM phones.
+     */
+    String getDeviceSvn(int subscription);
+
+    /**
+     * Retrieves the unique subscriber ID of a given subscription, e.g., IMSI for GSM phones.
+     */
+    String getSubscriberId(int subscription);
+
+    /**
+     * Retrieves the serial number of a given subscription.
+     */
+    String getIccSerialNumber(int subscription);
+
+    /**
+     * Retrieves the phone number string for line 1 of a subcription.
+     */
+    String getLine1Number(int subscription);
+
+    /**
+     * Retrieves the alpha identifier for line 1 of a subscription.
+     */
+    String getLine1AlphaTag(int subscription);
+
+    /**
+     * Retrieves the Msisdn of a subscription.
+     */
+    String getMsisdn(int subscription);
+
+    /**
+     * Retrieves the voice mail number of a given subscription.
+     */
+    String getVoiceMailNumber(int subscription);
+
+    /**
+     * Retrieves the complete voice mail number for particular subscription
+     */
+    String getCompleteVoiceMailNumber(int subscription);
+
+    /**
+     * Retrieves the alpha identifier associated with the voice mail number
+     * of a subscription.
+     */
+    String getVoiceMailAlphaTag(int subscription);
+
+}
diff --git a/telephony/java/com/android/internal/telephony/msim/ITelephonyMSim.aidl b/telephony/java/com/android/internal/telephony/msim/ITelephonyMSim.aidl
new file mode 100644
index 0000000..3689e90
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/msim/ITelephonyMSim.aidl
@@ -0,0 +1,373 @@
+/*
+ * Copyright (c) 2011-2013 The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony.msim;
+
+import android.os.Bundle;
+import java.util.List;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.CellInfo;
+
+/**
+ * Interface used to interact with the phone.  Mostly this is used by the
+ * TelephonyManager class.  A few places are still using this directly.
+ * Please clean them up if possible and use TelephonyManager instead.
+ *
+ * {@hide}
+ */
+interface ITelephonyMSim {
+    /**
+     * Dial a number. This doesn't place the call. It displays
+     * the Dialer screen for that subscription.
+     * @param number the number to be dialed. If null, this
+     * would display the Dialer screen with no number pre-filled.
+     * @param subscription user preferred subscription.
+     */
+    void dial(String number, int subscription);
+
+    /**
+     * Place a call to the specified number on particular subscription.
+     * @param number the number to be called.
+     * @param subscription user preferred subscription.
+     */
+    void call(String callingPackage, String number, int subscription);
+
+    /**
+     * If there is currently a call in progress, show the call screen.
+     * The DTMF dialpad may or may not be visible initially, depending on
+     * whether it was up when the user last exited the InCallScreen.
+     *
+     * @return true if the call screen was shown.
+     */
+    boolean showCallScreen();
+
+    /**
+     * Variation of showCallScreen() that also specifies whether the
+     * DTMF dialpad should be initially visible when the InCallScreen
+     * comes up.
+     *
+     * @param showDialpad if true, make the dialpad visible initially,
+     *                    otherwise hide the dialpad initially.
+     * @return true if the call screen was shown.
+     *
+     * @see showCallScreen
+     */
+    boolean showCallScreenWithDialpad(boolean showDialpad);
+
+    /**
+     * End call on particular subscription or go to the Home screen
+     * @param subscription user preferred subscription.
+     * @return whether it hung up
+     */
+    boolean endCall(int subscription);
+
+    /**
+     * Answer the currently-ringing call on particular subscription.
+     *
+     * If there's already a current active call, that call will be
+     * automatically put on hold.  If both lines are currently in use, the
+     * current active call will be ended.
+     *
+     * TODO: provide a flag to let the caller specify what policy to use
+     * if both lines are in use.  (The current behavior is hardwired to
+     * "answer incoming, end ongoing", which is how the CALL button
+     * is specced to behave.)
+     *
+     * TODO: this should be a oneway call (especially since it's called
+     * directly from the key queue thread).
+     *
+     * @param subscription user preferred subscription.
+     */
+    void answerRingingCall(int subscription);
+
+    /**
+     * Silence the ringer if an incoming call is currently ringing.
+     * (If vibrating, stop the vibrator also.)
+     *
+     * It's safe to call this if the ringer has already been silenced, or
+     * even if there's no incoming call.  (If so, this method will do nothing.)
+     *
+     * TODO: this should be a oneway call too (see above).
+     *       (Actually *all* the methods here that return void can
+     *       probably be oneway.)
+     */
+    void silenceRinger();
+
+    /**
+     * Check if a particular subscription has an active or holding call
+     *
+     * @param subscription user preferred subscription.
+     * @return true if the phone state is OFFHOOK.
+     */
+    boolean isOffhook(int subscription);
+
+    /**
+     * Check if an incoming phone call is ringing or call waiting
+     * on a particular subscription.
+     *
+     * @param subscription user preferred subscription.
+     * @return true if the phone state is RINGING.
+     */
+    boolean isRinging(int subscription);
+
+    /**
+     * Check if the phone is idle on a particular subscription.
+     *
+     * @param subscription user preferred subscription.
+     * @return true if the phone state is IDLE.
+     */
+    boolean isIdle(int subscription);
+
+    /**
+     * Check to see if the radio is on or not on particular subscription.
+     * @param subscription user preferred subscription.
+     * @return returns true if the radio is on.
+     */
+    boolean isRadioOn(int subscription);
+
+    /**
+     * Check if the SIM pin lock is enable
+     * for particular subscription.
+     * @param subscription user preferred subscription.
+     * @return true if the SIM pin lock is enabled.
+     */
+    boolean isSimPinEnabled(int subscription);
+
+    /**
+     * Cancels the missed calls notification on particular subscription.
+     * @param subscription user preferred subscription.
+     */
+    void cancelMissedCallsNotification(int subscription);
+
+    /**
+     * Supply a pin to unlock the SIM for particular subscription.
+     * Blocks until a result is determined.
+     * @param pin The pin to check.
+     * @param subscription user preferred subscription.
+     * @return whether the operation was a success.
+     */
+    boolean supplyPin(String pin, int subscription);
+
+    /**
+     * Supply puk to unlock the SIM and set SIM pin to new pin.
+     *  Blocks until a result is determined.
+     * @param puk The puk to check.
+     *        pin The new pin to be set in SIM
+     * @param subscription user preferred subscription.
+     * @return whether the operation was a success.
+     */
+    boolean supplyPuk(String puk, String pin, int subscription);
+
+    /**
+     * Supply a pin to unlock the SIM.  Blocks until a result is determined.
+     * Returns a specific success/error code.
+     * @param pin The pin to check.
+     * @return retValue[0] = Phone.PIN_RESULT_SUCCESS on success. Otherwise error code
+     *         retValue[1] = number of attempts remaining if known otherwise -1
+     */
+    int[] supplyPinReportResult(String pin, int subscription);
+
+    /**
+     * Supply puk to unlock the SIM and set SIM pin to new pin.
+     * Blocks until a result is determined.
+     * Returns a specific success/error code
+     * @param puk The puk to check
+     *        pin The pin to check.
+     * @return retValue[0] = Phone.PIN_RESULT_SUCCESS on success. Otherwise error code
+     *         retValue[1] = number of attempts remaining if known otherwise -1
+     */
+    int[] supplyPukReportResult(String puk, String pin, int subscription);
+
+
+    /**
+    * Gets the number of attempts remaining for PIN1/PUK1 unlock.
+    * @param subscription for which attempts remaining is required.
+    */
+    int getIccPin1RetryCount(int subscription);
+
+    /**
+     * Handles PIN MMI commands (PIN/PIN2/PUK/PUK2), which are initiated
+     * without SEND (so <code>dial</code> is not appropriate) for
+     * a particular subscription.
+     * @param dialString the MMI command to be executed.
+     * @param subscription user preferred subscription.
+     * @return true if MMI command is executed.
+     */
+    boolean handlePinMmi(String dialString, int subscription);
+
+    /**
+     * Toggles the radio on or off on particular subscription.
+     * @param subscription user preferred subscription.
+     */
+    void toggleRadioOnOff(int subscription);
+
+    /**
+     * Set the radio to on or off on particular subscription.
+     * @param subscription user preferred subscription.
+     */
+    boolean setRadio(boolean turnOn, int subscription);
+
+    /**
+     * Request to update location information for a subscrition in service state
+     * @param subscription user preferred subscription.
+     */
+    void updateServiceLocation(int subscription);
+
+    /**
+     * Enable a specific APN type.
+     */
+    int enableApnType(String type);
+
+    /**
+     * Disable a specific APN type.
+     */
+    int disableApnType(String type);
+
+    /**
+     * Allow mobile data connections.
+     */
+    boolean enableDataConnectivity();
+
+    /**
+     * Disallow mobile data connections.
+     */
+    boolean disableDataConnectivity();
+
+    /**
+     * Report whether data connectivity is possible.
+     */
+    boolean isDataConnectivityPossible();
+
+    /**
+     * Returns the call state for a subscription.
+     */
+     int getCallState(int subscription);
+     int getDataActivity();
+     int getDataState();
+
+    /**
+     * Returns the current active phone type as integer for particular subscription.
+     * Returns TelephonyManager.PHONE_TYPE_CDMA if RILConstants.CDMA_PHONE
+     * and TelephonyManager.PHONE_TYPE_GSM if RILConstants.GSM_PHONE
+     * @param subscription user preferred subscription.
+     */
+    int getActivePhoneType(int subscription);
+
+
+    /**
+     * Returns the CDMA ERI icon index to display on particular subscription.
+     * @param subscription user preferred subscription.
+     */
+    int getCdmaEriIconIndex(int subscription);
+
+    /**
+     * Returns the CDMA ERI icon mode on particular subscription,
+     * 0 - ON
+     * 1 - FLASHING
+     * @param subscription user preferred subscription.
+     */
+    int getCdmaEriIconMode(int subscription);
+
+    /**
+     * Returns the CDMA ERI text for particular subscription,
+     * @param subscription user preferred subscription.
+     */
+    String getCdmaEriText(int subscription);
+
+    /**
+     * Returns true if OTA service provisioning needs to run.
+     * Only relevant on some technologies, others will always
+     * return false.
+     */
+    boolean needsOtaServiceProvisioning();
+
+    /**
+     * Returns the unread count of voicemails for a subscription.
+     * @param subscription user preferred subscription.
+     * Returns the unread count of voicemails
+     */
+    int getVoiceMessageCount(int subscription);
+
+    /**
+     * Returns the network type of a subscription.
+     * @param subscription user preferred subscription.
+     * Returns the network type
+     */
+    int getNetworkType(int subscription);
+
+    /**
+      * Returns the data network type of a subscription
+      * @param subscription user preferred subscription.
+      * Returns the network type
+      */
+    int getDataNetworkType(int subscription);
+
+    /**
+      * Returns the voice network type of a subscription
+      * @param subscription user preferred subscription.
+      * Returns the network type
+      */
+    int getVoiceNetworkType(int subscription);
+
+    /**
+     * Return true if an ICC card is present for a subscription.
+     * @param subscription user preferred subscription.
+     * Return true if an ICC card is present
+     */
+    boolean hasIccCard(int subscription);
+
+    /**
+     * Return if the current radio is LTE on CDMA. This
+     * is a tri-state return value as for a period of time
+     * the mode may be unknown.
+     *
+     * @return {@link Phone#LTE_ON_CDMA_UNKNOWN}, {@link Phone#LTE_ON_CDMA_FALSE}
+     * or {@link PHone#LTE_ON_CDMA_TRUE}
+     */
+    int getLteOnCdmaMode(int subscription);
+
+    /**
+     * Returns the all observed cell information of the device.
+     */
+    List<CellInfo> getAllCellInfo();
+
+    /**
+     * get default subscription
+     * @return subscription id
+     */
+    int getDefaultSubscription();
+
+    /**
+     * get user prefered voice subscription
+     * @return subscription id
+     */
+    int getPreferredVoiceSubscription();
+
+    /**
+     * get user prefered data subscription
+     * @return subscription id
+     */
+    int getPreferredDataSubscription();
+
+    /*
+     * Set user prefered data subscription
+     * @return true if success
+     */
+    boolean setPreferredDataSubscription(int subscription);
+}
+
-- 
1.8.1.2

